   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 123               	.global	__vector_15
 125               	__vector_15:
   1:main.c        **** #define F_CPU 1000000UL
   2:main.c        **** 
   3:main.c        **** #include <avr/io.h>
   4:main.c        **** #include <avr/wdt.h>
   5:main.c        **** #include <avr/sleep.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #include <util/delay.h>
   8:main.c        **** #include <math.h>
   9:main.c        **** #include <string.h>
  10:main.c        **** #include <stdio.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <stdbool.h>
  14:main.c        **** #include <avr/pgmspace.h>
  15:main.c        **** #include "hd44780.h"
  16:main.c        **** #include "build_settings.h"
  17:main.c        **** 
  18:main.c        **** #define fpga_addr 0x23
  19:main.c        **** #define pll_addr 0x22
  20:main.c        **** 
  21:main.c        **** #define ROT1_A PE4
  22:main.c        **** #define ROT1_B PE5
  23:main.c        **** #define MENU_BUTTON PF2
  24:main.c        **** #define MODE_BUTTON PF1
  25:main.c        **** #define BAND_BUTTON PF0
  26:main.c        **** #define VOLROT_A PE6
  27:main.c        **** #define VOLROT_B PE7
  28:main.c        **** #define VOL_BUTTON PF4
  29:main.c        **** #define FREQ_BUTTON PE3
  30:main.c        **** #define CLAR_POT PF3
  31:main.c        **** #define MUTE PE0
  32:main.c        **** 
  33:main.c        **** #define LED_RED PD6
  34:main.c        **** #define LED_GREEN PD5
  35:main.c        **** 
  36:main.c        **** #define LSB 0x01
  37:main.c        **** #define LSBN 0x02
  38:main.c        **** #define USB 0x03
  39:main.c        **** #define USBN 0x04
  40:main.c        **** #define CW 0x05
  41:main.c        **** #define CWN 0x06
  42:main.c        **** #define CWNN 0x07
  43:main.c        **** #define AM 0x08
  44:main.c        **** #define AMN 0x09
  45:main.c        **** #define FM 0x0A
  46:main.c        **** 
  47:main.c        **** #define lcd_freq() \
  48:main.c        ****   lcd_goto(0x04);  \
  49:main.c        ****   sprintf(buffer,"%d,%06.2f     ",(int)floor(freq/1000+freq_offset),fmod(freq,1000));  \
  50:main.c        ****   lcd_puts(buffer);  \
  51:main.c        ****   lcd_goto(0x0f);  \
  52:main.c        ****   if (clar > 10)  \
  53:main.c        ****     sprintf(buffer,"+");  \
  54:main.c        ****   else if (clar < -10)  \
  55:main.c        ****     sprintf(buffer,"-");  \
  56:main.c        ****   else  \
  57:main.c        ****     sprintf(buffer," ");  \
  58:main.c        ****   lcd_puts(buffer)
  59:main.c        **** 
  60:main.c        **** 
  61:main.c        **** volatile uint8_t rot_flag, mode_flag, band_flag, timer_flag, vol_flag;
  62:main.c        **** volatile uint16_t step_timer;
  63:main.c        **** volatile uint8_t mode;
  64:main.c        **** volatile uint8_t band;
  65:main.c        **** volatile uint8_t tx_att;
  66:main.c        **** volatile uint8_t band_timer = 255, vol_timer = 255;
  67:main.c        **** volatile uint16_t bandf, tx, pll_n = 0;
  68:main.c        **** volatile uint8_t rx_att;
  69:main.c        **** volatile bool rffe_rx_att;
  70:main.c        **** 
  71:main.c        **** ISR(TIMER0_COMP_vect) {
 127               	.LM0:
 128               	.LFBB1:
 129 0000 1F92      		push r1
 130 0002 0F92      		push r0
 131 0004 0FB6      		in r0,__SREG__
 132 0006 0F92      		push r0
 133 0008 1124      		clr __zero_reg__
 134 000a 2F93      		push r18
 135 000c 8F93      		push r24
 136 000e 9F93      		push r25
 137               	/* prologue: Signal */
 138               	/* frame size = 0 */
 139               	/* stack size = 6 */
 140               	.L__stack_usage = 6
  72:main.c        ****   if (step_timer < 500)
 142               	.LM1:
 143 0010 8091 0000 		lds r24,step_timer
 144 0014 9091 0000 		lds r25,step_timer+1
 145 0018 843F      		cpi r24,-12
 146 001a 9140      		sbci r25,1
 147 001c 00F4      		brsh .L1
  73:main.c        ****     step_timer ++;
 149               	.LM2:
 150 001e 8091 0000 		lds r24,step_timer
 151 0022 9091 0000 		lds r25,step_timer+1
 152 0026 0196      		adiw r24,1
 153 0028 9093 0000 		sts step_timer+1,r25
 154 002c 8093 0000 		sts step_timer,r24
 155               	.L1:
 156               	/* epilogue start */
  74:main.c        **** }
 158               	.LM3:
 159 0030 9F91      		pop r25
 160 0032 8F91      		pop r24
 161 0034 2F91      		pop r18
 162 0036 0F90      		pop r0
 163 0038 0FBE      		out __SREG__,r0
 164 003a 0F90      		pop r0
 165 003c 1F90      		pop r1
 166 003e 1895      		reti
 168               	.Lscope1:
 170               	.global	__vector_12
 172               	__vector_12:
  75:main.c        **** 
  76:main.c        **** ISR(TIMER1_COMPA_vect) {
 174               	.LM4:
 175               	.LFBB2:
 176 0040 1F92      		push r1
 177 0042 0F92      		push r0
 178 0044 0FB6      		in r0,__SREG__
 179 0046 0F92      		push r0
 180 0048 1124      		clr __zero_reg__
 181 004a 8F93      		push r24
 182               	/* prologue: Signal */
 183               	/* frame size = 0 */
 184               	/* stack size = 4 */
 185               	.L__stack_usage = 4
  77:main.c        ****   timer_flag = 1;
 187               	.LM5:
 188 004c 81E0      		ldi r24,lo8(1)
 189 004e 8093 0000 		sts timer_flag,r24
 190               	/* epilogue start */
  78:main.c        ****   
  79:main.c        **** }
 192               	.LM6:
 193 0052 8F91      		pop r24
 194 0054 0F90      		pop r0
 195 0056 0FBE      		out __SREG__,r0
 196 0058 0F90      		pop r0
 197 005a 1F90      		pop r1
 198 005c 1895      		reti
 200               	.Lscope2:
 202               	.global	__vector_5
 204               	__vector_5:
  80:main.c        **** 
  81:main.c        **** ISR(INT4_vect) {  // falling level on INT4
 206               	.LM7:
 207               	.LFBB3:
 208 005e 1F92      		push r1
 209 0060 0F92      		push r0
 210 0062 0FB6      		in r0,__SREG__
 211 0064 0F92      		push r0
 212 0066 1124      		clr __zero_reg__
 213 0068 8F93      		push r24
 214               	/* prologue: Signal */
 215               	/* frame size = 0 */
 216               	/* stack size = 4 */
 217               	.L__stack_usage = 4
  82:main.c        ****   if(!(PINE & (1 << ROT1_A))) {
 219               	.LM8:
 220 006a 0C99      		sbic 0x1,4
 221 006c 00C0      		rjmp .L5
 222               	.LBB219:
 223               	.LBB220:
 225               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 227               	.LM9:
 228 006e 86E0      		ldi r24,lo8(6)
 229 0070 8A95      	1:	dec r24
 230 0072 01F4      		brne 1b
 231 0074 00C0      		rjmp .
 232               	.LBE220:
 233               	.LBE219:
 235               	.Ltext2:
  83:main.c        ****     _delay_us(20);
  84:main.c        ****     if (!(PINE & (1 << ROT1_B))) {
 237               	.LM10:
 238 0076 0D99      		sbic 0x1,5
 239 0078 00C0      		rjmp .L5
 240               	.LBB221:
 241               	.LBB222:
 243               	.Ltext3:
 245               	.LM11:
 246 007a 86E0      		ldi r24,lo8(6)
 247 007c 8A95      	1:	dec r24
 248 007e 01F4      		brne 1b
 249 0080 00C0      		rjmp .
 250               	.LBE222:
 251               	.LBE221:
 253               	.Ltext4:
  85:main.c        ****       _delay_us(20);
  86:main.c        ****       if (!(PINE & (1 << ROT1_A)) && !(PINE & (1 << ROT1_B))) {
 255               	.LM12:
 256 0082 0C99      		sbic 0x1,4
 257 0084 00C0      		rjmp .L5
 259               	.LM13:
 260 0086 0D99      		sbic 0x1,5
 261 0088 00C0      		rjmp .L5
 262               	.LBB223:
 263               	.LBB224:
 265               	.Ltext5:
 267               	.LM14:
 268 008a 81E2      		ldi r24,lo8(33)
 269 008c 8A95      	1:	dec r24
 270 008e 01F4      		brne 1b
 271 0090 0000      		nop
 272               	.LBE224:
 273               	.LBE223:
 275               	.Ltext6:
  87:main.c        **** 	_delay_us(100);
  88:main.c        **** 	rot_flag = 0x02;
 277               	.LM15:
 278 0092 82E0      		ldi r24,lo8(2)
 279 0094 8093 0000 		sts rot_flag,r24
 280               	.L5:
 281               	/* epilogue start */
  89:main.c        ****       }
  90:main.c        ****     }
  91:main.c        ****   }
  92:main.c        **** }
 283               	.LM16:
 284 0098 8F91      		pop r24
 285 009a 0F90      		pop r0
 286 009c 0FBE      		out __SREG__,r0
 287 009e 0F90      		pop r0
 288 00a0 1F90      		pop r1
 289 00a2 1895      		reti
 291               	.Lscope3:
 293               	.global	__vector_6
 295               	__vector_6:
  93:main.c        **** 
  94:main.c        **** ISR(INT5_vect) {  // falling level on INT5
 297               	.LM17:
 298               	.LFBB4:
 299 00a4 1F92      		push r1
 300 00a6 0F92      		push r0
 301 00a8 0FB6      		in r0,__SREG__
 302 00aa 0F92      		push r0
 303 00ac 1124      		clr __zero_reg__
 304 00ae 8F93      		push r24
 305               	/* prologue: Signal */
 306               	/* frame size = 0 */
 307               	/* stack size = 4 */
 308               	.L__stack_usage = 4
  95:main.c        ****   if (!(PINE & (1 << ROT1_B))) {
 310               	.LM18:
 311 00b0 0D99      		sbic 0x1,5
 312 00b2 00C0      		rjmp .L9
 313               	.LBB225:
 314               	.LBB226:
 316               	.Ltext7:
 318               	.LM19:
 319 00b4 86E0      		ldi r24,lo8(6)
 320 00b6 8A95      	1:	dec r24
 321 00b8 01F4      		brne 1b
 322 00ba 00C0      		rjmp .
 323               	.LBE226:
 324               	.LBE225:
 326               	.Ltext8:
  96:main.c        ****    _delay_us(20);
  97:main.c        ****     if (!(PINE & (1 << ROT1_A))) {
 328               	.LM20:
 329 00bc 0C99      		sbic 0x1,4
 330 00be 00C0      		rjmp .L9
 331               	.LBB227:
 332               	.LBB228:
 334               	.Ltext9:
 336               	.LM21:
 337 00c0 86E0      		ldi r24,lo8(6)
 338 00c2 8A95      	1:	dec r24
 339 00c4 01F4      		brne 1b
 340 00c6 00C0      		rjmp .
 341               	.LBE228:
 342               	.LBE227:
 344               	.Ltext10:
  98:main.c        ****       _delay_us(20);
  99:main.c        ****       if (!(PINE & (1 << ROT1_A)) && !(PINE & (1 << ROT1_B))) {
 346               	.LM22:
 347 00c8 0C99      		sbic 0x1,4
 348 00ca 00C0      		rjmp .L9
 350               	.LM23:
 351 00cc 0D99      		sbic 0x1,5
 352 00ce 00C0      		rjmp .L9
 353               	.LBB229:
 354               	.LBB230:
 356               	.Ltext11:
 358               	.LM24:
 359 00d0 81E2      		ldi r24,lo8(33)
 360 00d2 8A95      	1:	dec r24
 361 00d4 01F4      		brne 1b
 362 00d6 0000      		nop
 363               	.LBE230:
 364               	.LBE229:
 366               	.Ltext12:
 100:main.c        **** 	_delay_us(100);
 101:main.c        **** 	rot_flag = 0x01;
 368               	.LM25:
 369 00d8 81E0      		ldi r24,lo8(1)
 370 00da 8093 0000 		sts rot_flag,r24
 371               	.L9:
 372               	/* epilogue start */
 102:main.c        ****       }
 103:main.c        ****     }
 104:main.c        ****   }
 105:main.c        **** }
 374               	.LM26:
 375 00de 8F91      		pop r24
 376 00e0 0F90      		pop r0
 377 00e2 0FBE      		out __SREG__,r0
 378 00e4 0F90      		pop r0
 379 00e6 1F90      		pop r1
 380 00e8 1895      		reti
 382               	.Lscope4:
 384               	.global	__vector_7
 386               	__vector_7:
 106:main.c        **** 
 107:main.c        **** ISR(INT6_vect) {  // falling level on INT6
 388               	.LM27:
 389               	.LFBB5:
 390 00ea 1F92      		push r1
 391 00ec 0F92      		push r0
 392 00ee 0FB6      		in r0,__SREG__
 393 00f0 0F92      		push r0
 394 00f2 1124      		clr __zero_reg__
 395 00f4 8F93      		push r24
 396               	/* prologue: Signal */
 397               	/* frame size = 0 */
 398               	/* stack size = 4 */
 399               	.L__stack_usage = 4
 108:main.c        ****   if(!(PINE & (1 << VOLROT_A))) {
 401               	.LM28:
 402 00f6 0E99      		sbic 0x1,6
 403 00f8 00C0      		rjmp .L13
 404               	.LBB231:
 405               	.LBB232:
 407               	.Ltext13:
 409               	.LM29:
 410 00fa 86E0      		ldi r24,lo8(6)
 411 00fc 8A95      	1:	dec r24
 412 00fe 01F4      		brne 1b
 413 0100 00C0      		rjmp .
 414               	.LBE232:
 415               	.LBE231:
 417               	.Ltext14:
 109:main.c        ****     _delay_us(20);
 110:main.c        ****     if (!(PINE & (1 << VOLROT_B))) {
 419               	.LM30:
 420 0102 0F99      		sbic 0x1,7
 421 0104 00C0      		rjmp .L13
 422               	.LBB233:
 423               	.LBB234:
 425               	.Ltext15:
 427               	.LM31:
 428 0106 86E0      		ldi r24,lo8(6)
 429 0108 8A95      	1:	dec r24
 430 010a 01F4      		brne 1b
 431 010c 00C0      		rjmp .
 432               	.LBE234:
 433               	.LBE233:
 435               	.Ltext16:
 111:main.c        ****       _delay_us(20);
 112:main.c        ****       if (!(PINE & (1 << VOLROT_A)) && !(PINE & (1 << VOLROT_B))) {
 437               	.LM32:
 438 010e 0E99      		sbic 0x1,6
 439 0110 00C0      		rjmp .L13
 441               	.LM33:
 442 0112 0F99      		sbic 0x1,7
 443 0114 00C0      		rjmp .L13
 444               	.LBB235:
 445               	.LBB236:
 447               	.Ltext17:
 449               	.LM34:
 450 0116 81E2      		ldi r24,lo8(33)
 451 0118 8A95      	1:	dec r24
 452 011a 01F4      		brne 1b
 453 011c 0000      		nop
 454               	.LBE236:
 455               	.LBE235:
 457               	.Ltext18:
 113:main.c        **** 	_delay_us(100);
 114:main.c        **** 	vol_flag = 0x02;
 459               	.LM35:
 460 011e 82E0      		ldi r24,lo8(2)
 461 0120 8093 0000 		sts vol_flag,r24
 462               	.L13:
 463               	/* epilogue start */
 115:main.c        ****       }
 116:main.c        ****     }
 117:main.c        ****   }
 118:main.c        **** }
 465               	.LM36:
 466 0124 8F91      		pop r24
 467 0126 0F90      		pop r0
 468 0128 0FBE      		out __SREG__,r0
 469 012a 0F90      		pop r0
 470 012c 1F90      		pop r1
 471 012e 1895      		reti
 473               	.Lscope5:
 475               	.global	__vector_8
 477               	__vector_8:
 119:main.c        **** 
 120:main.c        **** ISR(INT7_vect) {  // falling level on INT7
 479               	.LM37:
 480               	.LFBB6:
 481 0130 1F92      		push r1
 482 0132 0F92      		push r0
 483 0134 0FB6      		in r0,__SREG__
 484 0136 0F92      		push r0
 485 0138 1124      		clr __zero_reg__
 486 013a 8F93      		push r24
 487               	/* prologue: Signal */
 488               	/* frame size = 0 */
 489               	/* stack size = 4 */
 490               	.L__stack_usage = 4
 121:main.c        ****   if (!(PINE & (1 << VOLROT_B))) {
 492               	.LM38:
 493 013c 0F99      		sbic 0x1,7
 494 013e 00C0      		rjmp .L17
 495               	.LBB237:
 496               	.LBB238:
 498               	.Ltext19:
 500               	.LM39:
 501 0140 86E0      		ldi r24,lo8(6)
 502 0142 8A95      	1:	dec r24
 503 0144 01F4      		brne 1b
 504 0146 00C0      		rjmp .
 505               	.LBE238:
 506               	.LBE237:
 508               	.Ltext20:
 122:main.c        ****     _delay_us(20);
 123:main.c        ****     if (!(PINE & (1 << VOLROT_A))) {
 510               	.LM40:
 511 0148 0E99      		sbic 0x1,6
 512 014a 00C0      		rjmp .L17
 513               	.LBB239:
 514               	.LBB240:
 516               	.Ltext21:
 518               	.LM41:
 519 014c 86E0      		ldi r24,lo8(6)
 520 014e 8A95      	1:	dec r24
 521 0150 01F4      		brne 1b
 522 0152 00C0      		rjmp .
 523               	.LBE240:
 524               	.LBE239:
 526               	.Ltext22:
 124:main.c        ****       _delay_us(20);
 125:main.c        ****       if (!(PINE & (1 << VOLROT_A)) && !(PINE & (1 << VOLROT_B))) {
 528               	.LM42:
 529 0154 0E99      		sbic 0x1,6
 530 0156 00C0      		rjmp .L17
 532               	.LM43:
 533 0158 0F99      		sbic 0x1,7
 534 015a 00C0      		rjmp .L17
 535               	.LBB241:
 536               	.LBB242:
 538               	.Ltext23:
 540               	.LM44:
 541 015c 81E2      		ldi r24,lo8(33)
 542 015e 8A95      	1:	dec r24
 543 0160 01F4      		brne 1b
 544 0162 0000      		nop
 545               	.LBE242:
 546               	.LBE241:
 548               	.Ltext24:
 126:main.c        **** 	_delay_us(100);
 127:main.c        **** 	vol_flag = 0x01;
 550               	.LM45:
 551 0164 81E0      		ldi r24,lo8(1)
 552 0166 8093 0000 		sts vol_flag,r24
 553               	.L17:
 554               	/* epilogue start */
 128:main.c        ****       }
 129:main.c        ****     }
 130:main.c        ****   }
 131:main.c        **** }
 556               	.LM46:
 557 016a 8F91      		pop r24
 558 016c 0F90      		pop r0
 559 016e 0FBE      		out __SREG__,r0
 560 0170 0F90      		pop r0
 561 0172 1F90      		pop r1
 562 0174 1895      		reti
 564               	.Lscope6:
 566               	.global	TWIinit
 568               	TWIinit:
 132:main.c        **** 
 133:main.c        **** void TWIinit(void) {
 570               	.LM47:
 571               	.LFBB7:
 572               	/* prologue: function */
 573               	/* frame size = 0 */
 574               	/* stack size = 0 */
 575               	.L__stack_usage = 0
 134:main.c        ****   TWBR = 0x45;
 577               	.LM48:
 578 0176 85E4      		ldi r24,lo8(69)
 579 0178 8093 7000 		sts 112,r24
 135:main.c        ****   TWCR = (1 << TWEN);
 581               	.LM49:
 582 017c 84E0      		ldi r24,lo8(4)
 583 017e 8093 7400 		sts 116,r24
 584 0182 0895      		ret
 586               	.Lscope7:
 588               	.global	TWIStart
 590               	TWIStart:
 136:main.c        **** }
 137:main.c        **** 
 138:main.c        **** void TWIStart(void) {
 592               	.LM50:
 593               	.LFBB8:
 594               	/* prologue: function */
 595               	/* frame size = 0 */
 596               	/* stack size = 0 */
 597               	.L__stack_usage = 0
 139:main.c        ****   TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 599               	.LM51:
 600 0184 84EA      		ldi r24,lo8(-92)
 601 0186 8093 7400 		sts 116,r24
 602               	.L23:
 140:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 604               	.LM52:
 605 018a 8091 7400 		lds r24,116
 606 018e 87FF      		sbrs r24,7
 607 0190 00C0      		rjmp .L23
 608               	/* epilogue start */
 141:main.c        **** }
 610               	.LM53:
 611 0192 0895      		ret
 613               	.Lscope8:
 615               	.global	TWIStop
 617               	TWIStop:
 142:main.c        **** 
 143:main.c        **** void TWIStop(void) {
 619               	.LM54:
 620               	.LFBB9:
 621               	/* prologue: function */
 622               	/* frame size = 0 */
 623               	/* stack size = 0 */
 624               	.L__stack_usage = 0
 144:main.c        ****   TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
 626               	.LM55:
 627 0194 84E9      		ldi r24,lo8(-108)
 628 0196 8093 7400 		sts 116,r24
 629 019a 0895      		ret
 631               	.Lscope9:
 634               	.global	TWIWrite
 636               	TWIWrite:
 145:main.c        **** }
 146:main.c        **** 
 147:main.c        **** void TWIWrite(uint8_t u8data) {
 638               	.LM56:
 639               	.LFBB10:
 640               	/* prologue: function */
 641               	/* frame size = 0 */
 642               	/* stack size = 0 */
 643               	.L__stack_usage = 0
 148:main.c        ****   TWDR = u8data;
 645               	.LM57:
 646 019c 8093 7300 		sts 115,r24
 149:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN);
 648               	.LM58:
 649 01a0 84E8      		ldi r24,lo8(-124)
 650 01a2 8093 7400 		sts 116,r24
 651               	.L27:
 150:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 653               	.LM59:
 654 01a6 8091 7400 		lds r24,116
 655 01aa 87FF      		sbrs r24,7
 656 01ac 00C0      		rjmp .L27
 657               	/* epilogue start */
 151:main.c        **** }
 659               	.LM60:
 660 01ae 0895      		ret
 662               	.Lscope10:
 664               	.global	TWIReadACK
 666               	TWIReadACK:
 152:main.c        **** 
 153:main.c        **** uint8_t TWIReadACK(void) {
 668               	.LM61:
 669               	.LFBB11:
 670               	/* prologue: function */
 671               	/* frame size = 0 */
 672               	/* stack size = 0 */
 673               	.L__stack_usage = 0
 154:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 675               	.LM62:
 676 01b0 84EC      		ldi r24,lo8(-60)
 677 01b2 8093 7400 		sts 116,r24
 678               	.L30:
 155:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 680               	.LM63:
 681 01b6 8091 7400 		lds r24,116
 682 01ba 87FF      		sbrs r24,7
 683 01bc 00C0      		rjmp .L30
 156:main.c        ****   return TWDR;
 685               	.LM64:
 686 01be 8091 7300 		lds r24,115
 157:main.c        **** }
 688               	.LM65:
 689 01c2 0895      		ret
 691               	.Lscope11:
 693               	.global	TWIReadNACK
 695               	TWIReadNACK:
 158:main.c        **** 
 159:main.c        **** //read byte with NACK
 160:main.c        **** uint8_t TWIReadNACK(void) {
 697               	.LM66:
 698               	.LFBB12:
 699               	/* prologue: function */
 700               	/* frame size = 0 */
 701               	/* stack size = 0 */
 702               	.L__stack_usage = 0
 161:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN);
 704               	.LM67:
 705 01c4 84E8      		ldi r24,lo8(-124)
 706 01c6 8093 7400 		sts 116,r24
 707               	.L33:
 162:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 709               	.LM68:
 710 01ca 8091 7400 		lds r24,116
 711 01ce 87FF      		sbrs r24,7
 712 01d0 00C0      		rjmp .L33
 163:main.c        ****   return TWDR;
 714               	.LM69:
 715 01d2 8091 7300 		lds r24,115
 164:main.c        **** }
 717               	.LM70:
 718 01d6 0895      		ret
 720               	.Lscope12:
 722               	.global	TWIGetStatus
 724               	TWIGetStatus:
 165:main.c        **** 
 166:main.c        **** uint8_t TWIGetStatus(void) {
 726               	.LM71:
 727               	.LFBB13:
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 0 */
 731               	.L__stack_usage = 0
 167:main.c        ****   uint8_t status;
 168:main.c        ****   //mask status
 169:main.c        ****   status = TWSR & 0xF8;
 733               	.LM72:
 734 01d8 8091 7100 		lds r24,113
 170:main.c        ****   return status;
 171:main.c        **** }
 736               	.LM73:
 737 01dc 887F      		andi r24,lo8(-8)
 738 01de 0895      		ret
 740               	.Lscope13:
 744               	.global	TWI_write_byte
 746               	TWI_write_byte:
 172:main.c        **** 
 173:main.c        **** uint8_t TWI_write_byte(uint8_t addr, uint8_t data) {
 748               	.LM74:
 749               	.LFBB14:
 750 01e0 1F93      		push r17
 751 01e2 CF93      		push r28
 752 01e4 DF93      		push r29
 753 01e6 1F92      		push __zero_reg__
 754 01e8 CDB7      		in r28,__SP_L__
 755 01ea DEB7      		in r29,__SP_H__
 756               	/* prologue: function */
 757               	/* frame size = 1 */
 758               	/* stack size = 4 */
 759               	.L__stack_usage = 4
 760 01ec 162F      		mov r17,r22
 174:main.c        **** 
 175:main.c        ****   TWIStart();
 762               	.LM75:
 763 01ee 8983      		std Y+1,r24
 764 01f0 0E94 0000 		call TWIStart
 765               	.LBB243:
 766               	.LBB244:
 169:main.c        ****   return status;
 768               	.LM76:
 769 01f4 9091 7100 		lds r25,113
 770 01f8 987F      		andi r25,lo8(-8)
 771               	.LBE244:
 772               	.LBE243:
 176:main.c        ****   if (TWIGetStatus() != 0x08) {
 774               	.LM77:
 775 01fa 8981      		ldd r24,Y+1
 776 01fc 9830      		cpi r25,lo8(8)
 777 01fe 01F0      		breq .L37
 778               	.LBB245:
 779               	.LBB246:
 144:main.c        **** }
 781               	.LM78:
 782 0200 84E9      		ldi r24,lo8(-108)
 783 0202 8093 7400 		sts 116,r24
 784               	.LBE246:
 785               	.LBE245:
 177:main.c        ****     TWIStop();
 178:main.c        ****     return 0x01;
 787               	.LM79:
 788 0206 81E0      		ldi r24,lo8(1)
 789 0208 00C0      		rjmp .L38
 790               	.L37:
 179:main.c        ****   }
 180:main.c        ****   TWIWrite(addr << 1);
 792               	.LM80:
 793 020a 880F      		lsl r24
 794 020c 0E94 0000 		call TWIWrite
 795               	.LBB247:
 796               	.LBB248:
 169:main.c        ****   return status;
 798               	.LM81:
 799 0210 9091 7100 		lds r25,113
 800 0214 987F      		andi r25,lo8(-8)
 801               	.LBE248:
 802               	.LBE247:
 181:main.c        ****   if (TWIGetStatus() != 0x18) {
 804               	.LM82:
 805 0216 9831      		cpi r25,lo8(24)
 806 0218 01F0      		breq .L39
 807               	.LBB249:
 808               	.LBB250:
 144:main.c        **** }
 810               	.LM83:
 811 021a 84E9      		ldi r24,lo8(-108)
 812 021c 8093 7400 		sts 116,r24
 813               	.LBE250:
 814               	.LBE249:
 182:main.c        ****     TWIStop();
 183:main.c        ****     return 0x02;
 816               	.LM84:
 817 0220 82E0      		ldi r24,lo8(2)
 818 0222 00C0      		rjmp .L38
 819               	.L39:
 184:main.c        ****   }  
 185:main.c        ****   TWIWrite(data);
 821               	.LM85:
 822 0224 812F      		mov r24,r17
 823 0226 0E94 0000 		call TWIWrite
 824               	.LBB251:
 825               	.LBB252:
 169:main.c        ****   return status;
 827               	.LM86:
 828 022a 8091 7100 		lds r24,113
 829 022e 887F      		andi r24,lo8(-8)
 830               	.LBE252:
 831               	.LBE251:
 186:main.c        ****   if (TWIGetStatus() != 0x28) {
 833               	.LM87:
 834 0230 8832      		cpi r24,lo8(40)
 835 0232 01F0      		breq .L40
 836               	.LBB253:
 837               	.LBB254:
 144:main.c        **** }
 839               	.LM88:
 840 0234 84E9      		ldi r24,lo8(-108)
 841 0236 8093 7400 		sts 116,r24
 842               	.LBE254:
 843               	.LBE253:
 187:main.c        ****     TWIStop();
 188:main.c        ****     return 0x03;
 845               	.LM89:
 846 023a 83E0      		ldi r24,lo8(3)
 847 023c 00C0      		rjmp .L38
 848               	.L40:
 849               	.LBB255:
 850               	.LBB256:
 144:main.c        **** }
 852               	.LM90:
 853 023e 84E9      		ldi r24,lo8(-108)
 854 0240 8093 7400 		sts 116,r24
 855               	.LBE256:
 856               	.LBE255:
 189:main.c        ****   }
 190:main.c        ****   TWIStop();
 191:main.c        ****   return 0x00;
 858               	.LM91:
 859 0244 80E0      		ldi r24,0
 860               	.L38:
 861               	/* epilogue start */
 192:main.c        **** }
 863               	.LM92:
 864 0246 0F90      		pop __tmp_reg__
 865 0248 DF91      		pop r29
 866 024a CF91      		pop r28
 867 024c 1F91      		pop r17
 868 024e 0895      		ret
 870               	.Lscope14:
 874               	.global	TWI_read_byte
 876               	TWI_read_byte:
 193:main.c        **** 
 194:main.c        **** uint8_t TWI_read_byte(uint8_t addr, uint8_t* data) {
 878               	.LM93:
 879               	.LFBB15:
 880 0250 0F93      		push r16
 881 0252 1F93      		push r17
 882 0254 CF93      		push r28
 883 0256 DF93      		push r29
 884 0258 1F92      		push __zero_reg__
 885 025a CDB7      		in r28,__SP_L__
 886 025c DEB7      		in r29,__SP_H__
 887               	/* prologue: function */
 888               	/* frame size = 1 */
 889               	/* stack size = 5 */
 890               	.L__stack_usage = 5
 891 025e 8B01      		movw r16,r22
 195:main.c        **** 
 196:main.c        ****   TWIStart();
 893               	.LM94:
 894 0260 8983      		std Y+1,r24
 895 0262 0E94 0000 		call TWIStart
 896               	.LBB277:
 897               	.LBB278:
 169:main.c        ****   return status;
 899               	.LM95:
 900 0266 9091 7100 		lds r25,113
 901 026a 987F      		andi r25,lo8(-8)
 902               	.LBE278:
 903               	.LBE277:
 197:main.c        ****   if (TWIGetStatus() != 0x08) {
 905               	.LM96:
 906 026c 8981      		ldd r24,Y+1
 907 026e 9830      		cpi r25,lo8(8)
 908 0270 01F0      		breq .L42
 909               	.LBB279:
 910               	.LBB280:
 144:main.c        **** }
 912               	.LM97:
 913 0272 84E9      		ldi r24,lo8(-108)
 914 0274 8093 7400 		sts 116,r24
 915               	.LBE280:
 916               	.LBE279:
 198:main.c        ****     TWIStop();
 199:main.c        ****     return 0x01;
 918               	.LM98:
 919 0278 81E0      		ldi r24,lo8(1)
 920 027a 00C0      		rjmp .L43
 921               	.L42:
 200:main.c        ****   }
 201:main.c        ****   TWIWrite((addr << 1) | 0x01);
 923               	.LM99:
 924 027c 880F      		lsl r24
 925 027e 8160      		ori r24,lo8(1)
 926 0280 0E94 0000 		call TWIWrite
 927               	.LBB281:
 928               	.LBB282:
 169:main.c        ****   return status;
 930               	.LM100:
 931 0284 8091 7100 		lds r24,113
 932 0288 887F      		andi r24,lo8(-8)
 933               	.LBE282:
 934               	.LBE281:
 202:main.c        ****   if (TWIGetStatus() != 0x40) {
 936               	.LM101:
 937 028a 8034      		cpi r24,lo8(64)
 938 028c 01F0      		breq .L44
 939               	.LBB283:
 940               	.LBB284:
 144:main.c        **** }
 942               	.LM102:
 943 028e 84E9      		ldi r24,lo8(-108)
 944 0290 8093 7400 		sts 116,r24
 945               	.LBE284:
 946               	.LBE283:
 203:main.c        ****     TWIStop();
 204:main.c        ****     return 0x02;
 948               	.LM103:
 949 0294 82E0      		ldi r24,lo8(2)
 950 0296 00C0      		rjmp .L43
 951               	.L44:
 952               	.LBB285:
 953               	.LBB286:
 205:main.c        ****   }
 206:main.c        ****   *data = TWIReadNACK();
 955               	.LM104:
 956 0298 0E94 0000 		call TWIReadNACK
 957 029c F801      		movw r30,r16
 958 029e 8083      		st Z,r24
 959               	.LBB287:
 960               	.LBB288:
 144:main.c        **** }
 962               	.LM105:
 963 02a0 84E9      		ldi r24,lo8(-108)
 964 02a2 8093 7400 		sts 116,r24
 965 02a6 80E0      		ldi r24,0
 966               	.L43:
 967               	/* epilogue start */
 968               	.LBE288:
 969               	.LBE287:
 970               	.LBE286:
 971               	.LBE285:
 207:main.c        ****   TWIStop();
 208:main.c        ****   return 0x00;
 209:main.c        **** }
 973               	.LM106:
 974 02a8 0F90      		pop __tmp_reg__
 975 02aa DF91      		pop r29
 976 02ac CF91      		pop r28
 977 02ae 1F91      		pop r17
 978 02b0 0F91      		pop r16
 979 02b2 0895      		ret
 981               	.Lscope15:
 984               	.global	TWI_write_word
 986               	TWI_write_word:
 210:main.c        **** 
 211:main.c        **** uint8_t TWI_write_word(uint8_t addr, uint16_t data_word) {
 988               	.LM107:
 989               	.LFBB16:
 990 02b4 0F93      		push r16
 991 02b6 1F93      		push r17
 992 02b8 CF93      		push r28
 993 02ba DF93      		push r29
 994 02bc 1F92      		push __zero_reg__
 995 02be CDB7      		in r28,__SP_L__
 996 02c0 DEB7      		in r29,__SP_H__
 997               	/* prologue: function */
 998               	/* frame size = 1 */
 999               	/* stack size = 5 */
 1000               	.L__stack_usage = 5
 1001 02c2 162F      		mov r17,r22
 1002 02c4 072F      		mov r16,r23
 212:main.c        **** 
 213:main.c        ****   TWIStart();
 1004               	.LM108:
 1005 02c6 8983      		std Y+1,r24
 1006 02c8 0E94 0000 		call TWIStart
 1007               	.LBB321:
 1008               	.LBB322:
 169:main.c        ****   return status;
 1010               	.LM109:
 1011 02cc 9091 7100 		lds r25,113
 1012 02d0 987F      		andi r25,lo8(-8)
 1013               	.LBE322:
 1014               	.LBE321:
 214:main.c        ****   if (TWIGetStatus() != 0x08) {
 1016               	.LM110:
 1017 02d2 8981      		ldd r24,Y+1
 1018 02d4 9830      		cpi r25,lo8(8)
 1019 02d6 01F0      		breq .L46
 1020               	.LBB323:
 1021               	.LBB324:
 144:main.c        **** }
 1023               	.LM111:
 1024 02d8 84E9      		ldi r24,lo8(-108)
 1025 02da 8093 7400 		sts 116,r24
 1026               	.LBE324:
 1027               	.LBE323:
 215:main.c        ****     TWIStop();
 216:main.c        ****     return 0x01;
 1029               	.LM112:
 1030 02de 81E0      		ldi r24,lo8(1)
 1031 02e0 00C0      		rjmp .L47
 1032               	.L46:
 217:main.c        ****   }
 218:main.c        ****   TWIWrite(addr << 1);
 1034               	.LM113:
 1035 02e2 880F      		lsl r24
 1036 02e4 0E94 0000 		call TWIWrite
 1037               	.LBB325:
 1038               	.LBB326:
 169:main.c        ****   return status;
 1040               	.LM114:
 1041 02e8 9091 7100 		lds r25,113
 1042 02ec 987F      		andi r25,lo8(-8)
 1043               	.LBE326:
 1044               	.LBE325:
 219:main.c        ****   if (TWIGetStatus() != 0x18) {
 1046               	.LM115:
 1047 02ee 9831      		cpi r25,lo8(24)
 1048 02f0 01F0      		breq .L48
 1049               	.LBB327:
 1050               	.LBB328:
 144:main.c        **** }
 1052               	.LM116:
 1053 02f2 84E9      		ldi r24,lo8(-108)
 1054 02f4 8093 7400 		sts 116,r24
 1055               	.LBE328:
 1056               	.LBE327:
 220:main.c        ****     TWIStop();
 221:main.c        ****     return 0x02;  
 1058               	.LM117:
 1059 02f8 82E0      		ldi r24,lo8(2)
 1060 02fa 00C0      		rjmp .L47
 1061               	.L48:
 222:main.c        ****   }
 223:main.c        ****   TWIWrite((uint8_t)((data_word & 0xFF00) >> 8));
 1063               	.LM118:
 1064 02fc 802F      		mov r24,r16
 1065 02fe 0E94 0000 		call TWIWrite
 1066               	.LBB329:
 1067               	.LBB330:
 169:main.c        ****   return status;
 1069               	.LM119:
 1070 0302 9091 7100 		lds r25,113
 1071 0306 987F      		andi r25,lo8(-8)
 1072               	.LBE330:
 1073               	.LBE329:
 224:main.c        ****   if (TWIGetStatus() != 0x28) {
 1075               	.LM120:
 1076 0308 9832      		cpi r25,lo8(40)
 1077 030a 01F0      		breq .L49
 1078               	.LBB331:
 1079               	.LBB332:
 144:main.c        **** }
 1081               	.LM121:
 1082 030c 84E9      		ldi r24,lo8(-108)
 1083 030e 8093 7400 		sts 116,r24
 1084               	.LBE332:
 1085               	.LBE331:
 225:main.c        ****     TWIStop();
 226:main.c        ****     return 0x03;
 1087               	.LM122:
 1088 0312 83E0      		ldi r24,lo8(3)
 1089 0314 00C0      		rjmp .L47
 1090               	.L49:
 1091               	.LBB333:
 1092               	.LBB334:
 227:main.c        ****   }
 228:main.c        ****   TWIWrite((uint8_t)(data_word & 0x00FF));
 1094               	.LM123:
 1095 0316 812F      		mov r24,r17
 1096 0318 0E94 0000 		call TWIWrite
 1097               	.LBB335:
 1098               	.LBB336:
 169:main.c        ****   return status;
 1100               	.LM124:
 1101 031c 8091 7100 		lds r24,113
 1102 0320 887F      		andi r24,lo8(-8)
 1103               	.LBE336:
 1104               	.LBE335:
 229:main.c        ****   if (TWIGetStatus() != 0x28) {
 1106               	.LM125:
 1107 0322 8832      		cpi r24,lo8(40)
 1108 0324 01F0      		breq .L50
 1109               	.LBB337:
 1110               	.LBB338:
 144:main.c        **** }
 1112               	.LM126:
 1113 0326 84E9      		ldi r24,lo8(-108)
 1114 0328 8093 7400 		sts 116,r24
 1115               	.LBE338:
 1116               	.LBE337:
 230:main.c        ****     TWIStop();
 231:main.c        ****     return 0x04;
 1118               	.LM127:
 1119 032c 84E0      		ldi r24,lo8(4)
 1120 032e 00C0      		rjmp .L47
 1121               	.L50:
 1122               	.LBB339:
 1123               	.LBB340:
 144:main.c        **** }
 1125               	.LM128:
 1126 0330 84E9      		ldi r24,lo8(-108)
 1127 0332 8093 7400 		sts 116,r24
 1128               	.LBE340:
 1129               	.LBE339:
 232:main.c        ****   }
 233:main.c        ****   TWIStop();
 234:main.c        ****   return 0x00;
 1131               	.LM129:
 1132 0336 80E0      		ldi r24,0
 1133               	.L47:
 1134               	/* epilogue start */
 1135               	.LBE334:
 1136               	.LBE333:
 235:main.c        **** }
 1138               	.LM130:
 1139 0338 0F90      		pop __tmp_reg__
 1140 033a DF91      		pop r29
 1141 033c CF91      		pop r28
 1142 033e 1F91      		pop r17
 1143 0340 0F91      		pop r16
 1144 0342 0895      		ret
 1146               	.Lscope16:
 1152               	.global	TWI_write_3bytes
 1154               	TWI_write_3bytes:
 236:main.c        **** 
 237:main.c        **** uint8_t TWI_write_3bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3) {
 1156               	.LM131:
 1157               	.LFBB17:
 1158 0344 FF92      		push r15
 1159 0346 0F93      		push r16
 1160 0348 1F93      		push r17
 1161 034a CF93      		push r28
 1162 034c DF93      		push r29
 1163 034e 1F92      		push __zero_reg__
 1164 0350 CDB7      		in r28,__SP_L__
 1165 0352 DEB7      		in r29,__SP_H__
 1166               	/* prologue: function */
 1167               	/* frame size = 1 */
 1168               	/* stack size = 6 */
 1169               	.L__stack_usage = 6
 1170 0354 162F      		mov r17,r22
 1171 0356 042F      		mov r16,r20
 1172 0358 F22E      		mov r15,r18
 238:main.c        **** 
 239:main.c        ****   TWIStart();
 1174               	.LM132:
 1175 035a 8983      		std Y+1,r24
 1176 035c 0E94 0000 		call TWIStart
 1177               	.LBB341:
 1178               	.LBB342:
 169:main.c        ****   return status;
 1180               	.LM133:
 1181 0360 9091 7100 		lds r25,113
 1182 0364 987F      		andi r25,lo8(-8)
 1183               	.LBE342:
 1184               	.LBE341:
 240:main.c        ****   if (TWIGetStatus() != 0x08) {
 1186               	.LM134:
 1187 0366 8981      		ldd r24,Y+1
 1188 0368 9830      		cpi r25,lo8(8)
 1189 036a 01F0      		breq .L52
 1190               	.LBB343:
 1191               	.LBB344:
 144:main.c        **** }
 1193               	.LM135:
 1194 036c 84E9      		ldi r24,lo8(-108)
 1195 036e 8093 7400 		sts 116,r24
 1196               	.LBE344:
 1197               	.LBE343:
 241:main.c        ****     TWIStop();
 242:main.c        ****     return 0x01;
 1199               	.LM136:
 1200 0372 81E0      		ldi r24,lo8(1)
 1201 0374 00C0      		rjmp .L53
 1202               	.L52:
 243:main.c        ****   }
 244:main.c        ****   TWIWrite(addr << 1);
 1204               	.LM137:
 1205 0376 880F      		lsl r24
 1206 0378 0E94 0000 		call TWIWrite
 1207               	.LBB345:
 1208               	.LBB346:
 169:main.c        ****   return status;
 1210               	.LM138:
 1211 037c 9091 7100 		lds r25,113
 1212 0380 987F      		andi r25,lo8(-8)
 1213               	.LBE346:
 1214               	.LBE345:
 245:main.c        ****   if (TWIGetStatus() != 0x18) {
 1216               	.LM139:
 1217 0382 9831      		cpi r25,lo8(24)
 1218 0384 01F0      		breq .L54
 1219               	.LBB347:
 1220               	.LBB348:
 144:main.c        **** }
 1222               	.LM140:
 1223 0386 84E9      		ldi r24,lo8(-108)
 1224 0388 8093 7400 		sts 116,r24
 1225               	.LBE348:
 1226               	.LBE347:
 246:main.c        ****     TWIStop();
 247:main.c        ****     return 0x02;  
 1228               	.LM141:
 1229 038c 82E0      		ldi r24,lo8(2)
 1230 038e 00C0      		rjmp .L53
 1231               	.L54:
 248:main.c        ****   }
 249:main.c        ****   TWIWrite(byte1);
 1233               	.LM142:
 1234 0390 812F      		mov r24,r17
 1235 0392 0E94 0000 		call TWIWrite
 1236               	.LBB349:
 1237               	.LBB350:
 169:main.c        ****   return status;
 1239               	.LM143:
 1240 0396 9091 7100 		lds r25,113
 1241 039a 987F      		andi r25,lo8(-8)
 1242               	.LBE350:
 1243               	.LBE349:
 250:main.c        ****   if (TWIGetStatus() != 0x28) {
 1245               	.LM144:
 1246 039c 9832      		cpi r25,lo8(40)
 1247 039e 01F0      		breq .L55
 1248               	.LBB351:
 1249               	.LBB352:
 144:main.c        **** }
 1251               	.LM145:
 1252 03a0 84E9      		ldi r24,lo8(-108)
 1253 03a2 8093 7400 		sts 116,r24
 1254               	.LBE352:
 1255               	.LBE351:
 251:main.c        ****     TWIStop();
 252:main.c        ****     return 0x03;
 1257               	.LM146:
 1258 03a6 83E0      		ldi r24,lo8(3)
 1259 03a8 00C0      		rjmp .L53
 1260               	.L55:
 253:main.c        ****   }
 254:main.c        ****   TWIWrite(byte2);
 1262               	.LM147:
 1263 03aa 802F      		mov r24,r16
 1264 03ac 0E94 0000 		call TWIWrite
 1265               	.LBB353:
 1266               	.LBB354:
 169:main.c        ****   return status;
 1268               	.LM148:
 1269 03b0 9091 7100 		lds r25,113
 1270 03b4 987F      		andi r25,lo8(-8)
 1271               	.LBE354:
 1272               	.LBE353:
 255:main.c        ****   if (TWIGetStatus() != 0x28) {
 1274               	.LM149:
 1275 03b6 9832      		cpi r25,lo8(40)
 1276 03b8 01F4      		brne .L58
 256:main.c        ****     TWIStop();
 257:main.c        ****     return 0x04;
 258:main.c        ****   }
 259:main.c        ****   TWIWrite(byte3);
 1278               	.LM150:
 1279 03ba 8F2D      		mov r24,r15
 1280 03bc 0E94 0000 		call TWIWrite
 1281               	.LBB355:
 1282               	.LBB356:
 169:main.c        ****   return status;
 1284               	.LM151:
 1285 03c0 8091 7100 		lds r24,113
 1286 03c4 887F      		andi r24,lo8(-8)
 1287               	.LBE356:
 1288               	.LBE355:
 260:main.c        ****   if (TWIGetStatus() != 0x28) {
 1290               	.LM152:
 1291 03c6 8832      		cpi r24,lo8(40)
 1292 03c8 01F0      		breq .L57
 1293               	.L58:
 1294               	.LBB357:
 1295               	.LBB358:
 144:main.c        **** }
 1297               	.LM153:
 1298 03ca 84E9      		ldi r24,lo8(-108)
 1299 03cc 8093 7400 		sts 116,r24
 1300               	.LBE358:
 1301               	.LBE357:
 261:main.c        ****     TWIStop();
 262:main.c        ****     return 0x04;
 1303               	.LM154:
 1304 03d0 84E0      		ldi r24,lo8(4)
 1305 03d2 00C0      		rjmp .L53
 1306               	.L57:
 1307               	.LBB359:
 1308               	.LBB360:
 144:main.c        **** }
 1310               	.LM155:
 1311 03d4 84E9      		ldi r24,lo8(-108)
 1312 03d6 8093 7400 		sts 116,r24
 1313               	.LBE360:
 1314               	.LBE359:
 263:main.c        ****   }
 264:main.c        ****   TWIStop();
 265:main.c        ****   return 0x00;
 1316               	.LM156:
 1317 03da 80E0      		ldi r24,0
 1318               	.L53:
 1319               	/* epilogue start */
 266:main.c        **** }
 1321               	.LM157:
 1322 03dc 0F90      		pop __tmp_reg__
 1323 03de DF91      		pop r29
 1324 03e0 CF91      		pop r28
 1325 03e2 1F91      		pop r17
 1326 03e4 0F91      		pop r16
 1327 03e6 FF90      		pop r15
 1328 03e8 0895      		ret
 1330               	.Lscope17:
 1337               	.global	TWI_write_4bytes
 1339               	TWI_write_4bytes:
 267:main.c        **** 
 268:main.c        **** uint8_t TWI_write_4bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3, uint8_t byte4) 
 1341               	.LM158:
 1342               	.LFBB18:
 1343 03ea EF92      		push r14
 1344 03ec FF92      		push r15
 1345 03ee 0F93      		push r16
 1346 03f0 1F93      		push r17
 1347 03f2 CF93      		push r28
 1348 03f4 DF93      		push r29
 1349 03f6 1F92      		push __zero_reg__
 1350 03f8 CDB7      		in r28,__SP_L__
 1351 03fa DEB7      		in r29,__SP_H__
 1352               	/* prologue: function */
 1353               	/* frame size = 1 */
 1354               	/* stack size = 7 */
 1355               	.L__stack_usage = 7
 1356 03fc 162F      		mov r17,r22
 1357 03fe F42E      		mov r15,r20
 1358 0400 E22E      		mov r14,r18
 269:main.c        **** 
 270:main.c        ****   TWIStart();
 1360               	.LM159:
 1361 0402 8983      		std Y+1,r24
 1362 0404 0E94 0000 		call TWIStart
 1363               	.LBB361:
 1364               	.LBB362:
 169:main.c        ****   return status;
 1366               	.LM160:
 1367 0408 9091 7100 		lds r25,113
 1368 040c 987F      		andi r25,lo8(-8)
 1369               	.LBE362:
 1370               	.LBE361:
 271:main.c        ****   if (TWIGetStatus() != 0x08) {
 1372               	.LM161:
 1373 040e 8981      		ldd r24,Y+1
 1374 0410 9830      		cpi r25,lo8(8)
 1375 0412 01F0      		breq .L60
 1376               	.LBB363:
 1377               	.LBB364:
 144:main.c        **** }
 1379               	.LM162:
 1380 0414 84E9      		ldi r24,lo8(-108)
 1381 0416 8093 7400 		sts 116,r24
 1382               	.LBE364:
 1383               	.LBE363:
 272:main.c        ****     TWIStop();
 273:main.c        ****     return 0x01;
 1385               	.LM163:
 1386 041a 81E0      		ldi r24,lo8(1)
 1387 041c 00C0      		rjmp .L61
 1388               	.L60:
 274:main.c        ****   }
 275:main.c        ****   TWIWrite(addr << 1);
 1390               	.LM164:
 1391 041e 880F      		lsl r24
 1392 0420 0E94 0000 		call TWIWrite
 1393               	.LBB365:
 1394               	.LBB366:
 169:main.c        ****   return status;
 1396               	.LM165:
 1397 0424 9091 7100 		lds r25,113
 1398 0428 987F      		andi r25,lo8(-8)
 1399               	.LBE366:
 1400               	.LBE365:
 276:main.c        ****   if (TWIGetStatus() != 0x18) {
 1402               	.LM166:
 1403 042a 9831      		cpi r25,lo8(24)
 1404 042c 01F0      		breq .L62
 1405               	.LBB367:
 1406               	.LBB368:
 144:main.c        **** }
 1408               	.LM167:
 1409 042e 84E9      		ldi r24,lo8(-108)
 1410 0430 8093 7400 		sts 116,r24
 1411               	.LBE368:
 1412               	.LBE367:
 277:main.c        ****     TWIStop();
 278:main.c        ****     return 0x02;  
 1414               	.LM168:
 1415 0434 82E0      		ldi r24,lo8(2)
 1416 0436 00C0      		rjmp .L61
 1417               	.L62:
 279:main.c        ****   }
 280:main.c        ****   TWIWrite(byte1);
 1419               	.LM169:
 1420 0438 812F      		mov r24,r17
 1421 043a 0E94 0000 		call TWIWrite
 1422               	.LBB369:
 1423               	.LBB370:
 169:main.c        ****   return status;
 1425               	.LM170:
 1426 043e 9091 7100 		lds r25,113
 1427 0442 987F      		andi r25,lo8(-8)
 1428               	.LBE370:
 1429               	.LBE369:
 281:main.c        ****   if (TWIGetStatus() != 0x28) {
 1431               	.LM171:
 1432 0444 9832      		cpi r25,lo8(40)
 1433 0446 01F0      		breq .L63
 1434               	.LBB371:
 1435               	.LBB372:
 144:main.c        **** }
 1437               	.LM172:
 1438 0448 84E9      		ldi r24,lo8(-108)
 1439 044a 8093 7400 		sts 116,r24
 1440               	.LBE372:
 1441               	.LBE371:
 282:main.c        ****     TWIStop();
 283:main.c        ****     return 0x03;
 1443               	.LM173:
 1444 044e 83E0      		ldi r24,lo8(3)
 1445 0450 00C0      		rjmp .L61
 1446               	.L63:
 284:main.c        ****   }
 285:main.c        ****   TWIWrite(byte2);
 1448               	.LM174:
 1449 0452 8F2D      		mov r24,r15
 1450 0454 0E94 0000 		call TWIWrite
 1451               	.LBB373:
 1452               	.LBB374:
 169:main.c        ****   return status;
 1454               	.LM175:
 1455 0458 9091 7100 		lds r25,113
 1456 045c 987F      		andi r25,lo8(-8)
 1457               	.LBE374:
 1458               	.LBE373:
 286:main.c        ****   if (TWIGetStatus() != 0x28) {
 1460               	.LM176:
 1461 045e 9832      		cpi r25,lo8(40)
 1462 0460 01F4      		brne .L68
 287:main.c        ****     TWIStop();
 288:main.c        ****     return 0x04;
 289:main.c        ****   }
 290:main.c        ****   TWIWrite(byte3);
 1464               	.LM177:
 1465 0462 8E2D      		mov r24,r14
 1466 0464 0E94 0000 		call TWIWrite
 1467               	.LBB375:
 1468               	.LBB376:
 169:main.c        ****   return status;
 1470               	.LM178:
 1471 0468 9091 7100 		lds r25,113
 1472 046c 987F      		andi r25,lo8(-8)
 1473               	.LBE376:
 1474               	.LBE375:
 291:main.c        ****   if (TWIGetStatus() != 0x28) {
 1476               	.LM179:
 1477 046e 9832      		cpi r25,lo8(40)
 1478 0470 01F4      		brne .L68
 292:main.c        ****     TWIStop();
 293:main.c        ****     return 0x04;
 294:main.c        ****   }
 295:main.c        ****   TWIWrite(byte4);
 1480               	.LM180:
 1481 0472 802F      		mov r24,r16
 1482 0474 0E94 0000 		call TWIWrite
 1483               	.LBB377:
 1484               	.LBB378:
 169:main.c        ****   return status;
 1486               	.LM181:
 1487 0478 8091 7100 		lds r24,113
 1488 047c 887F      		andi r24,lo8(-8)
 1489               	.LBE378:
 1490               	.LBE377:
 296:main.c        ****   if (TWIGetStatus() != 0x28) {
 1492               	.LM182:
 1493 047e 8832      		cpi r24,lo8(40)
 1494 0480 01F0      		breq .L66
 1495               	.L68:
 1496               	.LBB379:
 1497               	.LBB380:
 144:main.c        **** }
 1499               	.LM183:
 1500 0482 84E9      		ldi r24,lo8(-108)
 1501 0484 8093 7400 		sts 116,r24
 1502               	.LBE380:
 1503               	.LBE379:
 297:main.c        ****     TWIStop();
 298:main.c        ****     return 0x04;
 1505               	.LM184:
 1506 0488 84E0      		ldi r24,lo8(4)
 1507 048a 00C0      		rjmp .L61
 1508               	.L66:
 1509               	.LBB381:
 1510               	.LBB382:
 144:main.c        **** }
 1512               	.LM185:
 1513 048c 84E9      		ldi r24,lo8(-108)
 1514 048e 8093 7400 		sts 116,r24
 1515               	.LBE382:
 1516               	.LBE381:
 299:main.c        ****   }
 300:main.c        ****   TWIStop();
 301:main.c        ****   return 0x00;
 1518               	.LM186:
 1519 0492 80E0      		ldi r24,0
 1520               	.L61:
 1521               	/* epilogue start */
 302:main.c        **** }
 1523               	.LM187:
 1524 0494 0F90      		pop __tmp_reg__
 1525 0496 DF91      		pop r29
 1526 0498 CF91      		pop r28
 1527 049a 1F91      		pop r17
 1528 049c 0F91      		pop r16
 1529 049e FF90      		pop r15
 1530 04a0 EF90      		pop r14
 1531 04a2 0895      		ret
 1533               	.Lscope18:
 1541               	.global	TWI_write_5bytes
 1543               	TWI_write_5bytes:
 303:main.c        **** 
 304:main.c        **** uint8_t TWI_write_5bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3, uint8_t byte4, 
 1545               	.LM188:
 1546               	.LFBB19:
 1547 04a4 DF92      		push r13
 1548 04a6 EF92      		push r14
 1549 04a8 FF92      		push r15
 1550 04aa 0F93      		push r16
 1551 04ac 1F93      		push r17
 1552 04ae CF93      		push r28
 1553 04b0 DF93      		push r29
 1554 04b2 1F92      		push __zero_reg__
 1555 04b4 CDB7      		in r28,__SP_L__
 1556 04b6 DEB7      		in r29,__SP_H__
 1557               	/* prologue: function */
 1558               	/* frame size = 1 */
 1559               	/* stack size = 8 */
 1560               	.L__stack_usage = 8
 1561 04b8 162F      		mov r17,r22
 1562 04ba F42E      		mov r15,r20
 1563 04bc D22E      		mov r13,r18
 305:main.c        **** 
 306:main.c        ****   TWIStart();
 1565               	.LM189:
 1566 04be 8983      		std Y+1,r24
 1567 04c0 0E94 0000 		call TWIStart
 1568               	.LBB431:
 1569               	.LBB432:
 169:main.c        ****   return status;
 1571               	.LM190:
 1572 04c4 9091 7100 		lds r25,113
 1573 04c8 987F      		andi r25,lo8(-8)
 1574               	.LBE432:
 1575               	.LBE431:
 307:main.c        ****   if (TWIGetStatus() != 0x08) {
 1577               	.LM191:
 1578 04ca 8981      		ldd r24,Y+1
 1579 04cc 9830      		cpi r25,lo8(8)
 1580 04ce 01F0      		breq .L70
 1581               	.LBB433:
 1582               	.LBB434:
 144:main.c        **** }
 1584               	.LM192:
 1585 04d0 84E9      		ldi r24,lo8(-108)
 1586 04d2 8093 7400 		sts 116,r24
 1587               	.LBE434:
 1588               	.LBE433:
 308:main.c        ****     TWIStop();
 309:main.c        ****     return 0x01;
 1590               	.LM193:
 1591 04d6 81E0      		ldi r24,lo8(1)
 1592 04d8 00C0      		rjmp .L71
 1593               	.L70:
 310:main.c        ****   }
 311:main.c        ****   TWIWrite(addr << 1);
 1595               	.LM194:
 1596 04da 880F      		lsl r24
 1597 04dc 0E94 0000 		call TWIWrite
 1598               	.LBB435:
 1599               	.LBB436:
 169:main.c        ****   return status;
 1601               	.LM195:
 1602 04e0 9091 7100 		lds r25,113
 1603 04e4 987F      		andi r25,lo8(-8)
 1604               	.LBE436:
 1605               	.LBE435:
 312:main.c        ****   if (TWIGetStatus() != 0x18) {
 1607               	.LM196:
 1608 04e6 9831      		cpi r25,lo8(24)
 1609 04e8 01F0      		breq .L72
 1610               	.LBB437:
 1611               	.LBB438:
 144:main.c        **** }
 1613               	.LM197:
 1614 04ea 84E9      		ldi r24,lo8(-108)
 1615 04ec 8093 7400 		sts 116,r24
 1616               	.LBE438:
 1617               	.LBE437:
 313:main.c        ****     TWIStop();
 314:main.c        ****     return 0x02;  
 1619               	.LM198:
 1620 04f0 82E0      		ldi r24,lo8(2)
 1621 04f2 00C0      		rjmp .L71
 1622               	.L72:
 315:main.c        ****   }
 316:main.c        ****   TWIWrite(byte1);
 1624               	.LM199:
 1625 04f4 812F      		mov r24,r17
 1626 04f6 0E94 0000 		call TWIWrite
 1627               	.LBB439:
 1628               	.LBB440:
 169:main.c        ****   return status;
 1630               	.LM200:
 1631 04fa 9091 7100 		lds r25,113
 1632 04fe 987F      		andi r25,lo8(-8)
 1633               	.LBE440:
 1634               	.LBE439:
 317:main.c        ****   if (TWIGetStatus() != 0x28) {
 1636               	.LM201:
 1637 0500 9832      		cpi r25,lo8(40)
 1638 0502 01F0      		breq .L73
 1639               	.LBB441:
 1640               	.LBB442:
 144:main.c        **** }
 1642               	.LM202:
 1643 0504 84E9      		ldi r24,lo8(-108)
 1644 0506 8093 7400 		sts 116,r24
 1645               	.LBE442:
 1646               	.LBE441:
 318:main.c        ****     TWIStop();
 319:main.c        ****     return 0x03;
 1648               	.LM203:
 1649 050a 83E0      		ldi r24,lo8(3)
 1650 050c 00C0      		rjmp .L71
 1651               	.L73:
 320:main.c        ****   }
 321:main.c        ****   TWIWrite(byte2);
 1653               	.LM204:
 1654 050e 8F2D      		mov r24,r15
 1655 0510 0E94 0000 		call TWIWrite
 1656               	.LBB443:
 1657               	.LBB444:
 169:main.c        ****   return status;
 1659               	.LM205:
 1660 0514 9091 7100 		lds r25,113
 1661 0518 987F      		andi r25,lo8(-8)
 1662               	.LBE444:
 1663               	.LBE443:
 322:main.c        ****   if (TWIGetStatus() != 0x28) {
 1665               	.LM206:
 1666 051a 9832      		cpi r25,lo8(40)
 1667 051c 01F4      		brne .L78
 1668               	.LBB445:
 1669               	.LBB446:
 323:main.c        ****     TWIStop();
 324:main.c        ****     return 0x04;
 325:main.c        ****   }
 326:main.c        ****   TWIWrite(byte3);
 1671               	.LM207:
 1672 051e 8D2D      		mov r24,r13
 1673 0520 0E94 0000 		call TWIWrite
 1674               	.LBB447:
 1675               	.LBB448:
 169:main.c        ****   return status;
 1677               	.LM208:
 1678 0524 9091 7100 		lds r25,113
 1679 0528 987F      		andi r25,lo8(-8)
 1680               	.LBE448:
 1681               	.LBE447:
 327:main.c        ****   if (TWIGetStatus() != 0x28) {
 1683               	.LM209:
 1684 052a 9832      		cpi r25,lo8(40)
 1685 052c 01F4      		brne .L78
 328:main.c        ****     TWIStop();
 329:main.c        ****     return 0x04;
 330:main.c        ****   }
 331:main.c        ****   TWIWrite(byte4);
 1687               	.LM210:
 1688 052e 802F      		mov r24,r16
 1689 0530 0E94 0000 		call TWIWrite
 1690               	.LBB449:
 1691               	.LBB450:
 169:main.c        ****   return status;
 1693               	.LM211:
 1694 0534 9091 7100 		lds r25,113
 1695 0538 987F      		andi r25,lo8(-8)
 1696               	.LBE450:
 1697               	.LBE449:
 332:main.c        ****   if (TWIGetStatus() != 0x28) {
 1699               	.LM212:
 1700 053a 9832      		cpi r25,lo8(40)
 1701 053c 01F4      		brne .L78
 333:main.c        ****     TWIStop();
 334:main.c        ****     return 0x04;
 335:main.c        ****   }
 336:main.c        ****   TWIWrite(byte5);
 1703               	.LM213:
 1704 053e 8E2D      		mov r24,r14
 1705 0540 0E94 0000 		call TWIWrite
 1706               	.LBB451:
 1707               	.LBB452:
 169:main.c        ****   return status;
 1709               	.LM214:
 1710 0544 8091 7100 		lds r24,113
 1711 0548 887F      		andi r24,lo8(-8)
 1712               	.LBE452:
 1713               	.LBE451:
 337:main.c        ****   if (TWIGetStatus() != 0x28) {
 1715               	.LM215:
 1716 054a 8832      		cpi r24,lo8(40)
 1717 054c 01F0      		breq .L77
 1718               	.L78:
 1719               	.LBB453:
 1720               	.LBB454:
 144:main.c        **** }
 1722               	.LM216:
 1723 054e 84E9      		ldi r24,lo8(-108)
 1724 0550 8093 7400 		sts 116,r24
 1725               	.LBE454:
 1726               	.LBE453:
 338:main.c        ****     TWIStop();
 339:main.c        ****     return 0x04;
 1728               	.LM217:
 1729 0554 84E0      		ldi r24,lo8(4)
 1730 0556 00C0      		rjmp .L71
 1731               	.L77:
 1732               	.LBB455:
 1733               	.LBB456:
 144:main.c        **** }
 1735               	.LM218:
 1736 0558 84E9      		ldi r24,lo8(-108)
 1737 055a 8093 7400 		sts 116,r24
 1738               	.LBE456:
 1739               	.LBE455:
 340:main.c        ****   }
 341:main.c        ****   TWIStop();
 342:main.c        ****   return 0x00;
 1741               	.LM219:
 1742 055e 80E0      		ldi r24,0
 1743               	.L71:
 1744               	/* epilogue start */
 1745               	.LBE446:
 1746               	.LBE445:
 343:main.c        **** }
 1748               	.LM220:
 1749 0560 0F90      		pop __tmp_reg__
 1750 0562 DF91      		pop r29
 1751 0564 CF91      		pop r28
 1752 0566 1F91      		pop r17
 1753 0568 0F91      		pop r16
 1754 056a FF90      		pop r15
 1755 056c EF90      		pop r14
 1756 056e DF90      		pop r13
 1757 0570 0895      		ret
 1759               	.Lscope19:
 1762               	.global	updateVolume
 1764               	updateVolume:
 344:main.c        **** 
 345:main.c        **** uint8_t updateVolume(uint8_t vol) {
 1766               	.LM221:
 1767               	.LFBB20:
 1768 0572 EF92      		push r14
 1769 0574 0F93      		push r16
 1770               	/* prologue: function */
 1771               	/* frame size = 0 */
 1772               	/* stack size = 2 */
 1773               	.L__stack_usage = 2
 346:main.c        ****   
 347:main.c        ****   uint8_t addr, err;
 348:main.c        **** 
 349:main.c        ****   addr = 0x80; // Address for audio conf
 350:main.c        **** 
 351:main.c        ****   err = TWI_write_5bytes(fpga_addr, addr, 0x00, 0x00, 0x00, vol);
 1775               	.LM222:
 1776 0576 E82E      		mov r14,r24
 1777 0578 00E0      		ldi r16,0
 1778 057a 20E0      		ldi r18,0
 1779 057c 40E0      		ldi r20,0
 1780 057e 60E8      		ldi r22,lo8(-128)
 1781 0580 83E2      		ldi r24,lo8(35)
 1782 0582 0E94 0000 		call TWI_write_5bytes
 1783               	/* epilogue start */
 352:main.c        ****   if(err)
 353:main.c        ****     return err;
 354:main.c        ****   return 0x00;
 355:main.c        **** }
 1785               	.LM223:
 1786 0586 0F91      		pop r16
 1787 0588 EF90      		pop r14
 1788 058a 0895      		ret
 1790               	.Lscope20:
 1792               	.global	readClar
 1794               	readClar:
 356:main.c        **** 
 357:main.c        **** uint16_t readClar(void) {
 1796               	.LM224:
 1797               	.LFBB21:
 1798               	/* prologue: function */
 1799               	/* frame size = 0 */
 1800               	/* stack size = 0 */
 1801               	.L__stack_usage = 0
 358:main.c        ****   return (ADC);
 1803               	.LM225:
 1804 058c 84B1      		in r24,0x4
 1805 058e 95B1      		in r25,0x4+1
 359:main.c        **** }
 1807               	.LM226:
 1808 0590 0895      		ret
 1810               	.Lscope21:
 1812               	.global	updateRFFE
 1814               	updateRFFE:
 360:main.c        **** 
 361:main.c        **** uint8_t updateRFFE(void) {
 1816               	.LM227:
 1817               	.LFBB22:
 1818               	/* prologue: function */
 1819               	/* frame size = 0 */
 1820               	/* stack size = 0 */
 1821               	.L__stack_usage = 0
 362:main.c        ****   uint8_t err;
 363:main.c        ****   uint16_t rxatt;
 364:main.c        **** 
 365:main.c        ****   if (rx_att)
 1823               	.LM228:
 1824 0592 4091 0000 		lds r20,rx_att
 366:main.c        ****     rxatt = 0x0001;
 367:main.c        ****   else
 368:main.c        ****     rxatt = 0x0000;
 369:main.c        **** 
 370:main.c        ****   err = TWI_write_word(pll_addr,(pll_n & 0x0fff) | (tx << 15) | (bandf << 14) | (rxatt << 13));
 1826               	.LM229:
 1827 0596 8091 0000 		lds r24,pll_n
 1828 059a 9091 0000 		lds r25,pll_n+1
 1829 059e 6091 0000 		lds r22,tx
 1830 05a2 7091 0000 		lds r23,tx+1
 1831 05a6 2091 0000 		lds r18,bandf
 1832 05aa 3091 0000 		lds r19,bandf+1
 1833 05ae 7727      		clr r23
 1834 05b0 6695      		lsr r22
 1835 05b2 7795      		ror r23
 1836 05b4 6627      		clr r22
 1837 05b6 9F70      		andi r25,15
 1838 05b8 682B      		or r22,r24
 1839 05ba 792B      		or r23,r25
 1840 05bc 30E4      		ldi r19,0x40
 1841 05be 239F      		mul r18,r19
 1842 05c0 302D      		mov r19,r0
 1843 05c2 2227      		clr r18
 1844 05c4 1124      		clr __zero_reg__
 1845 05c6 622B      		or r22,r18
 1846 05c8 732B      		or r23,r19
 365:main.c        ****     rxatt = 0x0001;
 1848               	.LM230:
 1849 05ca 21E0      		ldi r18,lo8(1)
 1850 05cc 4111      		cpse r20,__zero_reg__
 1851 05ce 00C0      		rjmp .L82
 1852 05d0 20E0      		ldi r18,0
 1853               	.L82:
 1855               	.LM231:
 1856 05d2 80E0      		ldi r24,0
 1857 05d4 90E0      		ldi r25,0
 1858 05d6 922F      		mov r25,r18
 1859 05d8 9295      		swap r25
 1860 05da 990F      		lsl r25
 1861 05dc 907E      		andi r25,lo8(-32)
 1862 05de 682B      		or r22,r24
 1863 05e0 792B      		or r23,r25
 1864 05e2 82E2      		ldi r24,lo8(34)
 1865 05e4 0E94 0000 		call TWI_write_word
 371:main.c        ****   if (err)
 1867               	.LM232:
 1868 05e8 8823      		tst r24
 1869 05ea 01F0      		breq .L84
 372:main.c        ****     return err+5;
 1871               	.LM233:
 1872 05ec 8B5F      		subi r24,lo8(-(5))
 1873 05ee 0895      		ret
 1874               	.L84:
 373:main.c        ****   return 0x00;
 1876               	.LM234:
 1877 05f0 80E0      		ldi r24,0
 374:main.c        **** } 
 1879               	.LM235:
 1880 05f2 0895      		ret
 1885               	.Lscope22:
 1886               	.global	__addsf3
 1887               	.global	__subsf3
 1888               	.global	__divsf3
 1889               	.global	__mulsf3
 1890               	.global	__floatunsisf
 1891               	.global	__fixunssfsi
 1896               	.global	updateFreq
 1898               	updateFreq:
 375:main.c        ****   
 376:main.c        **** uint8_t updateFreq(double freq, int8_t clar, uint8_t all_update) {
 1900               	.LM236:
 1901               	.LFBB23:
 1902 05f4 4F92      		push r4
 1903 05f6 5F92      		push r5
 1904 05f8 6F92      		push r6
 1905 05fa 7F92      		push r7
 1906 05fc AF92      		push r10
 1907 05fe BF92      		push r11
 1908 0600 CF92      		push r12
 1909 0602 DF92      		push r13
 1910 0604 EF92      		push r14
 1911 0606 FF92      		push r15
 1912 0608 0F93      		push r16
 1913 060a 1F93      		push r17
 1914 060c CF93      		push r28
 1915 060e DF93      		push r29
 1916 0610 1F92      		push __zero_reg__
 1917 0612 CDB7      		in r28,__SP_L__
 1918 0614 DEB7      		in r29,__SP_H__
 1919               	/* prologue: function */
 1920               	/* frame size = 1 */
 1921               	/* stack size = 15 */
 1922               	.L__stack_usage = 15
 1923 0616 142F      		mov r17,r20
 377:main.c        ****   //   char buffer[60];
 378:main.c        ****   uint8_t byte1, byte2, byte3, byte4, byte5, err;
 379:main.c        ****   uint16_t pll_n_ = pll_n;
 1925               	.LM237:
 1926 0618 A090 0000 		lds r10,pll_n
 1927 061c B090 0000 		lds r11,pll_n+1
 380:main.c        ****   double freq_lo, ref_freq, ftw;
 381:main.c        ****   static double ftw_toptop, ftw_topbot, ftw_bottop, ftw_botbot;
 382:main.c        **** 
 383:main.c        ****   /*  if (band < 200) { 
 384:main.c        ****     freq_lo = (double)(freq_MHz*1000 + 45000 + freq_kHz);
 385:main.c        ****     bandf = 0;
 386:main.c        ****   }
 387:main.c        ****   else {
 388:main.c        ****     if (freq < 200*1e6) 
 389:main.c        ****       freq_lo = (double)(freq_MHz*1000 + 21400 + freq_kHz);
 390:main.c        ****     else
 391:main.c        ****       freq_lo = (double)((freq_MHz - 1152)*1000 + 21400 + freq_kHz);
 392:main.c        ****     bandf = 1;
 393:main.c        ****     }*/
 394:main.c        **** 
 395:main.c        ****   if (all_update) {
 1929               	.LM238:
 1930 0620 2223      		tst r18
 1931 0622 01F4      		brne .+2
 1932 0624 00C0      		rjmp .L86
 396:main.c        ****     freq_lo = freq + (double)21400;
 1934               	.LM239:
 1935 0626 20E0      		ldi r18,0
 1936 0628 30E3      		ldi r19,lo8(48)
 1937 062a 47EA      		ldi r20,lo8(-89)
 1938 062c 56E4      		ldi r21,lo8(70)
 1939 062e 0E94 0000 		call __addsf3
 1940 0632 6B01      		movw r12,r22
 1941 0634 7C01      		movw r14,r24
 397:main.c        ****     bandf = 1;
 1943               	.LM240:
 1944 0636 81E0      		ldi r24,lo8(1)
 1945 0638 90E0      		ldi r25,0
 1946 063a 9093 0000 		sts bandf+1,r25
 1947 063e 8093 0000 		sts bandf,r24
 398:main.c        **** 
 399:main.c        ****     if (mode == USB) {
 1949               	.LM241:
 1950 0642 8091 0000 		lds r24,mode
 1951 0646 8330      		cpi r24,lo8(3)
 1952 0648 01F4      		brne .L87
 400:main.c        ****       freq_lo += (double)1.8;
 1954               	.LM242:
 1955 064a 26E6      		ldi r18,lo8(102)
 1956 064c 36E6      		ldi r19,lo8(102)
 1957 064e 46EE      		ldi r20,lo8(-26)
 1958 0650 5FE3      		ldi r21,lo8(63)
 1959 0652 00C0      		rjmp .L104
 1960               	.L87:
 401:main.c        ****     }
 402:main.c        ****     else if (mode == CW) {
 1962               	.LM243:
 1963 0654 8091 0000 		lds r24,mode
 1964 0658 8530      		cpi r24,lo8(5)
 1965 065a 01F4      		brne .L89
 403:main.c        ****       freq_lo += (double)0.9;
 1967               	.LM244:
 1968 065c 26E6      		ldi r18,lo8(102)
 1969 065e 36E6      		ldi r19,lo8(102)
 1970 0660 46E6      		ldi r20,lo8(102)
 1971 0662 5FE3      		ldi r21,lo8(63)
 1972               	.L104:
 1973 0664 C701      		movw r24,r14
 1974 0666 B601      		movw r22,r12
 1975 0668 0E94 0000 		call __addsf3
 1976 066c 00C0      		rjmp .L103
 1977               	.L89:
 404:main.c        ****     }
 405:main.c        ****     else if (mode == CWN) {
 1979               	.LM245:
 1980 066e 8091 0000 		lds r24,mode
 1981 0672 8630      		cpi r24,lo8(6)
 1982 0674 01F0      		breq .L88
 406:main.c        ****       //freq_lo += (double)0.9;
 407:main.c        ****     }
 408:main.c        ****     else if (mode == LSB ) {
 1984               	.LM246:
 1985 0676 8091 0000 		lds r24,mode
 1986 067a 8130      		cpi r24,lo8(1)
 1987 067c 01F4      		brne .L88
 409:main.c        ****       freq_lo -= (double)1.8;
 1989               	.LM247:
 1990 067e 26E6      		ldi r18,lo8(102)
 1991 0680 36E6      		ldi r19,lo8(102)
 1992 0682 46EE      		ldi r20,lo8(-26)
 1993 0684 5FE3      		ldi r21,lo8(63)
 1994 0686 C701      		movw r24,r14
 1995 0688 B601      		movw r22,r12
 1996 068a 0E94 0000 		call __subsf3
 1997               	.L103:
 1998 068e 6B01      		movw r12,r22
 1999 0690 7C01      		movw r14,r24
 2000               	.L88:
 410:main.c        ****     }
 411:main.c        **** 
 412:main.c        ****     pll_n_ = (uint16_t)lround(freq_lo/(double)100);  // 100 kHz step
 2002               	.LM248:
 2003 0692 20E0      		ldi r18,0
 2004 0694 30E0      		ldi r19,0
 2005 0696 48EC      		ldi r20,lo8(-56)
 2006 0698 52E4      		ldi r21,lo8(66)
 2007 069a C701      		movw r24,r14
 2008 069c B601      		movw r22,r12
 2009 069e 0E94 0000 		call __divsf3
 2010 06a2 0E94 0000 		call lround
 2011 06a6 2B01      		movw r4,r22
 2012 06a8 3C01      		movw r6,r24
 2013 06aa 5B01      		movw r10,r22
 413:main.c        ****     ref_freq = 170*freq_lo/pll_n_;  // 170 ref divider value
 2015               	.LM249:
 2016 06ac 20E0      		ldi r18,0
 2017 06ae 30E0      		ldi r19,0
 2018 06b0 4AE2      		ldi r20,lo8(42)
 2019 06b2 53E4      		ldi r21,lo8(67)
 2020 06b4 C701      		movw r24,r14
 2021 06b6 B601      		movw r22,r12
 2022 06b8 0E94 0000 		call __mulsf3
 2023 06bc 6B01      		movw r12,r22
 2024 06be 7C01      		movw r14,r24
 2025 06c0 B201      		movw r22,r4
 2026 06c2 80E0      		ldi r24,0
 2027 06c4 90E0      		ldi r25,0
 2028 06c6 0E94 0000 		call __floatunsisf
 2029 06ca 9B01      		movw r18,r22
 2030 06cc AC01      		movw r20,r24
 2031 06ce C701      		movw r24,r14
 2032 06d0 B601      		movw r22,r12
 2033 06d2 0E94 0000 		call __divsf3
 414:main.c        ****     ftw = ref_freq*(double)279.62026666667; // 20MHz,25bit: 279.620266667 19.2MHz,22bit: 36.4088889
 2035               	.LM250:
 2036 06d6 25E6      		ldi r18,lo8(101)
 2037 06d8 3FEC      		ldi r19,lo8(-49)
 2038 06da 4BE8      		ldi r20,lo8(-117)
 2039 06dc 53E4      		ldi r21,lo8(67)
 2040 06de 0E94 0000 		call __mulsf3
 2041 06e2 6B01      		movw r12,r22
 2042 06e4 7C01      		movw r14,r24
 415:main.c        ****     ftw_toptop = floor(ftw/(double)16777216);
 2044               	.LM251:
 2045 06e6 20E0      		ldi r18,0
 2046 06e8 30E0      		ldi r19,0
 2047 06ea 40E8      		ldi r20,lo8(-128)
 2048 06ec 53E3      		ldi r21,lo8(51)
 2049 06ee 0E94 0000 		call __mulsf3
 2050 06f2 0E94 0000 		call floor
 2051 06f6 6093 0000 		sts ftw_toptop.2391,r22
 2052 06fa 7093 0000 		sts ftw_toptop.2391+1,r23
 2053 06fe 8093 0000 		sts ftw_toptop.2391+2,r24
 2054 0702 9093 0000 		sts ftw_toptop.2391+3,r25
 416:main.c        ****     ftw_topbot = floor((ftw-ftw_toptop*(double)16777216)/(double)65536);
 2056               	.LM252:
 2057 0706 20E0      		ldi r18,0
 2058 0708 30E0      		ldi r19,0
 2059 070a 40E8      		ldi r20,lo8(-128)
 2060 070c 5BE4      		ldi r21,lo8(75)
 2061 070e 0E94 0000 		call __mulsf3
 2062 0712 9B01      		movw r18,r22
 2063 0714 AC01      		movw r20,r24
 2064 0716 C701      		movw r24,r14
 2065 0718 B601      		movw r22,r12
 2066 071a 0E94 0000 		call __subsf3
 2067 071e 2B01      		movw r4,r22
 2068 0720 3C01      		movw r6,r24
 2069 0722 20E0      		ldi r18,0
 2070 0724 30E0      		ldi r19,0
 2071 0726 40E8      		ldi r20,lo8(-128)
 2072 0728 57E3      		ldi r21,lo8(55)
 2073 072a 0E94 0000 		call __mulsf3
 2074 072e 0E94 0000 		call floor
 2075 0732 6093 0000 		sts ftw_topbot.2392,r22
 2076 0736 7093 0000 		sts ftw_topbot.2392+1,r23
 2077 073a 8093 0000 		sts ftw_topbot.2392+2,r24
 2078 073e 9093 0000 		sts ftw_topbot.2392+3,r25
 417:main.c        ****     ftw_bottop = floor((ftw-ftw_toptop*(double)16777216-ftw_topbot*(double)65536)/(double)256);
 2080               	.LM253:
 2081 0742 20E0      		ldi r18,0
 2082 0744 30E0      		ldi r19,0
 2083 0746 40E8      		ldi r20,lo8(-128)
 2084 0748 57E4      		ldi r21,lo8(71)
 2085 074a 0E94 0000 		call __mulsf3
 2086 074e 9B01      		movw r18,r22
 2087 0750 AC01      		movw r20,r24
 2088 0752 C301      		movw r24,r6
 2089 0754 B201      		movw r22,r4
 2090 0756 0E94 0000 		call __subsf3
 2091 075a 20E0      		ldi r18,0
 2092 075c 30E0      		ldi r19,0
 2093 075e 40E8      		ldi r20,lo8(-128)
 2094 0760 5BE3      		ldi r21,lo8(59)
 2095 0762 0E94 0000 		call __mulsf3
 2096 0766 0E94 0000 		call floor
 2097 076a 6093 0000 		sts ftw_bottop.2393,r22
 2098 076e 7093 0000 		sts ftw_bottop.2393+1,r23
 2099 0772 8093 0000 		sts ftw_bottop.2393+2,r24
 2100 0776 9093 0000 		sts ftw_bottop.2393+3,r25
 418:main.c        ****     ftw_botbot = fmod(ftw,256);
 2102               	.LM254:
 2103 077a 20E0      		ldi r18,0
 2104 077c 30E0      		ldi r19,0
 2105 077e 40E8      		ldi r20,lo8(-128)
 2106 0780 53E4      		ldi r21,lo8(67)
 2107 0782 C701      		movw r24,r14
 2108 0784 B601      		movw r22,r12
 2109 0786 0E94 0000 		call fmod
 2110 078a 6093 0000 		sts ftw_botbot.2394,r22
 2111 078e 7093 0000 		sts ftw_botbot.2394+1,r23
 2112 0792 8093 0000 		sts ftw_botbot.2394+2,r24
 2113 0796 9093 0000 		sts ftw_botbot.2394+3,r25
 2114               	.L86:
 419:main.c        ****   }
 420:main.c        **** 
 421:main.c        ****   clar = -(clar+1);  // For arch with LO above RF freq
 422:main.c        **** 
 423:main.c        ****   byte1 = 0xc0;
 424:main.c        ****   byte2 = (uint8_t)(ftw_toptop) | (clar & 0xfe);
 425:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 426:main.c        ****   byte4 = (uint8_t)ftw_bottop;
 427:main.c        ****   byte5 = (uint8_t)ftw_botbot;
 2116               	.LM255:
 2117 079a 6091 0000 		lds r22,ftw_botbot.2394
 2118 079e 7091 0000 		lds r23,ftw_botbot.2394+1
 2119 07a2 8091 0000 		lds r24,ftw_botbot.2394+2
 2120 07a6 9091 0000 		lds r25,ftw_botbot.2394+3
 2121 07aa 0E94 0000 		call __fixunssfsi
 2122 07ae E62E      		mov r14,r22
 426:main.c        ****   byte5 = (uint8_t)ftw_botbot;
 2124               	.LM256:
 2125 07b0 6091 0000 		lds r22,ftw_bottop.2393
 2126 07b4 7091 0000 		lds r23,ftw_bottop.2393+1
 2127 07b8 8091 0000 		lds r24,ftw_bottop.2393+2
 2128 07bc 9091 0000 		lds r25,ftw_bottop.2393+3
 2129 07c0 0E94 0000 		call __fixunssfsi
 2130 07c4 062F      		mov r16,r22
 425:main.c        ****   byte4 = (uint8_t)ftw_bottop;
 2132               	.LM257:
 2133 07c6 6091 0000 		lds r22,ftw_topbot.2392
 2134 07ca 7091 0000 		lds r23,ftw_topbot.2392+1
 2135 07ce 8091 0000 		lds r24,ftw_topbot.2392+2
 2136 07d2 9091 0000 		lds r25,ftw_topbot.2392+3
 2137 07d6 0E94 0000 		call __fixunssfsi
 2138 07da 262F      		mov r18,r22
 421:main.c        **** 
 2140               	.LM258:
 2141 07dc 1095      		com r17
 424:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 2143               	.LM259:
 2144 07de 1E7F      		andi r17,lo8(-2)
 2145 07e0 6091 0000 		lds r22,ftw_toptop.2391
 2146 07e4 7091 0000 		lds r23,ftw_toptop.2391+1
 2147 07e8 8091 0000 		lds r24,ftw_toptop.2391+2
 2148 07ec 9091 0000 		lds r25,ftw_toptop.2391+3
 2149 07f0 2983      		std Y+1,r18
 2150 07f2 0E94 0000 		call __fixunssfsi
 2151 07f6 412F      		mov r20,r17
 2152 07f8 462B      		or r20,r22
 428:main.c        **** 
 429:main.c        ****   err = TWI_write_5bytes(fpga_addr, byte1, byte2, byte3, byte4, byte5);
 2154               	.LM260:
 2155 07fa 2981      		ldd r18,Y+1
 2156 07fc 60EC      		ldi r22,lo8(-64)
 2157 07fe 83E2      		ldi r24,lo8(35)
 2158 0800 0E94 0000 		call TWI_write_5bytes
 430:main.c        ****   if(err)
 2160               	.LM261:
 2161 0804 8111      		cpse r24,__zero_reg__
 2162 0806 00C0      		rjmp .L90
 2163               	.LBB457:
 2164               	.LBB458:
 2166               	.Ltext25:
 2168               	.LM262:
 2169 0808 80E1      		ldi r24,lo8(16)
 2170 080a 8A95      	1:	dec r24
 2171 080c 01F4      		brne 1b
 2172 080e 00C0      		rjmp .
 2173               	.LBE458:
 2174               	.LBE457:
 2176               	.Ltext26:
 431:main.c        ****     return err;
 432:main.c        ****  
 433:main.c        ****   _delay_us(50);
 434:main.c        ****   if (pll_n != pll_n_) {
 2178               	.LM263:
 2179 0810 8091 0000 		lds r24,pll_n
 2180 0814 9091 0000 		lds r25,pll_n+1
 2181 0818 8A15      		cp r24,r10
 2182 081a 9B05      		cpc r25,r11
 2183 081c 01F4      		brne .L91
 2184               	.L92:
 435:main.c        ****     pll_n = pll_n_;
 436:main.c        ****     err = updateRFFE();
 437:main.c        ****     if (err)
 438:main.c        ****       return err+5;
 439:main.c        ****   }
 440:main.c        ****   return 0x00;
 2186               	.LM264:
 2187 081e 80E0      		ldi r24,0
 2188 0820 00C0      		rjmp .L90
 2189               	.L91:
 435:main.c        ****     pll_n = pll_n_;
 2191               	.LM265:
 2192 0822 B092 0000 		sts pll_n+1,r11
 2193 0826 A092 0000 		sts pll_n,r10
 436:main.c        ****     if (err)
 2195               	.LM266:
 2196 082a 0E94 0000 		call updateRFFE
 437:main.c        ****       return err+5;
 2198               	.LM267:
 2199 082e 8823      		tst r24
 2200 0830 01F0      		breq .L92
 438:main.c        ****   }
 2202               	.LM268:
 2203 0832 8B5F      		subi r24,lo8(-(5))
 2204               	.L90:
 2205               	/* epilogue start */
 441:main.c        **** }
 2207               	.LM269:
 2208 0834 0F90      		pop __tmp_reg__
 2209 0836 DF91      		pop r29
 2210 0838 CF91      		pop r28
 2211 083a 1F91      		pop r17
 2212 083c 0F91      		pop r16
 2213 083e FF90      		pop r15
 2214 0840 EF90      		pop r14
 2215 0842 DF90      		pop r13
 2216 0844 CF90      		pop r12
 2217 0846 BF90      		pop r11
 2218 0848 AF90      		pop r10
 2219 084a 7F90      		pop r7
 2220 084c 6F90      		pop r6
 2221 084e 5F90      		pop r5
 2222 0850 4F90      		pop r4
 2223 0852 0895      		ret
 2233               	.Lscope23:
 2235               	.global	updateSettings
 2237               	updateSettings:
 442:main.c        **** 
 443:main.c        **** uint8_t updateSettings (void) {
 2239               	.LM270:
 2240               	.LFBB24:
 2241 0854 EF92      		push r14
 2242 0856 0F93      		push r16
 2243               	/* prologue: function */
 2244               	/* frame size = 0 */
 2245               	/* stack size = 2 */
 2246               	.L__stack_usage = 2
 444:main.c        **** 
 445:main.c        ****   uint8_t err;
 446:main.c        ****   uint8_t byte1, byte2, byte3, byte4, byte5;
 447:main.c        **** 
 448:main.c        ****   switch (mode) {  
 2248               	.LM271:
 2249 0858 9091 0000 		lds r25,mode
 2250 085c 9530      		cpi r25,lo8(5)
 2251 085e 01F0      		breq .L107
 2252 0860 00F4      		brsh .L108
 2253 0862 9130      		cpi r25,lo8(1)
 2254 0864 01F0      		breq .L109
 2255 0866 9330      		cpi r25,lo8(3)
 2256 0868 01F0      		breq .L107
 2257 086a 00C0      		rjmp .L106
 2258               	.L108:
 2259 086c 9830      		cpi r25,lo8(8)
 2260 086e 01F0      		breq .L111
 2261 0870 9A30      		cpi r25,lo8(10)
 2262 0872 01F4      		brne .+2
 2263 0874 00C0      		rjmp .L112
 2264 0876 9630      		cpi r25,lo8(6)
 2265 0878 01F0      		breq .+2
 2266 087a 00C0      		rjmp .L106
 449:main.c        ****   case LSB:
 450:main.c        ****     byte1 = 0b01111000; // Set USB (LO+)
 451:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 452:main.c        ****     byte3 = 0x08;
 453:main.c        ****     byte4 = 0x00;
 454:main.c        ****     byte5 = 0x00;
 455:main.c        ****     break;
 456:main.c        ****   case USB:
 457:main.c        ****     byte1 = 0b01110000; // Set LSB (LO+)
 458:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 459:main.c        ****     byte3 = 0x08;
 460:main.c        ****     byte4 = 0x00;
 461:main.c        ****     byte5 = 0x00;
 462:main.c        ****     break;
 463:main.c        ****   case CW:
 464:main.c        ****     byte1 = 0b01110000; // Set USB (LO+) 
 465:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 466:main.c        ****     byte3 = 0x08;
 467:main.c        ****     byte4 = 0x00;
 468:main.c        ****     byte5 = 0x00;
 469:main.c        ****     break;
 470:main.c        ****   case CWN:
 471:main.c        ****     byte1 = 0b01100000; // Set narrow USB (LO+)
 472:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 2268               	.LM272:
 2269 087c 8091 0000 		lds r24,tx_att
 2270 0880 9091 0000 		lds r25,rx_att
 2271 0884 20E4      		ldi r18,lo8(64)
 2272 0886 829F      		mul r24,r18
 2273 0888 A001      		movw r20,r0
 2274 088a 1124      		clr __zero_reg__
 2275 088c 28E0      		ldi r18,lo8(8)
 2276 088e 929F      		mul r25,r18
 2277 0890 C001      		movw r24,r0
 2278 0892 1124      		clr __zero_reg__
 2279 0894 842B      		or r24,r20
 2280 0896 482F      		mov r20,r24
 2281 0898 4160      		ori r20,lo8(1)
 471:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 2283               	.LM273:
 2284 089a 60E6      		ldi r22,lo8(96)
 473:main.c        ****     byte3 = 0x08;
 474:main.c        ****     byte4 = 0x00;
 475:main.c        ****     byte5 = 0x00;
 476:main.c        ****     break;
 2286               	.LM274:
 2287 089c 00C0      		rjmp .L106
 2288               	.L109:
 451:main.c        ****     byte3 = 0x08;
 2290               	.LM275:
 2291 089e 8091 0000 		lds r24,tx_att
 2292 08a2 9091 0000 		lds r25,rx_att
 2293 08a6 20E4      		ldi r18,lo8(64)
 2294 08a8 829F      		mul r24,r18
 2295 08aa A001      		movw r20,r0
 2296 08ac 1124      		clr __zero_reg__
 2297 08ae 28E0      		ldi r18,lo8(8)
 2298 08b0 929F      		mul r25,r18
 2299 08b2 C001      		movw r24,r0
 2300 08b4 1124      		clr __zero_reg__
 2301 08b6 842B      		or r24,r20
 2302 08b8 482F      		mov r20,r24
 2303 08ba 4160      		ori r20,lo8(1)
 450:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 2305               	.LM276:
 2306 08bc 68E7      		ldi r22,lo8(120)
 455:main.c        ****   case USB:
 2308               	.LM277:
 2309 08be 00C0      		rjmp .L106
 2310               	.L107:
 465:main.c        ****     byte3 = 0x08;
 2312               	.LM278:
 2313 08c0 8091 0000 		lds r24,tx_att
 2314 08c4 9091 0000 		lds r25,rx_att
 2315 08c8 20E4      		ldi r18,lo8(64)
 2316 08ca 829F      		mul r24,r18
 2317 08cc A001      		movw r20,r0
 2318 08ce 1124      		clr __zero_reg__
 2319 08d0 28E0      		ldi r18,lo8(8)
 2320 08d2 929F      		mul r25,r18
 2321 08d4 C001      		movw r24,r0
 2322 08d6 1124      		clr __zero_reg__
 2323 08d8 842B      		or r24,r20
 2324 08da 482F      		mov r20,r24
 2325 08dc 4160      		ori r20,lo8(1)
 464:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 2327               	.LM279:
 2328 08de 60E7      		ldi r22,lo8(112)
 469:main.c        ****   case CWN:
 2330               	.LM280:
 2331 08e0 00C0      		rjmp .L106
 2332               	.L111:
 477:main.c        ****   case AM:
 478:main.c        ****     byte1 = 0b01000000;
 479:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 2334               	.LM281:
 2335 08e2 8091 0000 		lds r24,tx_att
 2336 08e6 9091 0000 		lds r25,rx_att
 2337 08ea 20E4      		ldi r18,lo8(64)
 2338 08ec 829F      		mul r24,r18
 2339 08ee A001      		movw r20,r0
 2340 08f0 1124      		clr __zero_reg__
 2341 08f2 28E0      		ldi r18,lo8(8)
 2342 08f4 929F      		mul r25,r18
 2343 08f6 C001      		movw r24,r0
 2344 08f8 1124      		clr __zero_reg__
 2345 08fa 842B      		or r24,r20
 2346 08fc 482F      		mov r20,r24
 2347 08fe 4160      		ori r20,lo8(1)
 478:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 2349               	.LM282:
 2350 0900 60E4      		ldi r22,lo8(64)
 480:main.c        ****     byte3 = 0x08;
 481:main.c        ****     byte4 = 0x00;
 482:main.c        ****     byte5 = 0x00;
 483:main.c        ****     break;
 2352               	.LM283:
 2353 0902 00C0      		rjmp .L106
 2354               	.L112:
 484:main.c        ****   case FM:
 485:main.c        ****     byte1 = 0b01000001;
 486:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 2356               	.LM284:
 2357 0904 8091 0000 		lds r24,tx_att
 2358 0908 9091 0000 		lds r25,rx_att
 2359 090c 20E4      		ldi r18,lo8(64)
 2360 090e 829F      		mul r24,r18
 2361 0910 A001      		movw r20,r0
 2362 0912 1124      		clr __zero_reg__
 2363 0914 28E0      		ldi r18,lo8(8)
 2364 0916 929F      		mul r25,r18
 2365 0918 C001      		movw r24,r0
 2366 091a 1124      		clr __zero_reg__
 2367 091c 842B      		or r24,r20
 2368 091e 482F      		mov r20,r24
 2369 0920 4160      		ori r20,lo8(1)
 485:main.c        ****     byte2 = (tx_att << 6)|(rx_att << 3)|0x01;
 2371               	.LM285:
 2372 0922 61E4      		ldi r22,lo8(65)
 2373               	.L106:
 487:main.c        ****     byte3 = 0x08;
 488:main.c        ****     byte4 = 0x00;
 489:main.c        ****     byte5 = 0x00;
 490:main.c        ****   }
 491:main.c        ****   
 492:main.c        **** 
 493:main.c        ****   err = TWI_write_5bytes(fpga_addr, byte1, byte2, byte3, byte4, byte5);
 2375               	.LM286:
 2376 0924 E12C      		mov r14,__zero_reg__
 2377 0926 00E0      		ldi r16,0
 2378 0928 28E0      		ldi r18,lo8(8)
 2379 092a 83E2      		ldi r24,lo8(35)
 2380 092c 0E94 0000 		call TWI_write_5bytes
 2381               	/* epilogue start */
 494:main.c        ****   if (err)
 495:main.c        ****     return err;
 496:main.c        **** 
 497:main.c        ****   return 0x00;
 498:main.c        **** 
 499:main.c        **** }
 2383               	.LM287:
 2384 0930 0F91      		pop r16
 2385 0932 EF90      		pop r14
 2386 0934 0895      		ret
 2392               	.Lscope24:
 2394               	.global	adcInit
 2396               	adcInit:
 500:main.c        **** 
 501:main.c        **** void adcInit(void) {
 2398               	.LM288:
 2399               	.LFBB25:
 2400               	/* prologue: function */
 2401               	/* frame size = 0 */
 2402               	/* stack size = 0 */
 2403               	.L__stack_usage = 0
 502:main.c        ****   ADCSRA = (1 << ADEN) | (1 << ADFR) | (1 << ADPS2) | (1 << ADPS1); // Free run, /64 -> 77 kHz
 2405               	.LM289:
 2406 0936 86EA      		ldi r24,lo8(-90)
 2407 0938 86B9      		out 0x6,r24
 503:main.c        ****   ADMUX = 0x43; // ADC3, AVCC ref
 2409               	.LM290:
 2410 093a 83E4      		ldi r24,lo8(67)
 2411 093c 87B9      		out 0x7,r24
 504:main.c        ****   ADCSRA |= (1 << ADSC); // Start conversion
 2413               	.LM291:
 2414 093e 369A      		sbi 0x6,6
 2415 0940 0895      		ret
 2417               	.Lscope25:
 2419               	.global	Timer0Init
 2421               	Timer0Init:
 505:main.c        **** 
 506:main.c        **** }
 507:main.c        **** 
 508:main.c        **** void Timer0Init(void) {
 2423               	.LM292:
 2424               	.LFBB26:
 2425               	/* prologue: function */
 2426               	/* frame size = 0 */
 2427               	/* stack size = 0 */
 2428               	.L__stack_usage = 0
 509:main.c        **** 
 510:main.c        ****   TCCR0 = 0x0f; // CTC mode, 1024 prescaler
 2430               	.LM293:
 2431 0942 8FE0      		ldi r24,lo8(15)
 2432 0944 83BF      		out 0x33,r24
 511:main.c        ****   OCR0 = (uint8_t)10; // 1000000/(1024*10) = 100 Hz, 10ms
 2434               	.LM294:
 2435 0946 8AE0      		ldi r24,lo8(10)
 2436 0948 81BF      		out 0x31,r24
 512:main.c        ****   TIMSK |= (1 << OCIE0); // Interrupt at compare match
 2438               	.LM295:
 2439 094a 87B7      		in r24,0x37
 2440 094c 8260      		ori r24,lo8(2)
 2441 094e 87BF      		out 0x37,r24
 2442 0950 0895      		ret
 2444               	.Lscope26:
 2446               	.global	Timer1Init
 2448               	Timer1Init:
 513:main.c        **** }
 514:main.c        **** 
 515:main.c        **** void Timer1Init(void) {
 2450               	.LM296:
 2451               	.LFBB27:
 2452               	/* prologue: function */
 2453               	/* frame size = 0 */
 2454               	/* stack size = 0 */
 2455               	.L__stack_usage = 0
 516:main.c        **** 
 517:main.c        ****   TCCR1A = 0x00;  
 2457               	.LM297:
 2458 0952 1FBC      		out 0x2f,__zero_reg__
 518:main.c        ****   TCCR1B = 0x0b; // CTC mode, 64 prescaler
 2460               	.LM298:
 2461 0954 8BE0      		ldi r24,lo8(11)
 2462 0956 8EBD      		out 0x2e,r24
 519:main.c        ****   OCR1A = (uint16_t)1563; // 1000000/(64*1563) = 10 Hz, 100ms
 2464               	.LM299:
 2465 0958 8BE1      		ldi r24,lo8(27)
 2466 095a 96E0      		ldi r25,lo8(6)
 2467 095c 9BBD      		out 0x2a+1,r25
 2468 095e 8ABD      		out 0x2a,r24
 520:main.c        ****   TIMSK |= (1 << OCIE1A); // Interrupt at compare match
 2470               	.LM300:
 2471 0960 87B7      		in r24,0x37
 2472 0962 8061      		ori r24,lo8(16)
 2473 0964 87BF      		out 0x37,r24
 2474 0966 0895      		ret
 2476               	.Lscope27:
 2477               	.global	__nesf2
 2478               	.global	__floatsisf
 2479               	.global	__fixsfsi
 2480               		.section	.rodata.str1.1,"aMS",@progbits,1
 2481               	.LC0:
 2482 0000 2564 2C25 		.string	"%d,%06.2f     "
 2482      3036 2E32 
 2482      6620 2020 
 2482      2020 00
 2483               	.LC1:
 2484 000f 2000      		.string	" "
 2485               	.LC2:
 2486 0011 4572 7220 		.string	"Err %x         "
 2486      2578 2020 
 2486      2020 2020 
 2486      2020 2000 
 2487               	.LC3:
 2488 0021 532D 2D2D 		.string	"S---9+++   "
 2488      392B 2B2B 
 2488      2020 2000 
 2489               	.LC4:
 2490 002d 5325 6420 		.string	"S%d         "
 2490      2020 2020 
 2490      2020 2020 
 2490      00
 2491               	.LC5:
 2492 003a 532D 2564 		.string	"S-%d        "
 2492      2020 2020 
 2492      2020 2020 
 2492      00
 2493               	.LC6:
 2494 0047 532D 2D25 		.string	"S--%d       "
 2494      6420 2020 
 2494      2020 2020 
 2494      00
 2495               	.LC7:
 2496 0054 532D 2D2D 		.string	"S---%d      "
 2496      2564 2020 
 2496      2020 2020 
 2496      00
 2497               	.LC8:
 2498 0061 532D 2D2D 		.string	"S----%d     "
 2498      2D25 6420 
 2498      2020 2020 
 2498      00
 2499               	.LC9:
 2500 006e 532D 2D2D 		.string	"S----9+    "
 2500      2D39 2B20 
 2500      2020 2000 
 2501               	.LC10:
 2502 007a 532D 2D2D 		.string	"S----9++   "
 2502      2D39 2B2B 
 2502      2020 2000 
 2503               	.LC11:
 2504 0086 5553 4220 		.string	"USB "
 2504      00
 2505               	.LC12:
 2506 008b 4357 2020 		.string	"CW  "
 2506      00
 2507               	.LC13:
 2508 0090 4357 4E20 		.string	"CWN "
 2508      00
 2509               	.LC14:
 2510 0095 414D 2020 		.string	"AM  "
 2510      00
 2511               	.LC15:
 2512 009a 464D 2020 		.string	"FM  "
 2512      00
 2513               	.global	__ltsf2
 2514               	.LC16:
 2515 009f 566F 6C20 		.string	"Vol %d    "
 2515      2564 2020 
 2515      2020 00
 2516               		.section	.text.startup,"ax",@progbits
 2518               	.global	main
 2520               	main:
 521:main.c        **** }
 522:main.c        **** 
 523:main.c        **** int main(void)
 524:main.c        **** {
 2522               	.LM301:
 2523               	.LFBB28:
 2524 0000 CF93      		push r28
 2525 0002 DF93      		push r29
 2526 0004 CDB7      		in r28,__SP_L__
 2527 0006 DEB7      		in r29,__SP_H__
 2528 0008 C654      		subi r28,70
 2529 000a D109      		sbc r29,__zero_reg__
 2530 000c 0FB6      		in __tmp_reg__,__SREG__
 2531 000e F894      		cli
 2532 0010 DEBF      		out __SP_H__,r29
 2533 0012 0FBE      		out __SREG__,__tmp_reg__
 2534 0014 CDBF      		out __SP_L__,r28
 2535               	/* prologue: function */
 2536               	/* frame size = 70 */
 2537               	/* stack size = 72 */
 2538               	.L__stack_usage = 72
 525:main.c        ****   char buffer[60];
 526:main.c        ****   double freq, freq_last;  // kHz part
 527:main.c        ****   int16_t clarval, clarval_last;
 528:main.c        ****   int8_t clar = 0;
 529:main.c        ****   int freq_offset; // offset in MHz for display
 530:main.c        ****   uint8_t err, data;
 531:main.c        ****   uint8_t rssi, rssi_max=0, rssi_count=0;
 532:main.c        ****   uint8_t last_dir;
 533:main.c        ****   uint8_t tx_last = 255;
 534:main.c        ****   uint8_t vol = 0x18;
 535:main.c        ****   uint16_t steps;
 536:main.c        ****   
 537:main.c        ****   static const char string_intro_row1[] PROGMEM = "*** SM6VFZ";
 538:main.c        ****   static const char string_intro_row2[] PROGMEM = "Starting radio";
 539:main.c        **** 
 540:main.c        ****   DDRA = 0xFF;
 2540               	.LM302:
 2541 0016 8FEF      		ldi r24,lo8(-1)
 2542 0018 8ABB      		out 0x1a,r24
 541:main.c        ****   DDRB = 0xFF;
 2544               	.LM303:
 2545 001a 87BB      		out 0x17,r24
 542:main.c        ****   DDRC = 0xFF;
 2547               	.LM304:
 2548 001c 84BB      		out 0x14,r24
 543:main.c        ****   DDRD = 0xFF;
 2550               	.LM305:
 2551 001e 81BB      		out 0x11,r24
 544:main.c        ****   DDRE = ~(uint8_t)((1 << ROT1_A)|(1 << ROT1_B)|(1 << VOLROT_A)|(1 << VOLROT_B)|(1 << FREQ_BUTTON))
 2553               	.LM306:
 2554 0020 97E0      		ldi r25,lo8(7)
 2555 0022 92B9      		out 0x2,r25
 545:main.c        ****   DDRF = ~(uint8_t)((1 << VOL_BUTTON)|(1 << MODE_BUTTON)|(1 << BAND_BUTTON)|(1 << CLAR_POT)|(1 << M
 2557               	.LM307:
 2558 0024 90EE      		ldi r25,lo8(-32)
 2559 0026 9093 6100 		sts 97,r25
 546:main.c        ****   DDRG = 0xFF;  
 2561               	.LM308:
 2562 002a 8093 6400 		sts 100,r24
 547:main.c        **** 	
 548:main.c        ****   PORTA = 0x00;
 2564               	.LM309:
 2565 002e 1BBA      		out 0x1b,__zero_reg__
 549:main.c        ****   PORTB = 0x00;
 2567               	.LM310:
 2568 0030 18BA      		out 0x18,__zero_reg__
 550:main.c        ****   PORTC = 0x00;
 2570               	.LM311:
 2571 0032 15BA      		out 0x15,__zero_reg__
 551:main.c        ****   PORTD = (uint8_t)(1 << PD2); // PD2 = I2C pull-up
 2573               	.LM312:
 2574 0034 84E0      		ldi r24,lo8(4)
 2575 0036 82BB      		out 0x12,r24
 552:main.c        ****   PORTE = (uint8_t)((1 << ROT1_A)|(1 << ROT1_B)|(1 << VOLROT_A)|(1 << VOLROT_B)|(1 << FREQ_BUTTON))
 2577               	.LM313:
 2578 0038 88EF      		ldi r24,lo8(-8)
 2579 003a 83B9      		out 0x3,r24
 553:main.c        ****   PORTF = (uint8_t)((1 << VOL_BUTTON)|(1 << MODE_BUTTON)|(1 << BAND_BUTTON)|(1 << MODE_BUTTON));
 2581               	.LM314:
 2582 003c 83E1      		ldi r24,lo8(19)
 2583 003e 8093 6200 		sts 98,r24
 554:main.c        ****   PORTG = 0x00;
 2585               	.LM315:
 2586 0042 1092 6500 		sts 101,__zero_reg__
 555:main.c        **** 	
 556:main.c        ****   // turn off the analog comparator
 557:main.c        ****   ACSR = 0x40U;
 2588               	.LM316:
 2589 0046 80E4      		ldi r24,lo8(64)
 2590 0048 88B9      		out 0x8,r24
 558:main.c        **** 	
 559:main.c        ****   // turn off SPI, TWI and USART0
 560:main.c        ****   //PRR  = 0x86U;
 561:main.c        **** 	
 562:main.c        ****   EICRA = 0x00;
 2592               	.LM317:
 2593 004a 1092 6A00 		sts 106,__zero_reg__
 563:main.c        ****   EICRB = (1<<ISC41)|(1<<ISC51)|(1<<ISC61)|(1<<ISC71);
 2595               	.LM318:
 2596 004e 8AEA      		ldi r24,lo8(-86)
 2597 0050 8ABF      		out 0x3a,r24
 564:main.c        **** 
 565:main.c        ****   EIMSK = (1 << INTF4)|(1 << INTF5)|(1 << INTF6)|(1 << INTF7);
 2599               	.LM319:
 2600 0052 80EF      		ldi r24,lo8(-16)
 2601 0054 89BF      		out 0x39,r24
 2602               	.LBB459:
 2603               	.LBB460:
 2605               	.Ltext27:
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** 
 102:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 103:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** #else
 105:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 106:/usr/lib/avr/include/avr/wdt.h **** #endif
 107:/usr/lib/avr/include/avr/wdt.h **** 
 108:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 109:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 110:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 111:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 112:/usr/lib/avr/include/avr/wdt.h **** #else
 113:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 114:/usr/lib/avr/include/avr/wdt.h **** #endif
 115:/usr/lib/avr/include/avr/wdt.h **** 
 116:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 117:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 118:/usr/lib/avr/include/avr/wdt.h **** #else
 119:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 120:/usr/lib/avr/include/avr/wdt.h **** #endif
 121:/usr/lib/avr/include/avr/wdt.h **** 
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** /**
 124:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 125:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 126:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 127:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 128:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 129:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 130:/usr/lib/avr/include/avr/wdt.h **** 
 131:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 132:/usr/lib/avr/include/avr/wdt.h **** */
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h **** 
 135:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** /*
 138:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 139:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 140:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 141:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 142:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 143:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 144:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 145:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 146:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 147:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 148:/usr/lib/avr/include/avr/wdt.h **** */
 149:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 150:/usr/lib/avr/include/avr/wdt.h **** do { \
 151:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 152:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 153:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 155:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 156:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 157:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 158:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 159:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 160:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 161:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 162:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 163:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 164:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 165:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 166:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 167:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 168:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 169:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 170:/usr/lib/avr/include/avr/wdt.h **** ); \
 171:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 172:/usr/lib/avr/include/avr/wdt.h **** 
 173:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 174:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 175:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 176:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 177:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 178:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 179:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 180:/usr/lib/avr/include/avr/wdt.h ****     : \
 181:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 182:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 183:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 184:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 185:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 186:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 187:/usr/lib/avr/include/avr/wdt.h **** );
 188:/usr/lib/avr/include/avr/wdt.h **** 
 189:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 190:/usr/lib/avr/include/avr/wdt.h **** 
 191:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 192:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 193:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 194:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 195:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 196:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 197:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 198:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 199:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 200:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 201:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 202:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 203:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 204:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 205:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 206:/usr/lib/avr/include/avr/wdt.h **** )
 207:/usr/lib/avr/include/avr/wdt.h **** 
 208:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 209:/usr/lib/avr/include/avr/wdt.h **** do { \
 210:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 211:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 212:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 213:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 214:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 215:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 216:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 217:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 218:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 219:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 220:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 221:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 222:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 223:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 224:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 225:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 226:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 227:/usr/lib/avr/include/avr/wdt.h **** ); \
 228:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 229:/usr/lib/avr/include/avr/wdt.h **** 
 230:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 231:/usr/lib/avr/include/avr/wdt.h **** 
 232:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 233:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 234:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 235:/usr/lib/avr/include/avr/wdt.h **** {
 236:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 237:/usr/lib/avr/include/avr/wdt.h **** 	{
 238:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 239:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 240:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 241:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 242:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 243:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 244:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 245:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 246:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 247:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 248:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 249:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 250:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 251:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 252:/usr/lib/avr/include/avr/wdt.h **** 			);
 253:/usr/lib/avr/include/avr/wdt.h **** 	}
 254:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 255:/usr/lib/avr/include/avr/wdt.h **** 	{
 256:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 257:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 258:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 259:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 260:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 261:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 262:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 263:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 264:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 265:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 266:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 267:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 268:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 269:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 270:/usr/lib/avr/include/avr/wdt.h **** 			);
 271:/usr/lib/avr/include/avr/wdt.h **** 	}
 272:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 273:/usr/lib/avr/include/avr/wdt.h **** 	{
 274:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 275:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 276:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 277:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 278:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 279:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 280:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 281:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 282:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 283:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 284:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 285:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 286:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 287:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 288:/usr/lib/avr/include/avr/wdt.h **** 			);
 289:/usr/lib/avr/include/avr/wdt.h **** 	}
 290:/usr/lib/avr/include/avr/wdt.h **** 	else
 291:/usr/lib/avr/include/avr/wdt.h ****  	{
 292:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 293:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 294:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 295:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 296:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 297:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 298:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 299:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 300:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 301:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 302:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 303:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 304:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 305:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 306:/usr/lib/avr/include/avr/wdt.h **** 			);
 307:/usr/lib/avr/include/avr/wdt.h **** 	}
 308:/usr/lib/avr/include/avr/wdt.h **** }
 309:/usr/lib/avr/include/avr/wdt.h **** 
 310:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 311:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 312:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 313:/usr/lib/avr/include/avr/wdt.h **** {
 314:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 315:/usr/lib/avr/include/avr/wdt.h **** 	{
 316:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 317:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 318:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 319:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 320:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 321:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 322:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 323:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 327:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 328:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 329:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 330:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 331:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 332:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 333:/usr/lib/avr/include/avr/wdt.h **** 				);
 334:/usr/lib/avr/include/avr/wdt.h **** 	}
 335:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 336:/usr/lib/avr/include/avr/wdt.h **** 	{
 337:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 338:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 339:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 340:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 341:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 348:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 352:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 353:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 				);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 357:/usr/lib/avr/include/avr/wdt.h **** 	{
 358:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 359:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 360:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 361:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 362:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 363:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 364:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 365:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 366:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 369:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 370:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 371:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 372:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 373:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 374:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 375:/usr/lib/avr/include/avr/wdt.h **** 				);
 376:/usr/lib/avr/include/avr/wdt.h **** 	}
 377:/usr/lib/avr/include/avr/wdt.h **** 	else
 378:/usr/lib/avr/include/avr/wdt.h **** 	{
 379:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 380:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 381:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 382:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 383:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 384:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 385:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 386:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 387:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 390:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 391:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 392:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 393:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 394:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 395:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 396:/usr/lib/avr/include/avr/wdt.h **** 				);
 397:/usr/lib/avr/include/avr/wdt.h **** 	}
 398:/usr/lib/avr/include/avr/wdt.h **** }
 399:/usr/lib/avr/include/avr/wdt.h **** 
 400:/usr/lib/avr/include/avr/wdt.h **** #else
 401:/usr/lib/avr/include/avr/wdt.h **** 
 402:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 403:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 404:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 405:/usr/lib/avr/include/avr/wdt.h **** {
 406:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 407:/usr/lib/avr/include/avr/wdt.h **** 	{
 408:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 409:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 416:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 417:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 418:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 419:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 420:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 421:/usr/lib/avr/include/avr/wdt.h **** 		);
 422:/usr/lib/avr/include/avr/wdt.h **** 	}
 423:/usr/lib/avr/include/avr/wdt.h **** 	else
 424:/usr/lib/avr/include/avr/wdt.h **** 	{
 425:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 426:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 427:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 428:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 429:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 433:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 434:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 435:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 436:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 437:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 438:/usr/lib/avr/include/avr/wdt.h **** 		);
 439:/usr/lib/avr/include/avr/wdt.h **** 	}
 440:/usr/lib/avr/include/avr/wdt.h **** }
 441:/usr/lib/avr/include/avr/wdt.h **** 
 442:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 443:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 444:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 445:/usr/lib/avr/include/avr/wdt.h **** {
 446:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 447:/usr/lib/avr/include/avr/wdt.h **** 	{
 448:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 449:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2607               	.LM320:
 2608               	/* #APP */
 2609               	 ;  449 "/usr/lib/avr/include/avr/wdt.h" 1
 2610 0056 0FB6      		in __tmp_reg__,__SREG__
 2611 0058 F894      		cli
 2612 005a A895      		wdr
 2613 005c 81B5      		in  r24,33
 2614 005e 8861      		ori r24,24
 2615 0060 81BD      		out 33,r24
 2616 0062 11BC      		out 33,__zero_reg__
 2617 0064 0FBE      		out __SREG__,__tmp_reg__
 2618               		
 2619               	 ;  0 "" 2
 2620               	/* #NOAPP */
 2621               	.LBE460:
 2622               	.LBE459:
 2623               	.LBB461:
 2624               	.LBB462:
 2626               	.Ltext28:
 163:/usr/lib/avr/include/util/delay.h **** 
 2628               	.LM321:
 2629 0066 2FE9      		ldi r18,lo8(99999)
 2630 0068 36E8      		ldi r19,hi8(99999)
 2631 006a 81E0      		ldi r24,hlo8(99999)
 2632 006c 2150      	1:	subi r18,1
 2633 006e 3040      		sbci r19,0
 2634 0070 8040      		sbci r24,0
 2635 0072 01F4      		brne 1b
 2636 0074 00C0      		rjmp .
 2637 0076 0000      		nop
 2638               	.LBE462:
 2639               	.LBE461:
 2641               	.Ltext29:
 566:main.c        **** 
 567:main.c        ****   wdt_disable();
 568:main.c        **** 
 569:main.c        ****   _delay_ms(500);
 570:main.c        **** 
 571:main.c        ****   TIMSK = 0;
 2643               	.LM322:
 2644 0078 17BE      		out 0x37,__zero_reg__
 572:main.c        ****   Timer0Init();
 2646               	.LM323:
 2647 007a 0E94 0000 		call Timer0Init
 573:main.c        ****   Timer1Init();
 2649               	.LM324:
 2650 007e 0E94 0000 		call Timer1Init
 574:main.c        ****   TWIinit();
 2652               	.LM325:
 2653 0082 0E94 0000 		call TWIinit
 575:main.c        ****   lcd_init();
 2655               	.LM326:
 2656 0086 0E94 0000 		call lcd_init
 576:main.c        ****   lcd_clrscr();
 2658               	.LM327:
 2659 008a 0E94 0000 		call lcd_clrscr
 577:main.c        ****   adcInit();
 2661               	.LM328:
 2662 008e 0E94 0000 		call adcInit
 2663               	.LBB463:
 2664               	.LBB464:
 2666               	.Ltext30:
 163:/usr/lib/avr/include/util/delay.h **** 
 2668               	.LM329:
 2669 0092 AFE4      		ldi r26,lo8(-15537)
 2670 0094 B3EC      		ldi r27,hi8(-15537)
 2671 0096 1197      	1:	sbiw r26,1
 2672 0098 01F4      		brne 1b
 2673 009a 00C0      		rjmp .
 2674 009c 0000      		nop
 2675               	.LBE464:
 2676               	.LBE463:
 2678               	.Ltext31:
 578:main.c        **** 
 579:main.c        ****   _delay_ms(200);
 580:main.c        **** 
 581:main.c        ****   strcpy_P(buffer, string_intro_row1);
 2680               	.LM330:
 2681 009e 60E0      		ldi r22,lo8(string_intro_row1.2439)
 2682 00a0 70E0      		ldi r23,hi8(string_intro_row1.2439)
 2683 00a2 9E01      		movw r18,r28
 2684 00a4 2F5F      		subi r18,-1
 2685 00a6 3F4F      		sbci r19,-1
 2686 00a8 6901      		movw r12,r18
 2687 00aa C901      		movw r24,r18
 2688 00ac 0E94 0000 		call strcpy_P
 582:main.c        ****   lcd_puts(buffer);
 2690               	.LM331:
 2691 00b0 C601      		movw r24,r12
 2692 00b2 0E94 0000 		call lcd_puts
 583:main.c        ****   lcd_goto(0x40);
 2694               	.LM332:
 2695 00b6 80E4      		ldi r24,lo8(64)
 2696 00b8 0E94 0000 		call lcd_goto
 584:main.c        ****   strcpy_P(buffer, string_intro_row2);
 2698               	.LM333:
 2699 00bc 60E0      		ldi r22,lo8(string_intro_row2.2440)
 2700 00be 70E0      		ldi r23,hi8(string_intro_row2.2440)
 2701 00c0 C601      		movw r24,r12
 2702 00c2 0E94 0000 		call strcpy_P
 585:main.c        ****   lcd_puts(buffer);
 2704               	.LM334:
 2705 00c6 C601      		movw r24,r12
 2706 00c8 0E94 0000 		call lcd_puts
 586:main.c        **** 
 587:main.c        ****   rot_flag = 0x01;
 2708               	.LM335:
 2709 00cc 81E0      		ldi r24,lo8(1)
 2710 00ce 8093 0000 		sts rot_flag,r24
 588:main.c        ****   mode_flag = 0x01;
 2712               	.LM336:
 2713 00d2 8093 0000 		sts mode_flag,r24
 589:main.c        ****   band_flag = 0x02;
 2715               	.LM337:
 2716 00d6 82E0      		ldi r24,lo8(2)
 2717 00d8 8093 0000 		sts band_flag,r24
 590:main.c        ****   timer_flag = 0x00;
 2719               	.LM338:
 2720 00dc 1092 0000 		sts timer_flag,__zero_reg__
 591:main.c        **** 
 592:main.c        ****   band = 10;
 2722               	.LM339:
 2723 00e0 8AE0      		ldi r24,lo8(10)
 2724 00e2 8093 0000 		sts band,r24
 593:main.c        ****   step_timer = 255;
 2726               	.LM340:
 2727 00e6 8FEF      		ldi r24,lo8(-1)
 2728 00e8 90E0      		ldi r25,0
 2729 00ea 9093 0000 		sts step_timer+1,r25
 2730 00ee 8093 0000 		sts step_timer,r24
 594:main.c        ****   steps = 0;
 595:main.c        ****   last_dir = 0x00;
 596:main.c        ****   mode = 0x00;
 2732               	.LM341:
 2733 00f2 1092 0000 		sts mode,__zero_reg__
 597:main.c        ****   tx = 0x0000;
 2735               	.LM342:
 2736 00f6 1092 0000 		sts tx+1,__zero_reg__
 2737 00fa 1092 0000 		sts tx,__zero_reg__
 598:main.c        ****   rx_att = 0x00;
 2739               	.LM343:
 2740 00fe 1092 0000 		sts rx_att,__zero_reg__
 599:main.c        ****   tx_att = 0x00;
 2742               	.LM344:
 2743 0102 1092 0000 		sts tx_att,__zero_reg__
 600:main.c        ****   rffe_rx_att = false;
 2745               	.LM345:
 2746 0106 1092 0000 		sts rffe_rx_att,__zero_reg__
 601:main.c        **** 
 602:main.c        ****   err = updateVolume(vol);
 2748               	.LM346:
 2749 010a 88E1      		ldi r24,lo8(24)
 2750 010c 0E94 0000 		call updateVolume
 2751               	.LBB465:
 2752               	.LBB466:
 2754               	.Ltext32:
 163:/usr/lib/avr/include/util/delay.h **** 
 2756               	.LM347:
 2757 0110 3FE7      		ldi r19,lo8(399999)
 2758 0112 8AE1      		ldi r24,hi8(399999)
 2759 0114 96E0      		ldi r25,hlo8(399999)
 2760 0116 3150      	1:	subi r19,1
 2761 0118 8040      		sbci r24,0
 2762 011a 9040      		sbci r25,0
 2763 011c 01F4      		brne 1b
 2764 011e 00C0      		rjmp .
 2765 0120 0000      		nop
 2766               	.LBE466:
 2767               	.LBE465:
 2769               	.Ltext33:
 603:main.c        ****   
 604:main.c        ****   _delay_ms(2000);
 605:main.c        **** 
 606:main.c        ****   lcd_clrscr();
 2771               	.LM348:
 2772 0122 0E94 0000 		call lcd_clrscr
 607:main.c        ****   
 608:main.c        ****   sei();
 2774               	.LM349:
 2775               	/* #APP */
 2776               	 ;  608 "main.c" 1
 2777 0126 7894      		sei
 2778               	 ;  0 "" 2
 594:main.c        ****   last_dir = 0x00;
 2780               	.LM350:
 2781               	/* #NOAPP */
 2782 0128 612C      		mov r6,__zero_reg__
 2783 012a 712C      		mov r7,__zero_reg__
 534:main.c        ****   uint16_t steps;
 2785               	.LM351:
 2786 012c 38E1      		ldi r19,lo8(24)
 2787 012e 932E      		mov r9,r19
 533:main.c        ****   uint8_t vol = 0x18;
 2789               	.LM352:
 2790 0130 AFEF      		ldi r26,lo8(-1)
 2791 0132 AEAF      		std Y+62,r26
 595:main.c        ****   mode = 0x00;
 2793               	.LM353:
 2794 0134 2396      		adiw r28,66-63
 2795 0136 1FAE      		std Y+63,__zero_reg__
 2796 0138 2397      		sbiw r28,66-63
 531:main.c        ****   uint8_t last_dir;
 2798               	.LM354:
 2799 013a A12C      		mov r10,__zero_reg__
 2800 013c B12C      		mov r11,__zero_reg__
 2801               	.L118:
 609:main.c        **** 
 610:main.c        ****   while (1) {
 611:main.c        ****     if (timer_flag) {
 2803               	.LM355:
 2804 013e 8091 0000 		lds r24,timer_flag
 2805 0142 8823      		tst r24
 2806 0144 01F4      		brne .+2
 2807 0146 00C0      		rjmp .L119
 612:main.c        **** 
 613:main.c        **** #ifdef CLARPOT
 614:main.c        ****       clarval = readClar();
 615:main.c        **** #endif
 616:main.c        **** #ifndef CLARPOT
 617:main.c        ****       clarval = 0;
 618:main.c        **** #endif
 619:main.c        **** 
 620:main.c        ****       if ((clarval < clarval_last - 10) || (clarval > clarval_last + 10)) {
 621:main.c        **** 	clar = (int8_t)((clarval - 512) >> 2);
 622:main.c        **** 	err = updateFreq(freq,clar,0);
 623:main.c        **** 	if (err) {
 624:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 625:main.c        **** 	  lcd_goto(0x40);
 626:main.c        **** 	  lcd_puts(buffer);	
 627:main.c        **** 	}
 628:main.c        **** 	else {
 629:main.c        **** 	  lcd_freq();
 630:main.c        **** 	}
 631:main.c        **** 	clarval_last = clarval;
 632:main.c        ****       }
 633:main.c        **** 
 634:main.c        ****       if (vol_timer < 255)
 2809               	.LM356:
 2810 0148 8091 0000 		lds r24,vol_timer
 2811 014c 8F3F      		cpi r24,lo8(-1)
 2812 014e 01F0      		breq .L120
 635:main.c        **** 	vol_timer ++;
 2814               	.LM357:
 2815 0150 8091 0000 		lds r24,vol_timer
 2816 0154 8F5F      		subi r24,lo8(-(1))
 2817 0156 8093 0000 		sts vol_timer,r24
 2818               	.L120:
 636:main.c        **** 
 637:main.c        ****       // Band button
 638:main.c        **** 
 639:main.c        ****       if (band_timer < 9) { // Recently pressed ?
 2820               	.LM358:
 2821 015a 8091 0000 		lds r24,band_timer
 2822 015e 8930      		cpi r24,lo8(9)
 2823 0160 00F4      		brsh .L121
 640:main.c        **** 	band_timer ++;
 2825               	.LM359:
 2826 0162 8091 0000 		lds r24,band_timer
 2827 0166 8F5F      		subi r24,lo8(-(1))
 2828 0168 8093 0000 		sts band_timer,r24
 641:main.c        **** 	if ((band_timer < 9) && (PINF & (1 << BAND_BUTTON))) {
 2830               	.LM360:
 2831 016c 8091 0000 		lds r24,band_timer
 2832 0170 8930      		cpi r24,lo8(9)
 2833 0172 00F4      		brsh .L122
 2835               	.LM361:
 2836 0174 009B      		sbis 0,0
 2837 0176 00C0      		rjmp .L122
 642:main.c        **** 	  band_flag = 0x01; // short press
 2839               	.LM362:
 2840 0178 81E0      		ldi r24,lo8(1)
 2841 017a 8093 0000 		sts band_flag,r24
 643:main.c        **** 	  band_timer = 255;
 2843               	.LM363:
 2844 017e 8FEF      		ldi r24,lo8(-1)
 2845 0180 8093 0000 		sts band_timer,r24
 2846               	.L122:
 644:main.c        **** 	}
 645:main.c        **** 	if ((band_timer == 9) && (!(PINF & (1 << BAND_BUTTON)))) 
 2848               	.LM364:
 2849 0184 8091 0000 		lds r24,band_timer
 2850 0188 8930      		cpi r24,lo8(9)
 2851 018a 01F4      		brne .L124
 2853               	.LM365:
 2854 018c 0099      		sbic 0,0
 2855 018e 00C0      		rjmp .L124
 646:main.c        **** 	  band_flag = 0x02; // long press
 2857               	.LM366:
 2858 0190 82E0      		ldi r24,lo8(2)
 2859 0192 8093 0000 		sts band_flag,r24
 2860 0196 00C0      		rjmp .L124
 2861               	.L121:
 647:main.c        ****       }
 648:main.c        ****       else if (!(PINF & (1 << BAND_BUTTON))) {  // New press
 2863               	.LM367:
 2864 0198 009B      		sbis 0,0
 649:main.c        **** 	band_timer = 0;
 2866               	.LM368:
 2867 019a 1092 0000 		sts band_timer,__zero_reg__
 2868               	.L124:
 650:main.c        ****       }
 651:main.c        **** 
 652:main.c        ****       // Mode button
 653:main.c        **** 
 654:main.c        ****       if (!(PINF & (1 << MODE_BUTTON))) {
 2870               	.LM369:
 2871 019e 0199      		sbic 0,1
 2872 01a0 00C0      		rjmp .L126
 655:main.c        **** 	mode_flag = 0x01;
 2874               	.LM370:
 2875 01a2 81E0      		ldi r24,lo8(1)
 2876 01a4 8093 0000 		sts mode_flag,r24
 2877               	.L126:
 656:main.c        ****       }
 657:main.c        ****       
 658:main.c        ****       // Update frequency if necessary:
 659:main.c        ****       if (freq != freq_last) {
 2879               	.LM371:
 2880 01a8 282D      		mov r18,r8
 2881 01aa 3FAD      		ldd r19,Y+63
 2882 01ac 2196      		adiw r28,64-63
 2883 01ae 4FAD      		ldd r20,Y+63
 2884 01b0 2197      		sbiw r28,64-63
 2885 01b2 2296      		adiw r28,65-63
 2886 01b4 5FAD      		ldd r21,Y+63
 2887 01b6 2297      		sbiw r28,65-63
 2888 01b8 612F      		mov r22,r17
 2889 01ba 702F      		mov r23,r16
 2890 01bc 8F2D      		mov r24,r15
 2891 01be 9E2D      		mov r25,r14
 2892 01c0 0E94 0000 		call __nesf2
 2893 01c4 8823      		tst r24
 2894 01c6 01F4      		brne .+2
 2895 01c8 00C0      		rjmp .L127
 660:main.c        **** 	lcd_freq();
 2897               	.LM372:
 2898 01ca 84E0      		ldi r24,lo8(4)
 2899 01cc 0E94 0000 		call lcd_goto
 2900 01d0 20E0      		ldi r18,0
 2901 01d2 30E0      		ldi r19,0
 2902 01d4 4AE7      		ldi r20,lo8(122)
 2903 01d6 54E4      		ldi r21,lo8(68)
 2904 01d8 612F      		mov r22,r17
 2905 01da 702F      		mov r23,r16
 2906 01dc 8F2D      		mov r24,r15
 2907 01de 9E2D      		mov r25,r14
 2908 01e0 0E94 0000 		call fmod
 2909 01e4 6FAF      		std Y+63,r22
 2910 01e6 872E      		mov r8,r23
 2911 01e8 2196      		adiw r28,64-63
 2912 01ea 8FAF      		std Y+63,r24
 2913 01ec 2197      		sbiw r28,64-63
 2914 01ee 2296      		adiw r28,65-63
 2915 01f0 9FAF      		std Y+63,r25
 2916 01f2 2297      		sbiw r28,65-63
 2917 01f4 20E0      		ldi r18,0
 2918 01f6 30E0      		ldi r19,0
 2919 01f8 4AE7      		ldi r20,lo8(122)
 2920 01fa 54E4      		ldi r21,lo8(68)
 2921 01fc 612F      		mov r22,r17
 2922 01fe 702F      		mov r23,r16
 2923 0200 8F2D      		mov r24,r15
 2924 0202 9E2D      		mov r25,r14
 2925 0204 0E94 0000 		call __divsf3
 2926 0208 1B01      		movw r2,r22
 2927 020a 2C01      		movw r4,r24
 2928 020c 60E0      		ldi r22,0
 2929 020e 70E0      		ldi r23,0
 2930 0210 CB01      		movw r24,r22
 2931 0212 0E94 0000 		call __floatsisf
 2932 0216 9B01      		movw r18,r22
 2933 0218 AC01      		movw r20,r24
 2934 021a C201      		movw r24,r4
 2935 021c B101      		movw r22,r2
 2936 021e 0E94 0000 		call __addsf3
 2937 0222 0E94 0000 		call floor
 2938 0226 2296      		adiw r28,65-63
 2939 0228 BFAD      		ldd r27,Y+63
 2940 022a 2297      		sbiw r28,65-63
 2941 022c BF93      		push r27
 2942 022e 2196      		adiw r28,64-63
 2943 0230 2FAD      		ldd r18,Y+63
 2944 0232 2197      		sbiw r28,64-63
 2945 0234 2F93      		push r18
 2946 0236 8F92      		push r8
 2947 0238 3FAD      		ldd r19,Y+63
 2948 023a 3F93      		push r19
 2949 023c 0E94 0000 		call __fixsfsi
 2950 0240 7F93      		push r23
 2951 0242 6F93      		push r22
 2952 0244 80E0      		ldi r24,lo8(.LC0)
 2953 0246 90E0      		ldi r25,hi8(.LC0)
 2954 0248 9F93      		push r25
 2955 024a 8F93      		push r24
 2956 024c DF92      		push r13
 2957 024e CF92      		push r12
 2958 0250 0E94 0000 		call sprintf
 2959 0254 C601      		movw r24,r12
 2960 0256 0E94 0000 		call lcd_puts
 2961 025a 8FE0      		ldi r24,lo8(15)
 2962 025c 0E94 0000 		call lcd_goto
 2963 0260 60E0      		ldi r22,lo8(.LC1)
 2964 0262 70E0      		ldi r23,hi8(.LC1)
 2965 0264 C601      		movw r24,r12
 2966 0266 0E94 0000 		call strcpy
 2967 026a C601      		movw r24,r12
 2968 026c 0E94 0000 		call lcd_puts
 661:main.c        **** 	err = updateFreq(freq,clar,1);
 2970               	.LM373:
 2971 0270 21E0      		ldi r18,lo8(1)
 2972 0272 40E0      		ldi r20,0
 2973 0274 612F      		mov r22,r17
 2974 0276 702F      		mov r23,r16
 2975 0278 8F2D      		mov r24,r15
 2976 027a 9E2D      		mov r25,r14
 2977 027c 0E94 0000 		call updateFreq
 662:main.c        **** 	if (err) {
 2979               	.LM374:
 2980 0280 0FB6      		in __tmp_reg__,__SREG__
 2981 0282 F894      		cli
 2982 0284 DEBF      		out __SP_H__,r29
 2983 0286 0FBE      		out __SREG__,__tmp_reg__
 2984 0288 CDBF      		out __SP_L__,r28
 2985 028a 8823      		tst r24
 2986 028c 01F0      		breq .L191
 663:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 2988               	.LM375:
 2989 028e 1F92      		push __zero_reg__
 2990 0290 8F93      		push r24
 2991 0292 80E0      		ldi r24,lo8(.LC2)
 2992 0294 90E0      		ldi r25,hi8(.LC2)
 2993 0296 9F93      		push r25
 2994 0298 8F93      		push r24
 2995 029a DF92      		push r13
 2996 029c CF92      		push r12
 2997 029e 0E94 0000 		call sprintf
 664:main.c        **** 	  lcd_goto(0x40);
 2999               	.LM376:
 3000 02a2 80E4      		ldi r24,lo8(64)
 3001 02a4 0E94 0000 		call lcd_goto
 665:main.c        **** 	  lcd_puts(buffer);	
 3003               	.LM377:
 3004 02a8 C601      		movw r24,r12
 3005 02aa 0E94 0000 		call lcd_puts
 3006 02ae 0F90      		pop __tmp_reg__
 3007 02b0 0F90      		pop __tmp_reg__
 3008 02b2 0F90      		pop __tmp_reg__
 3009 02b4 0F90      		pop __tmp_reg__
 3010 02b6 0F90      		pop __tmp_reg__
 3011 02b8 0F90      		pop __tmp_reg__
 3012               	.L191:
 666:main.c        **** 	}
 667:main.c        **** 	freq_last = freq;
 3014               	.LM378:
 3015 02ba 812E      		mov r8,r17
 3016 02bc 0FAF      		std Y+63,r16
 3017 02be 2196      		adiw r28,64-63
 3018 02c0 FFAE      		std Y+63,r15
 3019 02c2 2197      		sbiw r28,64-63
 3020 02c4 2296      		adiw r28,65-63
 3021 02c6 EFAE      		std Y+63,r14
 3022 02c8 2297      		sbiw r28,65-63
 3023               	.L127:
 668:main.c        ****       }
 669:main.c        **** 
 670:main.c        ****       // Read RSSI and status:
 671:main.c        ****       err = TWI_read_byte(fpga_addr, &data);
 3025               	.LM379:
 3026 02ca BE01      		movw r22,r28
 3027 02cc 635C      		subi r22,-61
 3028 02ce 7F4F      		sbci r23,-1
 3029 02d0 83E2      		ldi r24,lo8(35)
 3030 02d2 0E94 0000 		call TWI_read_byte
 672:main.c        ****       if ((data & 0x80) && (tx_last != 1)) { // Shift to TX ?
 3032               	.LM380:
 3033 02d6 8DAD      		ldd r24,Y+61
 3034 02d8 87FF      		sbrs r24,7
 3035 02da 00C0      		rjmp .L129
 3037               	.LM381:
 3038 02dc BEAD      		ldd r27,Y+62
 3039 02de B130      		cpi r27,lo8(1)
 3040 02e0 01F0      		breq .L130
 673:main.c        **** 	tx = 0x0001;
 3042               	.LM382:
 3043 02e2 81E0      		ldi r24,lo8(1)
 3044 02e4 90E0      		ldi r25,0
 3045 02e6 9093 0000 		sts tx+1,r25
 3046 02ea 8093 0000 		sts tx,r24
 674:main.c        **** 	updateRFFE();
 3048               	.LM383:
 3049 02ee 0E94 0000 		call updateRFFE
 675:main.c        **** 	PORTD |= (1 << LED_RED);
 3051               	.LM384:
 3052 02f2 969A      		sbi 0x12,6
 676:main.c        **** 	PORTD &= ~(1 << LED_GREEN);
 3054               	.LM385:
 3055 02f4 9598      		cbi 0x12,5
 677:main.c        **** 	tx_last = 1;
 3057               	.LM386:
 3058 02f6 21E0      		ldi r18,lo8(1)
 3059 02f8 2EAF      		std Y+62,r18
 3060 02fa 00C0      		rjmp .L130
 3061               	.L129:
 678:main.c        ****       }
 679:main.c        ****       else if (!(data & 0x80) && (tx_last != 0)) { // Shift to RX ?
 3063               	.LM387:
 3064 02fc 3EAD      		ldd r19,Y+62
 3065 02fe 3323      		tst r19
 3066 0300 01F0      		breq .L130
 680:main.c        **** 	tx = 0x0000;
 3068               	.LM388:
 3069 0302 1092 0000 		sts tx+1,__zero_reg__
 3070 0306 1092 0000 		sts tx,__zero_reg__
 681:main.c        **** 	updateRFFE();
 3072               	.LM389:
 3073 030a 0E94 0000 		call updateRFFE
 682:main.c        **** 	PORTD |= (1 << LED_GREEN);
 3075               	.LM390:
 3076 030e 959A      		sbi 0x12,5
 683:main.c        **** 	PORTD &= ~(1 << LED_RED);
 3078               	.LM391:
 3079 0310 9698      		cbi 0x12,6
 684:main.c        **** 	tx_last = 0;
 3081               	.LM392:
 3082 0312 1EAE      		std Y+62,__zero_reg__
 3083               	.L130:
 685:main.c        ****       }
 686:main.c        **** 
 687:main.c        ****       rssi = (0x3f & data); 
 3085               	.LM393:
 3086 0314 8DAD      		ldd r24,Y+61
 3087 0316 8F73      		andi r24,lo8(63)
 3088 0318 B816      		cp r11,r24
 3089 031a 00F4      		brsh .L131
 3090 031c B82E      		mov r11,r24
 3091               	.L131:
 688:main.c        ****       if (rssi_max < rssi) 
 689:main.c        **** 	rssi_max = rssi;
 690:main.c        ****       rssi_count ++;
 3093               	.LM394:
 3094 031e A394      		inc r10
 691:main.c        ****       if ((!rffe_rx_att && rssi_count > 2) || (rffe_rx_att && rssi_count > 2)) {
 3096               	.LM395:
 3097 0320 8091 0000 		lds r24,rffe_rx_att
 3098 0324 8111      		cpse r24,__zero_reg__
 3099 0326 00C0      		rjmp .L132
 3101               	.LM396:
 3102 0328 82E0      		ldi r24,lo8(2)
 3103 032a 8A15      		cp r24,r10
 3104 032c 00F0      		brlo .L133
 3105               	.L132:
 3107               	.LM397:
 3108 032e 8091 0000 		lds r24,rffe_rx_att
 3109 0332 8823      		tst r24
 3110 0334 01F4      		brne .+2
 3111 0336 00C0      		rjmp .L134
 3113               	.LM398:
 3114 0338 92E0      		ldi r25,lo8(2)
 3115 033a 9A15      		cp r25,r10
 3116 033c 00F0      		brlo .+2
 3117 033e 00C0      		rjmp .L134
 3118               	.L133:
 692:main.c        **** 	rssi_count = 0;
 693:main.c        **** 	if (rssi_max < 4)
 3120               	.LM399:
 3121 0340 A3E0      		ldi r26,lo8(3)
 3122 0342 AB15      		cp r26,r11
 3123 0344 00F4      		brsh .L192
 694:main.c        **** 	  rssi = 0;
 695:main.c        **** 	else 
 696:main.c        **** 	  rssi = rssi_max - 4;
 3125               	.LM400:
 3126 0346 8CEF      		ldi r24,lo8(-4)
 3127 0348 8B0D      		add r24,r11
 3128 034a 00C0      		rjmp .L135
 3129               	.L192:
 694:main.c        **** 	  rssi = 0;
 3131               	.LM401:
 3132 034c 80E0      		ldi r24,0
 3133               	.L135:
 697:main.c        **** 	rssi_max = 0;
 698:main.c        **** 
 699:main.c        **** 	if (vol_timer < 10); // Don't print if vol info
 3135               	.LM402:
 3136 034e 9091 0000 		lds r25,vol_timer
 3137 0352 9A30      		cpi r25,lo8(10)
 3138 0354 00F4      		brsh .+2
 3139 0356 00C0      		rjmp .L193
 700:main.c        **** 	else if (rffe_rx_att && (rssi>9)) {
 3141               	.LM403:
 3142 0358 9091 0000 		lds r25,rffe_rx_att
 3143 035c 9923      		tst r25
 3144 035e 01F0      		breq .L136
 3146               	.LM404:
 3147 0360 8A30      		cpi r24,lo8(10)
 3148 0362 00F0      		brlo .L136
 701:main.c        **** 	  sprintf(buffer,"S---9+++   ");
 3150               	.LM405:
 3151 0364 60E0      		ldi r22,lo8(.LC3)
 3152 0366 70E0      		ldi r23,hi8(.LC3)
 3153 0368 00C0      		rjmp .L257
 3154               	.L136:
 702:main.c        **** 	  lcd_goto(0x40);
 703:main.c        **** 	  lcd_puts(buffer);
 704:main.c        **** 	}
 705:main.c        **** 	else if (rffe_rx_att && (rssi < 10)) {
 3156               	.LM406:
 3157 036a 9091 0000 		lds r25,rffe_rx_att
 3158 036e 9923      		tst r25
 3159 0370 01F0      		breq .L137
 3161               	.LM407:
 3162 0372 8A30      		cpi r24,lo8(10)
 3163 0374 00F4      		brsh .L138
 706:main.c        **** 	  rffe_rx_att = false;
 3165               	.LM408:
 3166 0376 1092 0000 		sts rffe_rx_att,__zero_reg__
 3167 037a 00C0      		rjmp .L256
 3168               	.L137:
 707:main.c        **** 	  err = updateRFFE();
 708:main.c        **** 	}
 709:main.c        **** 	else if (rssi < 2) { 
 3170               	.LM409:
 3171 037c 8230      		cpi r24,lo8(2)
 3172 037e 00F4      		brsh .L139
 710:main.c        **** 	  sprintf(buffer,"S%d         ",rssi);
 3174               	.LM410:
 3175 0380 1F92      		push __zero_reg__
 3176 0382 8F93      		push r24
 3177 0384 80E0      		ldi r24,lo8(.LC4)
 3178 0386 90E0      		ldi r25,hi8(.LC4)
 3179 0388 00C0      		rjmp .L261
 3180               	.L139:
 711:main.c        **** 	  lcd_goto(0x40);
 712:main.c        **** 	  lcd_puts(buffer);
 713:main.c        **** 	}
 714:main.c        **** 	else if (rssi < 4) {
 3182               	.LM411:
 3183 038a 8430      		cpi r24,lo8(4)
 3184 038c 00F4      		brsh .L138
 715:main.c        **** 	  sprintf(buffer,"S-%d        ",rssi);
 3186               	.LM412:
 3187 038e 1F92      		push __zero_reg__
 3188 0390 8F93      		push r24
 3189 0392 80E0      		ldi r24,lo8(.LC5)
 3190 0394 90E0      		ldi r25,hi8(.LC5)
 3191 0396 00C0      		rjmp .L261
 3192               	.L138:
 716:main.c        **** 	  lcd_goto(0x40);
 717:main.c        **** 	  lcd_puts(buffer);
 718:main.c        ****  	}
 719:main.c        **** 	else if (rssi < 6) {
 3194               	.LM413:
 3195 0398 8630      		cpi r24,lo8(6)
 3196 039a 00F4      		brsh .L140
 720:main.c        **** 	  sprintf(buffer,"S--%d       ",rssi);
 3198               	.LM414:
 3199 039c 1F92      		push __zero_reg__
 3200 039e 8F93      		push r24
 3201 03a0 80E0      		ldi r24,lo8(.LC6)
 3202 03a2 90E0      		ldi r25,hi8(.LC6)
 3203 03a4 00C0      		rjmp .L261
 3204               	.L140:
 721:main.c        **** 	  lcd_goto(0x40);
 722:main.c        **** 	  lcd_puts(buffer);
 723:main.c        **** 	}
 724:main.c        **** 	else if (rssi < 8) {
 3206               	.LM415:
 3207 03a6 8830      		cpi r24,lo8(8)
 3208 03a8 00F4      		brsh .L141
 725:main.c        **** 	  sprintf(buffer,"S---%d      ",rssi);
 3210               	.LM416:
 3211 03aa 1F92      		push __zero_reg__
 3212 03ac 8F93      		push r24
 3213 03ae 80E0      		ldi r24,lo8(.LC7)
 3214 03b0 90E0      		ldi r25,hi8(.LC7)
 3215               	.L261:
 3216 03b2 9F93      		push r25
 3217 03b4 8F93      		push r24
 3218 03b6 00C0      		rjmp .L258
 3219               	.L141:
 726:main.c        **** 	  lcd_goto(0x40);
 727:main.c        **** 	  lcd_puts(buffer);
 728:main.c        **** 	}
 729:main.c        **** 	else if (rssi < 10) {
 3221               	.LM417:
 3222 03b8 8A30      		cpi r24,lo8(10)
 3223 03ba 00F4      		brsh .L142
 730:main.c        **** 	  sprintf(buffer,"S----%d     ",rssi);
 3225               	.LM418:
 3226 03bc 1F92      		push __zero_reg__
 3227 03be 8F93      		push r24
 3228 03c0 A0E0      		ldi r26,lo8(.LC8)
 3229 03c2 B0E0      		ldi r27,hi8(.LC8)
 3230 03c4 BF93      		push r27
 3231 03c6 AF93      		push r26
 3232               	.L258:
 3233 03c8 DF92      		push r13
 3234 03ca CF92      		push r12
 3235 03cc 0E94 0000 		call sprintf
 731:main.c        **** 	  lcd_goto(0x40);
 3237               	.LM419:
 3238 03d0 80E4      		ldi r24,lo8(64)
 3239 03d2 0E94 0000 		call lcd_goto
 732:main.c        **** 	  lcd_puts(buffer);
 3241               	.LM420:
 3242 03d6 C601      		movw r24,r12
 3243 03d8 0E94 0000 		call lcd_puts
 3244 03dc 0F90      		pop __tmp_reg__
 3245 03de 0F90      		pop __tmp_reg__
 3246 03e0 0F90      		pop __tmp_reg__
 3247 03e2 0F90      		pop __tmp_reg__
 3248 03e4 0F90      		pop __tmp_reg__
 3249 03e6 0F90      		pop __tmp_reg__
 3250 03e8 00C0      		rjmp .L193
 3251               	.L142:
 733:main.c        **** 	}
 734:main.c        **** 	else if (rssi < 12) {
 3253               	.LM421:
 3254 03ea 8C30      		cpi r24,lo8(12)
 3255 03ec 00F4      		brsh .L143
 735:main.c        **** 	  sprintf(buffer,"S----9+    ");
 3257               	.LM422:
 3258 03ee 60E0      		ldi r22,lo8(.LC9)
 3259 03f0 70E0      		ldi r23,hi8(.LC9)
 3260 03f2 00C0      		rjmp .L257
 3261               	.L143:
 736:main.c        **** 	  lcd_goto(0x40);
 737:main.c        **** 	  lcd_puts(buffer);
 738:main.c        **** 	}
 739:main.c        **** 	else if (rssi < 13 ){
 3263               	.LM423:
 3264 03f4 8C30      		cpi r24,lo8(12)
 3265 03f6 01F4      		brne .L144
 740:main.c        **** 	  sprintf(buffer,"S----9++   ");
 3267               	.LM424:
 3268 03f8 60E0      		ldi r22,lo8(.LC10)
 3269 03fa 70E0      		ldi r23,hi8(.LC10)
 3270               	.L257:
 3271 03fc C601      		movw r24,r12
 3272 03fe 0E94 0000 		call strcpy
 741:main.c        **** 	  lcd_goto(0x40);
 3274               	.LM425:
 3275 0402 80E4      		ldi r24,lo8(64)
 3276 0404 0E94 0000 		call lcd_goto
 742:main.c        **** 	  lcd_puts(buffer);
 3278               	.LM426:
 3279 0408 C601      		movw r24,r12
 3280 040a 0E94 0000 		call lcd_puts
 3281 040e 00C0      		rjmp .L193
 3282               	.L144:
 743:main.c        **** 	}
 744:main.c        **** 	else {
 745:main.c        **** 	  rffe_rx_att = true;
 3284               	.LM427:
 3285 0410 81E0      		ldi r24,lo8(1)
 3286 0412 8093 0000 		sts rffe_rx_att,r24
 3287               	.L256:
 746:main.c        **** 	  err = updateRFFE();
 3289               	.LM428:
 3290 0416 0E94 0000 		call updateRFFE
 3291               	.L193:
 692:main.c        **** 	if (rssi_max < 4)
 3293               	.LM429:
 3294 041a A12C      		mov r10,__zero_reg__
 697:main.c        **** 
 3296               	.LM430:
 3297 041c B12C      		mov r11,__zero_reg__
 3298               	.L134:
 747:main.c        **** 	}
 748:main.c        **** 	rssi = 0;
 749:main.c        ****       }
 750:main.c        ****       timer_flag = 0;
 3300               	.LM431:
 3301 041e 1092 0000 		sts timer_flag,__zero_reg__
 3302 0422 00C0      		rjmp .L145
 3303               	.L119:
 751:main.c        ****     }
 752:main.c        ****     else if (mode_flag) {
 3305               	.LM432:
 3306 0424 8091 0000 		lds r24,mode_flag
 3307 0428 8823      		tst r24
 3308 042a 01F4      		brne .+2
 3309 042c 00C0      		rjmp .L145
 753:main.c        ****       switch (mode) {
 3311               	.LM433:
 3312 042e 8091 0000 		lds r24,mode
 3313 0432 8330      		cpi r24,lo8(3)
 3314 0434 01F0      		breq .L147
 3315 0436 00F0      		brlo .L149
 3316 0438 8530      		cpi r24,lo8(5)
 3317 043a 01F0      		breq .L150
 3318 043c 8630      		cpi r24,lo8(6)
 3319 043e 01F0      		breq .L151
 3320               	.L149:
 754:main.c        ****       case LSB:
 755:main.c        **** 	mode = USB;
 3322               	.LM434:
 3323 0440 83E0      		ldi r24,lo8(3)
 3324 0442 8093 0000 		sts mode,r24
 756:main.c        **** 	if (!updateSettings()) { 
 3326               	.LM435:
 3327 0446 0E94 0000 		call updateSettings
 3328 044a 8111      		cpse r24,__zero_reg__
 3329 044c 00C0      		rjmp .L153
 757:main.c        **** 	  lcd_goto(0x00);
 3331               	.LM436:
 3332 044e 80E0      		ldi r24,0
 3333 0450 0E94 0000 		call lcd_goto
 758:main.c        **** 	  sprintf(buffer,"USB ");
 3335               	.LM437:
 3336 0454 60E0      		ldi r22,lo8(.LC11)
 3337 0456 70E0      		ldi r23,hi8(.LC11)
 3338 0458 00C0      		rjmp .L251
 3339               	.L147:
 759:main.c        **** 	  lcd_puts(buffer);
 760:main.c        **** 	}
 761:main.c        **** 	break;
 762:main.c        ****       case USB:
 763:main.c        **** 	mode = CW;
 3341               	.LM438:
 3342 045a 85E0      		ldi r24,lo8(5)
 3343 045c 8093 0000 		sts mode,r24
 764:main.c        **** 	if(!updateSettings()) {
 3345               	.LM439:
 3346 0460 0E94 0000 		call updateSettings
 3347 0464 8111      		cpse r24,__zero_reg__
 3348 0466 00C0      		rjmp .L153
 765:main.c        **** 	  lcd_goto(0x00);
 3350               	.LM440:
 3351 0468 0E94 0000 		call lcd_goto
 766:main.c        **** 	  sprintf(buffer,"CW  ");
 3353               	.LM441:
 3354 046c 60E0      		ldi r22,lo8(.LC12)
 3355 046e 70E0      		ldi r23,hi8(.LC12)
 3356 0470 00C0      		rjmp .L251
 3357               	.L150:
 767:main.c        **** 	  lcd_puts(buffer);
 768:main.c        **** 	}
 769:main.c        **** 	break;
 770:main.c        ****       case CW:
 771:main.c        **** 	mode = CWN;
 3359               	.LM442:
 3360 0472 86E0      		ldi r24,lo8(6)
 3361 0474 8093 0000 		sts mode,r24
 772:main.c        **** 	if(!updateSettings()) {
 3363               	.LM443:
 3364 0478 0E94 0000 		call updateSettings
 3365 047c 8111      		cpse r24,__zero_reg__
 3366 047e 00C0      		rjmp .L153
 773:main.c        **** 	  lcd_goto(0x00);
 3368               	.LM444:
 3369 0480 0E94 0000 		call lcd_goto
 774:main.c        **** 	  sprintf(buffer,"CWN ");
 3371               	.LM445:
 3372 0484 60E0      		ldi r22,lo8(.LC13)
 3373 0486 70E0      		ldi r23,hi8(.LC13)
 3374 0488 00C0      		rjmp .L251
 3375               	.L151:
 775:main.c        **** 	  lcd_puts(buffer);
 776:main.c        **** 	}
 777:main.c        **** 	break;
 778:main.c        ****       case CWN:
 779:main.c        **** 	if (band < 200) {
 3377               	.LM446:
 3378 048a 8091 0000 		lds r24,band
 3379 048e 883C      		cpi r24,lo8(-56)
 3380 0490 00F4      		brsh .L155
 780:main.c        **** 	  mode = AM;
 3382               	.LM447:
 3383 0492 88E0      		ldi r24,lo8(8)
 3384 0494 8093 0000 		sts mode,r24
 781:main.c        **** 	  if(!updateSettings()) {
 3386               	.LM448:
 3387 0498 0E94 0000 		call updateSettings
 3388 049c 8111      		cpse r24,__zero_reg__
 3389 049e 00C0      		rjmp .L153
 782:main.c        **** 	    lcd_goto(0x00);
 3391               	.LM449:
 3392 04a0 0E94 0000 		call lcd_goto
 783:main.c        **** 	    sprintf(buffer,"AM  ");
 3394               	.LM450:
 3395 04a4 60E0      		ldi r22,lo8(.LC14)
 3396 04a6 70E0      		ldi r23,hi8(.LC14)
 3397 04a8 00C0      		rjmp .L251
 3398               	.L155:
 784:main.c        **** 	    lcd_puts(buffer);
 785:main.c        **** 	  }
 786:main.c        **** 	}
 787:main.c        **** 	else {
 788:main.c        **** 	  mode = FM;
 3400               	.LM451:
 3401 04aa 8AE0      		ldi r24,lo8(10)
 3402 04ac 8093 0000 		sts mode,r24
 789:main.c        **** 	  if(!updateSettings()) {
 3404               	.LM452:
 3405 04b0 0E94 0000 		call updateSettings
 3406 04b4 8111      		cpse r24,__zero_reg__
 3407 04b6 00C0      		rjmp .L153
 790:main.c        **** 	    lcd_goto(0x00);
 3409               	.LM453:
 3410 04b8 0E94 0000 		call lcd_goto
 791:main.c        **** 	    sprintf(buffer,"FM  ");
 3412               	.LM454:
 3413 04bc 60E0      		ldi r22,lo8(.LC15)
 3414 04be 70E0      		ldi r23,hi8(.LC15)
 3415               	.L251:
 3416 04c0 C601      		movw r24,r12
 3417 04c2 0E94 0000 		call strcpy
 792:main.c        **** 	    lcd_puts(buffer);
 3419               	.LM455:
 3420 04c6 C601      		movw r24,r12
 3421 04c8 0E94 0000 		call lcd_puts
 3422               	.L153:
 3423               	.LBB467:
 3424               	.LBB468:
 3426               	.Ltext34:
 163:/usr/lib/avr/include/util/delay.h **** 
 3428               	.LM456:
 3429 04cc 83E2      		ldi r24,lo8(-3037)
 3430 04ce 94EF      		ldi r25,hi8(-3037)
 3431 04d0 0197      	1:	sbiw r24,1
 3432 04d2 01F4      		brne 1b
 3433 04d4 00C0      		rjmp .
 3434 04d6 0000      		nop
 3435               	.LBE468:
 3436               	.LBE467:
 3438               	.Ltext35:
 793:main.c        **** 	  }
 794:main.c        **** 	}	  
 795:main.c        **** 	break;
 796:main.c        ****       case AM:
 797:main.c        ****       case FM:
 798:main.c        ****       default:
 799:main.c        **** 	mode = USB;
 800:main.c        **** 	if(!updateSettings()) { 
 801:main.c        **** 	  lcd_goto(0x00);
 802:main.c        **** 	  sprintf(buffer,"USB ");
 803:main.c        **** 	  lcd_puts(buffer);
 804:main.c        **** 	}
 805:main.c        **** 	break;
 806:main.c        ****       }
 807:main.c        ****       _delay_ms(250);
 808:main.c        ****       err = updateFreq(freq,clar,1);  // To shift +/-
 3440               	.LM457:
 3441 04d8 21E0      		ldi r18,lo8(1)
 3442 04da 40E0      		ldi r20,0
 3443 04dc 612F      		mov r22,r17
 3444 04de 702F      		mov r23,r16
 3445 04e0 8F2D      		mov r24,r15
 3446 04e2 9E2D      		mov r25,r14
 3447 04e4 0E94 0000 		call updateFreq
 809:main.c        ****       mode_flag = 0x00;
 3449               	.LM458:
 3450 04e8 1092 0000 		sts mode_flag,__zero_reg__
 3451               	.L145:
 810:main.c        ****     }
 811:main.c        **** 
 812:main.c        ****     if (band_flag) {
 3453               	.LM459:
 3454 04ec 8091 0000 		lds r24,band_flag
 3455 04f0 8823      		tst r24
 3456 04f2 01F4      		brne .+2
 3457 04f4 00C0      		rjmp .L156
 813:main.c        ****       if (band_flag == 0x02) { // long press
 3459               	.LM460:
 3460 04f6 8091 0000 		lds r24,band_flag
 3461 04fa 8230      		cpi r24,lo8(2)
 3462 04fc 01F4      		brne .+2
 3463 04fe 00C0      		rjmp .L157
 814:main.c        **** #ifdef TWOMETER_TRANSV
 815:main.c        **** 	if (band == 200) {
 816:main.c        **** 	  band = 201;
 817:main.c        **** 	  freq_offset = 1152;
 818:main.c        **** 	  freq = 144200;
 819:main.c        **** 	  tx_att = 0x01;
 820:main.c        **** 	  rx_att = 0x00;
 821:main.c        **** 	  updateSettings();
 822:main.c        **** 	}
 823:main.c        **** 	else if (band == 201) {
 824:main.c        **** 	  band = 202;
 825:main.c        **** 	  freq_offset = 5616;
 826:main.c        **** 	  freq = 144200;
 827:main.c        **** 	  tx_att = 0x01;
 828:main.c        **** 	  rx_att = 0x00;
 829:main.c        **** 	  updateSettings();
 830:main.c        **** 	}
 831:main.c        **** 	else {
 832:main.c        **** 	  band = 200;
 833:main.c        **** 	  freq_offset = 0;
 834:main.c        **** 	  freq = 144300;
 835:main.c        **** 	  tx_att = 0x00;
 836:main.c        **** 	  rx_att = 0x00;
 837:main.c        **** 	  updateSettings();
 838:main.c        **** 	  /*
 839:main.c        **** 	  band = 160;
 840:main.c        **** 	  freq_offset = 0;
 841:main.c        **** 	  freq = 1810;
 842:main.c        **** 	  tx_att = 0x00;
 843:main.c        **** 	  */
 844:main.c        **** 	}
 845:main.c        **** #endif
 846:main.c        ****       }
 847:main.c        ****       else {
 848:main.c        **** #ifdef HF_HAM
 849:main.c        **** 	if (freq<3500)
 3465               	.LM461:
 3466 0500 20E0      		ldi r18,0
 3467 0502 30EC      		ldi r19,lo8(-64)
 3468 0504 4AE5      		ldi r20,lo8(90)
 3469 0506 55E4      		ldi r21,lo8(69)
 3470 0508 612F      		mov r22,r17
 3471 050a 702F      		mov r23,r16
 3472 050c 8F2D      		mov r24,r15
 3473 050e 9E2D      		mov r25,r14
 3474 0510 0E94 0000 		call __ltsf2
 3475 0514 87FD      		sbrc r24,7
 3476 0516 00C0      		rjmp .L194
 850:main.c        **** 	  freq = 3510;
 851:main.c        **** 	else if(freq<7000)
 3478               	.LM462:
 3479 0518 20E0      		ldi r18,0
 3480 051a 30EC      		ldi r19,lo8(-64)
 3481 051c 4AED      		ldi r20,lo8(-38)
 3482 051e 55E4      		ldi r21,lo8(69)
 3483 0520 612F      		mov r22,r17
 3484 0522 702F      		mov r23,r16
 3485 0524 8F2D      		mov r24,r15
 3486 0526 9E2D      		mov r25,r14
 3487 0528 0E94 0000 		call __ltsf2
 3488 052c 87FD      		sbrc r24,7
 3489 052e 00C0      		rjmp .L195
 852:main.c        **** 	  freq = 7010;
 853:main.c        **** 	else if(freq<10100)
 3491               	.LM463:
 3492 0530 20E0      		ldi r18,0
 3493 0532 30ED      		ldi r19,lo8(-48)
 3494 0534 4DE1      		ldi r20,lo8(29)
 3495 0536 56E4      		ldi r21,lo8(70)
 3496 0538 612F      		mov r22,r17
 3497 053a 702F      		mov r23,r16
 3498 053c 8F2D      		mov r24,r15
 3499 053e 9E2D      		mov r25,r14
 3500 0540 0E94 0000 		call __ltsf2
 3501 0544 87FD      		sbrc r24,7
 3502 0546 00C0      		rjmp .L196
 854:main.c        **** 	  freq = 10110;
 855:main.c        **** 	else if(freq<14000)
 3504               	.LM464:
 3505 0548 20E0      		ldi r18,0
 3506 054a 30EC      		ldi r19,lo8(-64)
 3507 054c 4AE5      		ldi r20,lo8(90)
 3508 054e 56E4      		ldi r21,lo8(70)
 3509 0550 612F      		mov r22,r17
 3510 0552 702F      		mov r23,r16
 3511 0554 8F2D      		mov r24,r15
 3512 0556 9E2D      		mov r25,r14
 3513 0558 0E94 0000 		call __ltsf2
 3514 055c 87FD      		sbrc r24,7
 3515 055e 00C0      		rjmp .L197
 856:main.c        **** 	  freq = 14010;
 857:main.c        **** 	else if(freq<18068)
 3517               	.LM465:
 3518 0560 20E0      		ldi r18,0
 3519 0562 38E2      		ldi r19,lo8(40)
 3520 0564 4DE8      		ldi r20,lo8(-115)
 3521 0566 56E4      		ldi r21,lo8(70)
 3522 0568 612F      		mov r22,r17
 3523 056a 702F      		mov r23,r16
 3524 056c 8F2D      		mov r24,r15
 3525 056e 9E2D      		mov r25,r14
 3526 0570 0E94 0000 		call __ltsf2
 3527 0574 87FD      		sbrc r24,7
 3528 0576 00C0      		rjmp .L198
 858:main.c        **** 	  freq = 18078;
 859:main.c        **** 	else if(freq<21000)
 3530               	.LM466:
 3531 0578 20E0      		ldi r18,0
 3532 057a 30E1      		ldi r19,lo8(16)
 3533 057c 44EA      		ldi r20,lo8(-92)
 3534 057e 56E4      		ldi r21,lo8(70)
 3535 0580 612F      		mov r22,r17
 3536 0582 702F      		mov r23,r16
 3537 0584 8F2D      		mov r24,r15
 3538 0586 9E2D      		mov r25,r14
 3539 0588 0E94 0000 		call __ltsf2
 3540 058c 87FD      		sbrc r24,7
 3541 058e 00C0      		rjmp .L199
 860:main.c        **** 	  freq = 21010;
 861:main.c        **** 	else if(freq<24890)
 3543               	.LM467:
 3544 0590 20E0      		ldi r18,0
 3545 0592 34E7      		ldi r19,lo8(116)
 3546 0594 42EC      		ldi r20,lo8(-62)
 3547 0596 56E4      		ldi r21,lo8(70)
 3548 0598 612F      		mov r22,r17
 3549 059a 702F      		mov r23,r16
 3550 059c 8F2D      		mov r24,r15
 3551 059e 9E2D      		mov r25,r14
 3552 05a0 0E94 0000 		call __ltsf2
 3553 05a4 87FD      		sbrc r24,7
 3554 05a6 00C0      		rjmp .L200
 862:main.c        **** 	  freq = 24900;
 863:main.c        **** 	else if(freq<28000)
 3556               	.LM468:
 3557 05a8 20E0      		ldi r18,0
 3558 05aa 30EC      		ldi r19,lo8(-64)
 3559 05ac 4AED      		ldi r20,lo8(-38)
 3560 05ae 56E4      		ldi r21,lo8(70)
 3561 05b0 612F      		mov r22,r17
 3562 05b2 702F      		mov r23,r16
 3563 05b4 8F2D      		mov r24,r15
 3564 05b6 9E2D      		mov r25,r14
 3565 05b8 0E94 0000 		call __ltsf2
 3566 05bc 87FD      		sbrc r24,7
 3567 05be 00C0      		rjmp .L201
 864:main.c        **** 	  freq = 28010;
 865:main.c        **** 	else if(freq<28500)
 3569               	.LM469:
 3570 05c0 20E0      		ldi r18,0
 3571 05c2 38EA      		ldi r19,lo8(-88)
 3572 05c4 4EED      		ldi r20,lo8(-34)
 3573 05c6 56E4      		ldi r21,lo8(70)
 3574 05c8 612F      		mov r22,r17
 3575 05ca 702F      		mov r23,r16
 3576 05cc 8F2D      		mov r24,r15
 3577 05ce 9E2D      		mov r25,r14
 3578 05d0 0E94 0000 		call __ltsf2
 866:main.c        **** 	  freq = 28600;
 3580               	.LM470:
 3581 05d4 10E0      		ldi r17,0
 865:main.c        **** 	  freq = 28600;
 3583               	.LM471:
 3584 05d6 87FD      		sbrc r24,7
 3585 05d8 00C0      		rjmp .L202
 867:main.c        **** 	else
 868:main.c        **** 	  freq = 1810;
 3587               	.LM472:
 3588 05da 00E4      		ldi r16,lo8(64)
 3589 05dc 92EE      		ldi r25,lo8(-30)
 3590 05de F92E      		mov r15,r25
 3591 05e0 24E4      		ldi r18,lo8(68)
 3592 05e2 E22E      		mov r14,r18
 3593 05e4 00C0      		rjmp .L157
 3594               	.L194:
 850:main.c        **** 	else if(freq<7000)
 3596               	.LM473:
 3597 05e6 10E0      		ldi r17,0
 3598 05e8 00E6      		ldi r16,lo8(96)
 3599 05ea 8BE5      		ldi r24,lo8(91)
 3600 05ec F82E      		mov r15,r24
 3601 05ee 00C0      		rjmp .L253
 3602               	.L195:
 852:main.c        **** 	else if(freq<10100)
 3604               	.LM474:
 3605 05f0 10E0      		ldi r17,0
 3606 05f2 00E1      		ldi r16,lo8(16)
 3607 05f4 BBED      		ldi r27,lo8(-37)
 3608 05f6 FB2E      		mov r15,r27
 3609               	.L253:
 3610 05f8 A5E4      		ldi r26,lo8(69)
 3611 05fa EA2E      		mov r14,r26
 3612 05fc 00C0      		rjmp .L157
 3613               	.L196:
 854:main.c        **** 	else if(freq<14000)
 3615               	.LM475:
 3616 05fe 10E0      		ldi r17,0
 3617 0600 08EF      		ldi r16,lo8(-8)
 3618 0602 FDE1      		ldi r31,lo8(29)
 3619 0604 FF2E      		mov r15,r31
 3620 0606 00C0      		rjmp .L252
 3621               	.L197:
 856:main.c        **** 	else if(freq<18068)
 3623               	.LM476:
 3624 0608 10E0      		ldi r17,0
 3625 060a 08EE      		ldi r16,lo8(-24)
 3626 060c EAE5      		ldi r30,lo8(90)
 3627 060e FE2E      		mov r15,r30
 3628 0610 00C0      		rjmp .L252
 3629               	.L198:
 858:main.c        **** 	else if(freq<21000)
 3631               	.LM477:
 3632 0612 10E0      		ldi r17,0
 3633 0614 0CE3      		ldi r16,lo8(60)
 3634 0616 7DE8      		ldi r23,lo8(-115)
 3635 0618 F72E      		mov r15,r23
 3636 061a 00C0      		rjmp .L252
 3637               	.L199:
 860:main.c        **** 	else if(freq<24890)
 3639               	.LM478:
 3640 061c 10E0      		ldi r17,0
 3641 061e 04E2      		ldi r16,lo8(36)
 3642 0620 64EA      		ldi r22,lo8(-92)
 3643 0622 F62E      		mov r15,r22
 3644 0624 00C0      		rjmp .L252
 3645               	.L200:
 862:main.c        **** 	else if(freq<28000)
 3647               	.LM479:
 3648 0626 10E0      		ldi r17,0
 3649 0628 08E8      		ldi r16,lo8(-120)
 3650 062a 52EC      		ldi r21,lo8(-62)
 3651 062c F52E      		mov r15,r21
 3652 062e 00C0      		rjmp .L252
 3653               	.L201:
 864:main.c        **** 	else if(freq<28500)
 3655               	.LM480:
 3656 0630 10E0      		ldi r17,0
 3657 0632 04ED      		ldi r16,lo8(-44)
 3658 0634 4AED      		ldi r20,lo8(-38)
 3659 0636 F42E      		mov r15,r20
 3660 0638 00C0      		rjmp .L252
 3661               	.L202:
 866:main.c        **** 	else
 3663               	.LM481:
 3664 063a 00E7      		ldi r16,lo8(112)
 3665 063c 3FED      		ldi r19,lo8(-33)
 3666 063e F32E      		mov r15,r19
 3667               	.L252:
 3668 0640 26E4      		ldi r18,lo8(70)
 3669 0642 E22E      		mov r14,r18
 3670               	.L157:
 869:main.c        **** #endif
 870:main.c        **** #ifdef TWOMETER
 871:main.c        ****       if(freq<144150)
 872:main.c        **** 	freq = 144300;
 873:main.c        ****       else if(freq<144400)
 874:main.c        **** 	freq = 144450;
 875:main.c        ****       else if(freq<145000)
 876:main.c        **** 	freq = 145500;
 877:main.c        ****       else if(freq<150000)
 878:main.c        **** 	freq = 144050;
 879:main.c        **** #endif
 880:main.c        **** #ifdef TWOMETER_TRANSV
 881:main.c        ****       if(freq<144700)
 882:main.c        **** 	freq = 144800;
 883:main.c        ****       else if(freq<150000)
 884:main.c        **** 	freq = 144200;
 885:main.c        **** #endif
 886:main.c        ****       }
 887:main.c        **** 
 888:main.c        ****       lcd_freq();
 3672               	.LM482:
 3673 0644 84E0      		ldi r24,lo8(4)
 3674 0646 0E94 0000 		call lcd_goto
 3675 064a 20E0      		ldi r18,0
 3676 064c 30E0      		ldi r19,0
 3677 064e 4AE7      		ldi r20,lo8(122)
 3678 0650 54E4      		ldi r21,lo8(68)
 3679 0652 612F      		mov r22,r17
 3680 0654 702F      		mov r23,r16
 3681 0656 8F2D      		mov r24,r15
 3682 0658 9E2D      		mov r25,r14
 3683 065a 0E94 0000 		call fmod
 3684 065e 2496      		adiw r28,67-63
 3685 0660 6FAF      		std Y+63,r22
 3686 0662 2497      		sbiw r28,67-63
 3687 0664 2596      		adiw r28,68-63
 3688 0666 7FAF      		std Y+63,r23
 3689 0668 2597      		sbiw r28,68-63
 3690 066a 2696      		adiw r28,69-63
 3691 066c 8FAF      		std Y+63,r24
 3692 066e 2697      		sbiw r28,69-63
 3693 0670 2796      		adiw r28,70-63
 3694 0672 9FAF      		std Y+63,r25
 3695 0674 2797      		sbiw r28,70-63
 3696 0676 20E0      		ldi r18,0
 3697 0678 30E0      		ldi r19,0
 3698 067a 4AE7      		ldi r20,lo8(122)
 3699 067c 54E4      		ldi r21,lo8(68)
 3700 067e 612F      		mov r22,r17
 3701 0680 702F      		mov r23,r16
 3702 0682 8F2D      		mov r24,r15
 3703 0684 9E2D      		mov r25,r14
 3704 0686 0E94 0000 		call __divsf3
 3705 068a 1B01      		movw r2,r22
 3706 068c 2C01      		movw r4,r24
 3707 068e 60E0      		ldi r22,0
 3708 0690 70E0      		ldi r23,0
 3709 0692 CB01      		movw r24,r22
 3710 0694 0E94 0000 		call __floatsisf
 3711 0698 9B01      		movw r18,r22
 3712 069a AC01      		movw r20,r24
 3713 069c C201      		movw r24,r4
 3714 069e B101      		movw r22,r2
 3715 06a0 0E94 0000 		call __addsf3
 3716 06a4 0E94 0000 		call floor
 3717 06a8 2796      		adiw r28,70-63
 3718 06aa AFAD      		ldd r26,Y+63
 3719 06ac 2797      		sbiw r28,70-63
 3720 06ae AF93      		push r26
 3721 06b0 2696      		adiw r28,69-63
 3722 06b2 BFAD      		ldd r27,Y+63
 3723 06b4 2697      		sbiw r28,69-63
 3724 06b6 BF93      		push r27
 3725 06b8 2596      		adiw r28,68-63
 3726 06ba 2FAD      		ldd r18,Y+63
 3727 06bc 2597      		sbiw r28,68-63
 3728 06be 2F93      		push r18
 3729 06c0 2496      		adiw r28,67-63
 3730 06c2 3FAD      		ldd r19,Y+63
 3731 06c4 2497      		sbiw r28,67-63
 3732 06c6 3F93      		push r19
 3733 06c8 0E94 0000 		call __fixsfsi
 3734 06cc 7F93      		push r23
 3735 06ce 6F93      		push r22
 3736 06d0 80E0      		ldi r24,lo8(.LC0)
 3737 06d2 90E0      		ldi r25,hi8(.LC0)
 3738 06d4 9F93      		push r25
 3739 06d6 8F93      		push r24
 3740 06d8 DF92      		push r13
 3741 06da CF92      		push r12
 3742 06dc 0E94 0000 		call sprintf
 3743 06e0 C601      		movw r24,r12
 3744 06e2 0E94 0000 		call lcd_puts
 3745 06e6 8FE0      		ldi r24,lo8(15)
 3746 06e8 0E94 0000 		call lcd_goto
 3747 06ec 60E0      		ldi r22,lo8(.LC1)
 3748 06ee 70E0      		ldi r23,hi8(.LC1)
 3749 06f0 C601      		movw r24,r12
 3750 06f2 0E94 0000 		call strcpy
 3751 06f6 C601      		movw r24,r12
 3752 06f8 0E94 0000 		call lcd_puts
 889:main.c        ****       err = updateFreq(freq,clar,1);
 3754               	.LM483:
 3755 06fc 21E0      		ldi r18,lo8(1)
 3756 06fe 40E0      		ldi r20,0
 3757 0700 612F      		mov r22,r17
 3758 0702 702F      		mov r23,r16
 3759 0704 8F2D      		mov r24,r15
 3760 0706 9E2D      		mov r25,r14
 3761 0708 0E94 0000 		call updateFreq
 890:main.c        ****       if (err) {
 3763               	.LM484:
 3764 070c 0FB6      		in __tmp_reg__,__SREG__
 3765 070e F894      		cli
 3766 0710 DEBF      		out __SP_H__,r29
 3767 0712 0FBE      		out __SREG__,__tmp_reg__
 3768 0714 CDBF      		out __SP_L__,r28
 3769 0716 8823      		tst r24
 3770 0718 01F0      		breq .L158
 891:main.c        **** 	sprintf(buffer,"Err %x         ",err);
 3772               	.LM485:
 3773 071a 1F92      		push __zero_reg__
 3774 071c 8F93      		push r24
 3775 071e 80E0      		ldi r24,lo8(.LC2)
 3776 0720 90E0      		ldi r25,hi8(.LC2)
 3777 0722 9F93      		push r25
 3778 0724 8F93      		push r24
 3779 0726 DF92      		push r13
 3780 0728 CF92      		push r12
 3781 072a 0E94 0000 		call sprintf
 892:main.c        **** 	lcd_goto(0x40);
 3783               	.LM486:
 3784 072e 80E4      		ldi r24,lo8(64)
 3785 0730 0E94 0000 		call lcd_goto
 893:main.c        **** 	lcd_puts(buffer);	
 3787               	.LM487:
 3788 0734 C601      		movw r24,r12
 3789 0736 0E94 0000 		call lcd_puts
 3790 073a 0F90      		pop __tmp_reg__
 3791 073c 0F90      		pop __tmp_reg__
 3792 073e 0F90      		pop __tmp_reg__
 3793 0740 0F90      		pop __tmp_reg__
 3794 0742 0F90      		pop __tmp_reg__
 3795 0744 0F90      		pop __tmp_reg__
 3796               	.L158:
 894:main.c        ****       }      
 895:main.c        ****       err = updateSettings();
 3798               	.LM488:
 3799 0746 0E94 0000 		call updateSettings
 896:main.c        ****       if (err) {
 3801               	.LM489:
 3802 074a 8823      		tst r24
 3803 074c 01F0      		breq .L159
 897:main.c        **** 	sprintf(buffer,"Err %x         ",err);
 3805               	.LM490:
 3806 074e 1F92      		push __zero_reg__
 3807 0750 8F93      		push r24
 3808 0752 80E0      		ldi r24,lo8(.LC2)
 3809 0754 90E0      		ldi r25,hi8(.LC2)
 3810 0756 9F93      		push r25
 3811 0758 8F93      		push r24
 3812 075a DF92      		push r13
 3813 075c CF92      		push r12
 3814 075e 0E94 0000 		call sprintf
 898:main.c        **** 	lcd_goto(0x40);
 3816               	.LM491:
 3817 0762 80E4      		ldi r24,lo8(64)
 3818 0764 0E94 0000 		call lcd_goto
 899:main.c        **** 	lcd_puts(buffer);	
 3820               	.LM492:
 3821 0768 C601      		movw r24,r12
 3822 076a 0E94 0000 		call lcd_puts
 3823 076e 0F90      		pop __tmp_reg__
 3824 0770 0F90      		pop __tmp_reg__
 3825 0772 0F90      		pop __tmp_reg__
 3826 0774 0F90      		pop __tmp_reg__
 3827 0776 0F90      		pop __tmp_reg__
 3828 0778 0F90      		pop __tmp_reg__
 3829               	.L159:
 3830               	.LBB469:
 3831               	.LBB470:
 3833               	.Ltext36:
 163:/usr/lib/avr/include/util/delay.h **** 
 3835               	.LM493:
 3836 077a 8FE4      		ldi r24,lo8(-15537)
 3837 077c 93EC      		ldi r25,hi8(-15537)
 3838 077e 0197      	1:	sbiw r24,1
 3839 0780 01F4      		brne 1b
 3840 0782 00C0      		rjmp .
 3841 0784 0000      		nop
 3842               	.LBE470:
 3843               	.LBE469:
 3845               	.Ltext37:
 900:main.c        ****       }      
 901:main.c        ****       _delay_ms(200);
 902:main.c        ****       band_flag = 0x00;
 3847               	.LM494:
 3848 0786 1092 0000 		sts band_flag,__zero_reg__
 3849 078a 00C0      		rjmp .L118
 3850               	.L156:
 903:main.c        ****     }
 904:main.c        ****     else if (rot_flag) {
 3852               	.LM495:
 3853 078c 8091 0000 		lds r24,rot_flag
 3854 0790 8823      		tst r24
 3855 0792 01F4      		brne .+2
 3856 0794 00C0      		rjmp .L161
 905:main.c        ****       if (rot_flag != last_dir) {
 3858               	.LM496:
 3859 0796 8091 0000 		lds r24,rot_flag
 3860 079a 2396      		adiw r28,66-63
 3861 079c 9FAD      		ldd r25,Y+63
 3862 079e 2397      		sbiw r28,66-63
 3863 07a0 8917      		cp r24,r25
 3864 07a2 01F0      		breq .L162
 906:main.c        **** 	steps = 0;
 907:main.c        **** 	step_timer = 0;
 3866               	.LM497:
 3867 07a4 1092 0000 		sts step_timer+1,__zero_reg__
 3868 07a8 1092 0000 		sts step_timer,__zero_reg__
 908:main.c        **** 	last_dir = rot_flag;
 3870               	.LM498:
 3871 07ac 8091 0000 		lds r24,rot_flag
 906:main.c        **** 	steps = 0;
 3873               	.LM499:
 3874 07b0 612C      		mov r6,__zero_reg__
 3875 07b2 712C      		mov r7,__zero_reg__
 3876 07b4 00C0      		rjmp .L163
 3877               	.L162:
 909:main.c        ****       }
 910:main.c        ****       else if (rot_flag == 0x01) {
 3879               	.LM500:
 3880 07b6 9091 0000 		lds r25,rot_flag
 3881 07ba 9130      		cpi r25,lo8(1)
 3882 07bc 01F0      		breq .+2
 3883 07be 00C0      		rjmp .L164
 911:main.c        **** 	if (step_timer < 30) {
 3885               	.LM501:
 3886 07c0 8091 0000 		lds r24,step_timer
 3887 07c4 9091 0000 		lds r25,step_timer+1
 912:main.c        **** 	  step_timer = 0;
 3889               	.LM502:
 3890 07c8 1092 0000 		sts step_timer+1,__zero_reg__
 3891 07cc 1092 0000 		sts step_timer,__zero_reg__
 911:main.c        **** 	if (step_timer < 30) {
 3893               	.LM503:
 3894 07d0 4E97      		sbiw r24,30
 3895 07d2 00F4      		brsh .L165
 913:main.c        **** 	  steps ++;
 3897               	.LM504:
 3898 07d4 AFEF      		ldi r26,-1
 3899 07d6 6A1A      		sub r6,r26
 3900 07d8 7A0A      		sbc r7,r26
 914:main.c        **** 	}
 915:main.c        **** 	else {
 916:main.c        **** 	  step_timer = 0;
 917:main.c        **** 	  steps = 1;
 918:main.c        **** 	}
 919:main.c        **** 	
 920:main.c        **** 	if (steps > 500) {
 3902               	.LM505:
 3903 07da B5EF      		ldi r27,-11
 3904 07dc 6B16      		cp r6,r27
 3905 07de B1E0      		ldi r27,1
 3906 07e0 7B06      		cpc r7,r27
 3907 07e2 00F4      		brsh .L166
 3908 07e4 00C0      		rjmp .L262
 3909               	.L165:
 917:main.c        **** 	}
 3911               	.LM506:
 3912 07e6 6624      		clr r6
 3913 07e8 6394      		inc r6
 3914 07ea 712C      		mov r7,__zero_reg__
 3915 07ec 00C0      		rjmp .L168
 3916               	.L166:
 921:main.c        **** 	  if (mode == AM)
 3918               	.LM507:
 3919 07ee 8091 0000 		lds r24,mode
 3920 07f2 8830      		cpi r24,lo8(8)
 3921 07f4 01F4      		brne .L169
 922:main.c        **** 	    freq += 20;
 3923               	.LM508:
 3924 07f6 20E0      		ldi r18,0
 3925 07f8 30E0      		ldi r19,0
 3926 07fa 40EA      		ldi r20,lo8(-96)
 3927 07fc 51E4      		ldi r21,lo8(65)
 3928 07fe 00C0      		rjmp .L254
 3929               	.L169:
 923:main.c        **** 	  else if (mode == FM)
 3931               	.LM509:
 3932 0800 8091 0000 		lds r24,mode
 3933 0804 8A30      		cpi r24,lo8(10)
 3934 0806 01F4      		brne .L259
 924:main.c        **** 	    freq += 50;
 3936               	.LM510:
 3937 0808 20E0      		ldi r18,0
 3938 080a 30E0      		ldi r19,0
 3939 080c 48E4      		ldi r20,lo8(72)
 3940 080e 52E4      		ldi r21,lo8(66)
 3941 0810 00C0      		rjmp .L254
 3942               	.L262:
 925:main.c        **** 	  else
 926:main.c        **** 	    freq += 1;
 927:main.c        **** 	}
 928:main.c        **** 	else if (steps > 150) {
 3944               	.LM511:
 3945 0812 27E9      		ldi r18,-105
 3946 0814 6216      		cp r6,r18
 3947 0816 7104      		cpc r7,__zero_reg__
 3948 0818 00F0      		brlo .L168
 929:main.c        **** 	  if (mode == AM)
 3950               	.LM512:
 3951 081a 8091 0000 		lds r24,mode
 3952 081e 8830      		cpi r24,lo8(8)
 3953 0820 01F4      		brne .L171
 930:main.c        **** 	    freq += 5;
 3955               	.LM513:
 3956 0822 20E0      		ldi r18,0
 3957 0824 30E0      		ldi r19,0
 3958 0826 40EA      		ldi r20,lo8(-96)
 3959 0828 50E4      		ldi r21,lo8(64)
 3960 082a 00C0      		rjmp .L254
 3961               	.L171:
 931:main.c        **** 	  else if (mode == FM)
 3963               	.LM514:
 3964 082c 8091 0000 		lds r24,mode
 3965 0830 8A30      		cpi r24,lo8(10)
 3966 0832 01F4      		brne .L172
 932:main.c        **** 	    freq += 25;
 3968               	.LM515:
 3969 0834 20E0      		ldi r18,0
 3970 0836 30E0      		ldi r19,0
 3971 0838 48EC      		ldi r20,lo8(-56)
 3972 083a 51E4      		ldi r21,lo8(65)
 3973 083c 00C0      		rjmp .L254
 3974               	.L172:
 933:main.c        **** 	  else
 934:main.c        **** 	    freq += 0.5;
 3976               	.LM516:
 3977 083e 20E0      		ldi r18,0
 3978 0840 30E0      		ldi r19,0
 3979 0842 40E0      		ldi r20,0
 3980 0844 5FE3      		ldi r21,lo8(63)
 3981 0846 00C0      		rjmp .L254
 3982               	.L168:
 935:main.c        **** 	}
 936:main.c        **** 	else {
 937:main.c        **** 	  if (mode == AM)
 3984               	.LM517:
 3985 0848 8091 0000 		lds r24,mode
 3986 084c 8830      		cpi r24,lo8(8)
 3987 084e 01F4      		brne .L173
 3988               	.L259:
 938:main.c        **** 	    freq += 1;
 3990               	.LM518:
 3991 0850 20E0      		ldi r18,0
 3992 0852 30E0      		ldi r19,0
 3993 0854 40E8      		ldi r20,lo8(-128)
 3994 0856 5FE3      		ldi r21,lo8(63)
 3995 0858 00C0      		rjmp .L254
 3996               	.L173:
 939:main.c        **** 	  else if (mode == FM)
 3998               	.LM519:
 3999 085a 8091 0000 		lds r24,mode
 4000 085e 8A30      		cpi r24,lo8(10)
 4001 0860 01F4      		brne .L174
 940:main.c        **** 	    freq += 2.5;
 4003               	.LM520:
 4004 0862 20E0      		ldi r18,0
 4005 0864 30E0      		ldi r19,0
 4006 0866 40E2      		ldi r20,lo8(32)
 4007 0868 50E4      		ldi r21,lo8(64)
 4008 086a 00C0      		rjmp .L254
 4009               	.L174:
 941:main.c        **** 	  else
 942:main.c        **** 	    freq+=0.05;
 4011               	.LM521:
 4012 086c 2DEC      		ldi r18,lo8(-51)
 4013 086e 3CEC      		ldi r19,lo8(-52)
 4014 0870 4CE4      		ldi r20,lo8(76)
 4015 0872 5DE3      		ldi r21,lo8(61)
 4016               	.L254:
 4017 0874 612F      		mov r22,r17
 4018 0876 702F      		mov r23,r16
 4019 0878 8F2D      		mov r24,r15
 4020 087a 9E2D      		mov r25,r14
 4021 087c 0E94 0000 		call __addsf3
 4022 0880 162F      		mov r17,r22
 4023 0882 072F      		mov r16,r23
 4024 0884 F82E      		mov r15,r24
 4025 0886 E92E      		mov r14,r25
 943:main.c        **** 	}
 944:main.c        **** 	last_dir = 0x01;
 4027               	.LM522:
 4028 0888 81E0      		ldi r24,lo8(1)
 4029 088a 00C0      		rjmp .L163
 4030               	.L164:
 945:main.c        ****       }
 946:main.c        ****       else if (rot_flag == 0x02) {
 4032               	.LM523:
 4033 088c 9091 0000 		lds r25,rot_flag
 4034 0890 9230      		cpi r25,lo8(2)
 4035 0892 01F0      		breq .+2
 4036 0894 00C0      		rjmp .L163
 947:main.c        **** 	if ((step_timer < 30) && (last_dir == rot_flag)) {
 4038               	.LM524:
 4039 0896 8091 0000 		lds r24,step_timer
 4040 089a 9091 0000 		lds r25,step_timer+1
 4041 089e 4E97      		sbiw r24,30
 4042 08a0 00F4      		brsh .L175
 4044               	.LM525:
 4045 08a2 8091 0000 		lds r24,rot_flag
 4046 08a6 2396      		adiw r28,66-63
 4047 08a8 3FAD      		ldd r19,Y+63
 4048 08aa 2397      		sbiw r28,66-63
 4049 08ac 3813      		cpse r19,r24
 4050 08ae 00C0      		rjmp .L175
 948:main.c        **** 	  step_timer = 0;
 4052               	.LM526:
 4053 08b0 1092 0000 		sts step_timer+1,__zero_reg__
 4054 08b4 1092 0000 		sts step_timer,__zero_reg__
 949:main.c        **** 	  steps ++;
 4056               	.LM527:
 4057 08b8 8FEF      		ldi r24,-1
 4058 08ba 681A      		sub r6,r24
 4059 08bc 780A      		sbc r7,r24
 950:main.c        **** 	}
 951:main.c        **** 	else {
 952:main.c        **** 	  step_timer = 0;
 953:main.c        **** 	  steps = 1;
 954:main.c        **** 	}
 955:main.c        **** 	
 956:main.c        **** 	if (steps > 500) {
 4061               	.LM528:
 4062 08be 95EF      		ldi r25,-11
 4063 08c0 6916      		cp r6,r25
 4064 08c2 91E0      		ldi r25,1
 4065 08c4 7906      		cpc r7,r25
 4066 08c6 00F4      		brsh .L176
 4067 08c8 00C0      		rjmp .L263
 4068               	.L175:
 952:main.c        **** 	  steps = 1;
 4070               	.LM529:
 4071 08ca 1092 0000 		sts step_timer+1,__zero_reg__
 4072 08ce 1092 0000 		sts step_timer,__zero_reg__
 953:main.c        **** 	}
 4074               	.LM530:
 4075 08d2 6624      		clr r6
 4076 08d4 6394      		inc r6
 4077 08d6 712C      		mov r7,__zero_reg__
 4078 08d8 00C0      		rjmp .L178
 4079               	.L176:
 957:main.c        **** 	  if (mode == AM)
 4081               	.LM531:
 4082 08da 8091 0000 		lds r24,mode
 4083 08de 8830      		cpi r24,lo8(8)
 4084 08e0 01F4      		brne .L179
 958:main.c        **** 	    freq -= 20;
 4086               	.LM532:
 4087 08e2 20E0      		ldi r18,0
 4088 08e4 30E0      		ldi r19,0
 4089 08e6 40EA      		ldi r20,lo8(-96)
 4090 08e8 51E4      		ldi r21,lo8(65)
 4091 08ea 00C0      		rjmp .L255
 4092               	.L179:
 959:main.c        **** 	  else if (mode == FM)
 4094               	.LM533:
 4095 08ec 8091 0000 		lds r24,mode
 4096 08f0 8A30      		cpi r24,lo8(10)
 4097 08f2 01F4      		brne .L260
 960:main.c        **** 	    freq -= 50;
 4099               	.LM534:
 4100 08f4 20E0      		ldi r18,0
 4101 08f6 30E0      		ldi r19,0
 4102 08f8 48E4      		ldi r20,lo8(72)
 4103 08fa 52E4      		ldi r21,lo8(66)
 4104 08fc 00C0      		rjmp .L255
 4105               	.L263:
 961:main.c        **** 	  else
 962:main.c        **** 	    freq -= 1;
 963:main.c        **** 	}
 964:main.c        **** 	else if (steps > 150) {
 4107               	.LM535:
 4108 08fe A7E9      		ldi r26,-105
 4109 0900 6A16      		cp r6,r26
 4110 0902 7104      		cpc r7,__zero_reg__
 4111 0904 00F0      		brlo .L178
 965:main.c        **** 	  if (mode == AM)
 4113               	.LM536:
 4114 0906 8091 0000 		lds r24,mode
 4115 090a 8830      		cpi r24,lo8(8)
 4116 090c 01F4      		brne .L181
 966:main.c        **** 	    freq -= 5;
 4118               	.LM537:
 4119 090e 20E0      		ldi r18,0
 4120 0910 30E0      		ldi r19,0
 4121 0912 40EA      		ldi r20,lo8(-96)
 4122 0914 50E4      		ldi r21,lo8(64)
 4123 0916 00C0      		rjmp .L255
 4124               	.L181:
 967:main.c        **** 	  else if (mode == FM)
 4126               	.LM538:
 4127 0918 8091 0000 		lds r24,mode
 4128 091c 8A30      		cpi r24,lo8(10)
 4129 091e 01F4      		brne .L182
 968:main.c        **** 	    freq -= 25;
 4131               	.LM539:
 4132 0920 20E0      		ldi r18,0
 4133 0922 30E0      		ldi r19,0
 4134 0924 48EC      		ldi r20,lo8(-56)
 4135 0926 51E4      		ldi r21,lo8(65)
 4136 0928 00C0      		rjmp .L255
 4137               	.L182:
 969:main.c        **** 	  else
 970:main.c        **** 	    freq -= 0.5;
 4139               	.LM540:
 4140 092a 20E0      		ldi r18,0
 4141 092c 30E0      		ldi r19,0
 4142 092e 40E0      		ldi r20,0
 4143 0930 5FE3      		ldi r21,lo8(63)
 4144 0932 00C0      		rjmp .L255
 4145               	.L178:
 971:main.c        **** 	}
 972:main.c        **** 	else {
 973:main.c        **** 	  if (mode == AM)
 4147               	.LM541:
 4148 0934 8091 0000 		lds r24,mode
 4149 0938 8830      		cpi r24,lo8(8)
 4150 093a 01F4      		brne .L183
 4151               	.L260:
 974:main.c        **** 	    freq -= 1;
 4153               	.LM542:
 4154 093c 20E0      		ldi r18,0
 4155 093e 30E0      		ldi r19,0
 4156 0940 40E8      		ldi r20,lo8(-128)
 4157 0942 5FE3      		ldi r21,lo8(63)
 4158 0944 00C0      		rjmp .L255
 4159               	.L183:
 975:main.c        **** 	  else if (mode == FM)
 4161               	.LM543:
 4162 0946 8091 0000 		lds r24,mode
 4163 094a 8A30      		cpi r24,lo8(10)
 4164 094c 01F4      		brne .L184
 976:main.c        **** 	    freq -= 2.5;
 4166               	.LM544:
 4167 094e 20E0      		ldi r18,0
 4168 0950 30E0      		ldi r19,0
 4169 0952 40E2      		ldi r20,lo8(32)
 4170 0954 50E4      		ldi r21,lo8(64)
 4171 0956 00C0      		rjmp .L255
 4172               	.L184:
 977:main.c        **** 	  else
 978:main.c        **** 	    freq-=0.05;
 4174               	.LM545:
 4175 0958 2DEC      		ldi r18,lo8(-51)
 4176 095a 3CEC      		ldi r19,lo8(-52)
 4177 095c 4CE4      		ldi r20,lo8(76)
 4178 095e 5DE3      		ldi r21,lo8(61)
 4179               	.L255:
 4180 0960 612F      		mov r22,r17
 4181 0962 702F      		mov r23,r16
 4182 0964 8F2D      		mov r24,r15
 4183 0966 9E2D      		mov r25,r14
 4184 0968 0E94 0000 		call __subsf3
 4185 096c 162F      		mov r17,r22
 4186 096e 072F      		mov r16,r23
 4187 0970 F82E      		mov r15,r24
 4188 0972 E92E      		mov r14,r25
 979:main.c        **** 	}
 980:main.c        ****       last_dir = 0x02;
 4190               	.LM546:
 4191 0974 82E0      		ldi r24,lo8(2)
 4192               	.L163:
 981:main.c        ****       }
 982:main.c        ****       //_delay_ms(30);
 983:main.c        **** 
 984:main.c        ****       rot_flag = 0x00;
 4194               	.LM547:
 4195 0976 1092 0000 		sts rot_flag,__zero_reg__
 4196 097a 2396      		adiw r28,66-63
 4197 097c 8FAF      		std Y+63,r24
 4198 097e 2397      		sbiw r28,66-63
 4199 0980 00C0      		rjmp .L118
 4200               	.L161:
 985:main.c        ****     }
 986:main.c        ****     else if (vol_flag) {
 4202               	.LM548:
 4203 0982 8091 0000 		lds r24,vol_flag
 4204 0986 8823      		tst r24
 4205 0988 01F4      		brne .+2
 4206 098a 00C0      		rjmp .L118
 987:main.c        ****       if (vol_timer > 1) {
 4208               	.LM549:
 4209 098c 8091 0000 		lds r24,vol_timer
 4210 0990 8230      		cpi r24,lo8(2)
 4211 0992 00F4      		brsh .+2
 4212 0994 00C0      		rjmp .L185
 988:main.c        **** 	if (vol_flag == 0x01) {
 4214               	.LM550:
 4215 0996 8091 0000 		lds r24,vol_flag
 4216 099a 8130      		cpi r24,lo8(1)
 4217 099c 01F4      		brne .L186
 989:main.c        **** 	  if(vol<31)
 4219               	.LM551:
 4220 099e BEE1      		ldi r27,lo8(30)
 4221 09a0 B915      		cp r27,r9
 4222 09a2 00F0      		brlo .L189
 990:main.c        **** 	    vol ++; // Higher means lower 
 4224               	.LM552:
 4225 09a4 9394      		inc r9
 4226 09a6 00C0      		rjmp .L189
 4227               	.L186:
 991:main.c        **** 	  sprintf(buffer,"Vol %d    ", 31-vol);
 992:main.c        **** 	  lcd_goto(0x40);
 993:main.c        **** 	  lcd_puts(buffer);
 994:main.c        **** 	}
 995:main.c        **** 	else if (vol_flag == 0x02) {
 4229               	.LM553:
 4230 09a8 8091 0000 		lds r24,vol_flag
 4231 09ac 8230      		cpi r24,lo8(2)
 4232 09ae 01F4      		brne .L188
 996:main.c        **** 	  if(vol>0)
 4234               	.LM554:
 4235 09b0 9110      		cpse r9,__zero_reg__
 997:main.c        **** 	    vol --;
 4237               	.LM555:
 4238 09b2 9A94      		dec r9
 4239               	.L189:
 998:main.c        **** 	  sprintf(buffer,"Vol %d    ", 31-vol);
 4241               	.LM556:
 4242 09b4 8FE1      		ldi r24,lo8(31)
 4243 09b6 90E0      		ldi r25,0
 4244 09b8 8919      		sub r24,r9
 4245 09ba 9109      		sbc r25,__zero_reg__
 4246 09bc 9F93      		push r25
 4247 09be 8F93      		push r24
 4248 09c0 80E0      		ldi r24,lo8(.LC16)
 4249 09c2 90E0      		ldi r25,hi8(.LC16)
 4250 09c4 9F93      		push r25
 4251 09c6 8F93      		push r24
 4252 09c8 DF92      		push r13
 4253 09ca CF92      		push r12
 4254 09cc 0E94 0000 		call sprintf
 999:main.c        **** 	  lcd_goto(0x40);
 4256               	.LM557:
 4257 09d0 80E4      		ldi r24,lo8(64)
 4258 09d2 0E94 0000 		call lcd_goto
1000:main.c        **** 	  lcd_puts(buffer);
 4260               	.LM558:
 4261 09d6 C601      		movw r24,r12
 4262 09d8 0E94 0000 		call lcd_puts
 4263 09dc 0F90      		pop __tmp_reg__
 4264 09de 0F90      		pop __tmp_reg__
 4265 09e0 0F90      		pop __tmp_reg__
 4266 09e2 0F90      		pop __tmp_reg__
 4267 09e4 0F90      		pop __tmp_reg__
 4268 09e6 0F90      		pop __tmp_reg__
 4269               	.L188:
1001:main.c        **** 	}
1002:main.c        **** 
1003:main.c        **** 	err = updateVolume(vol);
 4271               	.LM559:
 4272 09e8 892D      		mov r24,r9
 4273 09ea 0E94 0000 		call updateVolume
1004:main.c        **** 
1005:main.c        **** 	if (err) {
 4275               	.LM560:
 4276 09ee 8823      		tst r24
 4277 09f0 01F0      		breq .L190
1006:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 4279               	.LM561:
 4280 09f2 1F92      		push __zero_reg__
 4281 09f4 8F93      		push r24
 4282 09f6 80E0      		ldi r24,lo8(.LC2)
 4283 09f8 90E0      		ldi r25,hi8(.LC2)
 4284 09fa 9F93      		push r25
 4285 09fc 8F93      		push r24
 4286 09fe DF92      		push r13
 4287 0a00 CF92      		push r12
 4288 0a02 0E94 0000 		call sprintf
1007:main.c        **** 	  lcd_goto(0x40);
 4290               	.LM562:
 4291 0a06 80E4      		ldi r24,lo8(64)
 4292 0a08 0E94 0000 		call lcd_goto
1008:main.c        **** 	  lcd_puts(buffer);	
 4294               	.LM563:
 4295 0a0c C601      		movw r24,r12
 4296 0a0e 0E94 0000 		call lcd_puts
 4297 0a12 0F90      		pop __tmp_reg__
 4298 0a14 0F90      		pop __tmp_reg__
 4299 0a16 0F90      		pop __tmp_reg__
 4300 0a18 0F90      		pop __tmp_reg__
 4301 0a1a 0F90      		pop __tmp_reg__
 4302 0a1c 0F90      		pop __tmp_reg__
 4303               	.L190:
1009:main.c        **** 	}      
1010:main.c        **** 	vol_timer = 0;
 4305               	.LM564:
 4306 0a1e 1092 0000 		sts vol_timer,__zero_reg__
 4307               	.L185:
1011:main.c        ****       }
1012:main.c        ****       vol_flag = 0x00;
 4309               	.LM565:
 4310 0a22 1092 0000 		sts vol_flag,__zero_reg__
 4311 0a26 00C0      		rjmp .L118
 4324               	.Lscope28:
 4325               		.section	.progmem.data,"a",@progbits
 4328               	string_intro_row2.2440:
 4329 0000 5374 6172 		.string	"Starting radio"
 4329      7469 6E67 
 4329      2072 6164 
 4329      696F 00
 4332               	string_intro_row1.2439:
 4333 000f 2A2A 2A20 		.string	"*** SM6VFZ"
 4333      534D 3656 
 4333      465A 00
 4334               		.local	ftw_botbot.2394
 4335               		.comm	ftw_botbot.2394,4,1
 4336               		.local	ftw_bottop.2393
 4337               		.comm	ftw_bottop.2393,4,1
 4338               		.local	ftw_topbot.2392
 4339               		.comm	ftw_topbot.2392,4,1
 4340               		.local	ftw_toptop.2391
 4341               		.comm	ftw_toptop.2391,4,1
 4342               		.comm	rffe_rx_att,1,1
 4343               		.comm	rx_att,1,1
 4344               	.global	pll_n
 4345               		.section .bss
 4348               	pll_n:
 4349 0000 0000      		.zero	2
 4350               		.comm	tx,2,1
 4351               		.comm	bandf,2,1
 4352               	.global	vol_timer
 4353               		.data
 4356               	vol_timer:
 4357 0000 FF        		.byte	-1
 4358               	.global	band_timer
 4361               	band_timer:
 4362 0001 FF        		.byte	-1
 4363               		.comm	tx_att,1,1
 4364               		.comm	band,1,1
 4365               		.comm	mode,1,1
 4366               		.comm	step_timer,2,1
 4367               		.comm	vol_flag,1,1
 4368               		.comm	timer_flag,1,1
 4369               		.comm	band_flag,1,1
 4370               		.comm	mode_flag,1,1
 4371               		.comm	rot_flag,1,1
 4388               		.text
 4390               	.Letext0:
 4391               		.ident	"GCC: (GNU) 4.9.2"
 4392               	.global __do_copy_data
 4393               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccQjTuat.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccQjTuat.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccQjTuat.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccQjTuat.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccQjTuat.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccQjTuat.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccQjTuat.s:125    .text:0000000000000000 __vector_15
                            *COM*:0000000000000002 step_timer
     /tmp/ccQjTuat.s:172    .text:0000000000000040 __vector_12
                            *COM*:0000000000000001 timer_flag
     /tmp/ccQjTuat.s:204    .text:000000000000005e __vector_5
                            *COM*:0000000000000001 rot_flag
     /tmp/ccQjTuat.s:295    .text:00000000000000a4 __vector_6
     /tmp/ccQjTuat.s:386    .text:00000000000000ea __vector_7
                            *COM*:0000000000000001 vol_flag
     /tmp/ccQjTuat.s:477    .text:0000000000000130 __vector_8
     /tmp/ccQjTuat.s:568    .text:0000000000000176 TWIinit
     /tmp/ccQjTuat.s:590    .text:0000000000000184 TWIStart
     /tmp/ccQjTuat.s:617    .text:0000000000000194 TWIStop
     /tmp/ccQjTuat.s:636    .text:000000000000019c TWIWrite
     /tmp/ccQjTuat.s:666    .text:00000000000001b0 TWIReadACK
     /tmp/ccQjTuat.s:695    .text:00000000000001c4 TWIReadNACK
     /tmp/ccQjTuat.s:724    .text:00000000000001d8 TWIGetStatus
     /tmp/ccQjTuat.s:746    .text:00000000000001e0 TWI_write_byte
     /tmp/ccQjTuat.s:876    .text:0000000000000250 TWI_read_byte
     /tmp/ccQjTuat.s:986    .text:00000000000002b4 TWI_write_word
     /tmp/ccQjTuat.s:1154   .text:0000000000000344 TWI_write_3bytes
     /tmp/ccQjTuat.s:1339   .text:00000000000003ea TWI_write_4bytes
     /tmp/ccQjTuat.s:1543   .text:00000000000004a4 TWI_write_5bytes
     /tmp/ccQjTuat.s:1764   .text:0000000000000572 updateVolume
     /tmp/ccQjTuat.s:1794   .text:000000000000058c readClar
     /tmp/ccQjTuat.s:1814   .text:0000000000000592 updateRFFE
                            *COM*:0000000000000001 rx_att
     /tmp/ccQjTuat.s:4348   .bss:0000000000000000 pll_n
                            *COM*:0000000000000002 tx
                            *COM*:0000000000000002 bandf
     /tmp/ccQjTuat.s:1898   .text:00000000000005f4 updateFreq
                            *COM*:0000000000000001 mode
     /tmp/ccQjTuat.s:4339   .bss:000000000000000e ftw_toptop.2391
     /tmp/ccQjTuat.s:4337   .bss:000000000000000a ftw_topbot.2392
     /tmp/ccQjTuat.s:4335   .bss:0000000000000006 ftw_bottop.2393
                             .bss:0000000000000002 ftw_botbot.2394
     /tmp/ccQjTuat.s:2237   .text:0000000000000854 updateSettings
                            *COM*:0000000000000001 tx_att
     /tmp/ccQjTuat.s:2396   .text:0000000000000936 adcInit
     /tmp/ccQjTuat.s:2421   .text:0000000000000942 Timer0Init
     /tmp/ccQjTuat.s:2448   .text:0000000000000952 Timer1Init
     /tmp/ccQjTuat.s:2520   .text.startup:0000000000000000 main
     /tmp/ccQjTuat.s:4332   .progmem.data:000000000000000f string_intro_row1.2439
     /tmp/ccQjTuat.s:4328   .progmem.data:0000000000000000 string_intro_row2.2440
                            *COM*:0000000000000001 mode_flag
                            *COM*:0000000000000001 band_flag
                            *COM*:0000000000000001 band
                            *COM*:0000000000000001 rffe_rx_att
     /tmp/ccQjTuat.s:4356   .data:0000000000000000 vol_timer
     /tmp/ccQjTuat.s:4361   .data:0000000000000001 band_timer

UNDEFINED SYMBOLS
__addsf3
__subsf3
__divsf3
__mulsf3
__floatunsisf
__fixunssfsi
lround
floor
fmod
__nesf2
__floatsisf
__fixsfsi
__ltsf2
lcd_init
lcd_clrscr
strcpy_P
lcd_puts
lcd_goto
sprintf
strcpy
__do_copy_data
__do_clear_bss
