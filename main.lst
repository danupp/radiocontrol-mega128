   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 123               	.global	__vector_15
 125               	__vector_15:
   1:main.c        **** #define F_CPU 1000000UL
   2:main.c        **** 
   3:main.c        **** #include <avr/io.h>
   4:main.c        **** #include <avr/wdt.h>
   5:main.c        **** #include <avr/sleep.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #include <util/delay.h>
   8:main.c        **** #include <math.h>
   9:main.c        **** #include <string.h>
  10:main.c        **** #include <stdio.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <stdbool.h>
  14:main.c        **** #include <avr/pgmspace.h>
  15:main.c        **** #include "hd44780.h"
  16:main.c        **** #include "build_settings.h"
  17:main.c        **** 
  18:main.c        **** #define fpga_addr 0x23
  19:main.c        **** #define pll_addr 0x22
  20:main.c        **** 
  21:main.c        **** #define ROT1_A PE4
  22:main.c        **** #define ROT1_B PE5
  23:main.c        **** #define ROT2_A PD2
  24:main.c        **** #define ROT2_B PD3
  25:main.c        **** #define ROT_BUTTON PE3
  26:main.c        **** #define SQUELCH_BUTTON PF4
  27:main.c        **** #define MENU_BUTTON PF2
  28:main.c        **** #define MODE_BUTTON PF1
  29:main.c        **** #define BAND_BUTTON PF0
  30:main.c        **** #define VOLROT_A PE6
  31:main.c        **** #define VOLROT_B PE7
  32:main.c        **** #define VOL_BUTTON PF4
  33:main.c        **** #define FREQ_BUTTON PE3
  34:main.c        **** #define CLAR_POT PF3
  35:main.c        **** #define MUTE PE0
  36:main.c        **** 
  37:main.c        **** #define LED_RED PD6
  38:main.c        **** #define LED_GREEN PD5
  39:main.c        **** 
  40:main.c        **** #define LSB 0x01
  41:main.c        **** #define LSBN 0x02
  42:main.c        **** #define USB 0x03
  43:main.c        **** #define USBN 0x04
  44:main.c        **** #define CW 0x05
  45:main.c        **** #define CWN 0x06
  46:main.c        **** #define CWNN 0x07
  47:main.c        **** #define AM 0x08
  48:main.c        **** #define AMN 0x09
  49:main.c        **** #define FM 0x0A
  50:main.c        **** 
  51:main.c        **** 
  52:main.c        **** volatile uint8_t rot_flag, mode_flag, band_flag, timer_flag, vol_flag;
  53:main.c        **** volatile uint16_t step_timer;
  54:main.c        **** volatile uint8_t mode;
  55:main.c        **** volatile uint8_t band;
  56:main.c        **** volatile uint8_t tx_att;
  57:main.c        **** volatile uint8_t band_timer = 255, vol_timer = 255;
  58:main.c        **** volatile uint16_t bandf, tx, pll_n = 0;
  59:main.c        **** volatile uint8_t rx_att;
  60:main.c        **** volatile bool rffe_rx_att;
  61:main.c        **** volatile double freq;
  62:main.c        **** volatile int8_t clar = 0;
  63:main.c        **** volatile int freq_offset = 0; // offset in MHz for display
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** ISR(TIMER0_COMP_vect) {
 127               	.LM0:
 128               	.LFBB1:
 129 0000 1F92      		push r1
 130 0002 0F92      		push r0
 131 0004 0FB6      		in r0,__SREG__
 132 0006 0F92      		push r0
 133 0008 1124      		clr __zero_reg__
 134 000a 2F93      		push r18
 135 000c 8F93      		push r24
 136 000e 9F93      		push r25
 137               	/* prologue: Signal */
 138               	/* frame size = 0 */
 139               	/* stack size = 6 */
 140               	.L__stack_usage = 6
  67:main.c        ****   if (step_timer < 500)
 142               	.LM1:
 143 0010 8091 0000 		lds r24,step_timer
 144 0014 9091 0000 		lds r25,step_timer+1
 145 0018 843F      		cpi r24,-12
 146 001a 9140      		sbci r25,1
 147 001c 00F4      		brsh .L1
  68:main.c        ****     step_timer ++;
 149               	.LM2:
 150 001e 8091 0000 		lds r24,step_timer
 151 0022 9091 0000 		lds r25,step_timer+1
 152 0026 0196      		adiw r24,1
 153 0028 9093 0000 		sts step_timer+1,r25
 154 002c 8093 0000 		sts step_timer,r24
 155               	.L1:
 156               	/* epilogue start */
  69:main.c        **** }
 158               	.LM3:
 159 0030 9F91      		pop r25
 160 0032 8F91      		pop r24
 161 0034 2F91      		pop r18
 162 0036 0F90      		pop r0
 163 0038 0FBE      		out __SREG__,r0
 164 003a 0F90      		pop r0
 165 003c 1F90      		pop r1
 166 003e 1895      		reti
 168               	.Lscope1:
 170               	.global	__vector_12
 172               	__vector_12:
  70:main.c        **** 
  71:main.c        **** ISR(TIMER1_COMPA_vect) {
 174               	.LM4:
 175               	.LFBB2:
 176 0040 1F92      		push r1
 177 0042 0F92      		push r0
 178 0044 0FB6      		in r0,__SREG__
 179 0046 0F92      		push r0
 180 0048 1124      		clr __zero_reg__
 181 004a 8F93      		push r24
 182               	/* prologue: Signal */
 183               	/* frame size = 0 */
 184               	/* stack size = 4 */
 185               	.L__stack_usage = 4
  72:main.c        ****   timer_flag = 1;
 187               	.LM5:
 188 004c 81E0      		ldi r24,lo8(1)
 189 004e 8093 0000 		sts timer_flag,r24
 190               	/* epilogue start */
  73:main.c        ****   
  74:main.c        **** }
 192               	.LM6:
 193 0052 8F91      		pop r24
 194 0054 0F90      		pop r0
 195 0056 0FBE      		out __SREG__,r0
 196 0058 0F90      		pop r0
 197 005a 1F90      		pop r1
 198 005c 1895      		reti
 200               	.Lscope2:
 202               	.global	__vector_3
 204               	__vector_3:
  75:main.c        **** 
  76:main.c        **** 
  77:main.c        **** ISR(INT2_vect) {  // falling level on INT2
 206               	.LM7:
 207               	.LFBB3:
 208 005e 1F92      		push r1
 209 0060 0F92      		push r0
 210 0062 0FB6      		in r0,__SREG__
 211 0064 0F92      		push r0
 212 0066 1124      		clr __zero_reg__
 213 0068 8F93      		push r24
 214               	/* prologue: Signal */
 215               	/* frame size = 0 */
 216               	/* stack size = 4 */
 217               	.L__stack_usage = 4
  78:main.c        ****   if(!(PIND & (1 << ROT2_A))) {
 219               	.LM8:
 220 006a 8299      		sbic 0x10,2
 221 006c 00C0      		rjmp .L5
 222               	.LBB231:
 223               	.LBB232:
 225               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 227               	.LM9:
 228 006e 86E0      		ldi r24,lo8(6)
 229 0070 8A95      	1:	dec r24
 230 0072 01F4      		brne 1b
 231 0074 00C0      		rjmp .
 232               	.LBE232:
 233               	.LBE231:
 235               	.Ltext2:
  79:main.c        ****     _delay_us(20);
  80:main.c        ****     if ((PIND & (1 << ROT2_B))) {
 237               	.LM10:
 238 0076 839B      		sbis 0x10,3
 239 0078 00C0      		rjmp .L5
 240               	.LBB233:
 241               	.LBB234:
 243               	.Ltext3:
 245               	.LM11:
 246 007a 86E0      		ldi r24,lo8(6)
 247 007c 8A95      	1:	dec r24
 248 007e 01F4      		brne 1b
 249 0080 00C0      		rjmp .
 250               	.LBE234:
 251               	.LBE233:
 253               	.Ltext4:
  81:main.c        ****       _delay_us(20);
  82:main.c        ****       if (!(PIND & (1 << ROT2_A)) && (PIND & (1 << ROT2_B))) {
 255               	.LM12:
 256 0082 8299      		sbic 0x10,2
 257 0084 00C0      		rjmp .L5
 259               	.LM13:
 260 0086 839B      		sbis 0x10,3
 261 0088 00C0      		rjmp .L5
 262               	.LBB235:
 263               	.LBB236:
 265               	.Ltext5:
 267               	.LM14:
 268 008a 81E2      		ldi r24,lo8(33)
 269 008c 8A95      	1:	dec r24
 270 008e 01F4      		brne 1b
 271 0090 0000      		nop
 272               	.LBE236:
 273               	.LBE235:
 275               	.Ltext6:
  83:main.c        **** 	_delay_us(100);
  84:main.c        **** 	rot_flag = 0x01;
 277               	.LM15:
 278 0092 81E0      		ldi r24,lo8(1)
 279 0094 8093 0000 		sts rot_flag,r24
 280               	.L5:
 281               	/* epilogue start */
  85:main.c        ****       }
  86:main.c        ****     }
  87:main.c        ****   }
  88:main.c        **** }
 283               	.LM16:
 284 0098 8F91      		pop r24
 285 009a 0F90      		pop r0
 286 009c 0FBE      		out __SREG__,r0
 287 009e 0F90      		pop r0
 288 00a0 1F90      		pop r1
 289 00a2 1895      		reti
 291               	.Lscope3:
 293               	.global	__vector_4
 295               	__vector_4:
  89:main.c        **** 
  90:main.c        **** ISR(INT3_vect) {  // falling level on INT3
 297               	.LM17:
 298               	.LFBB4:
 299 00a4 1F92      		push r1
 300 00a6 0F92      		push r0
 301 00a8 0FB6      		in r0,__SREG__
 302 00aa 0F92      		push r0
 303 00ac 1124      		clr __zero_reg__
 304 00ae 8F93      		push r24
 305               	/* prologue: Signal */
 306               	/* frame size = 0 */
 307               	/* stack size = 4 */
 308               	.L__stack_usage = 4
  91:main.c        ****   if (!(PIND & (1 << ROT2_B))) {
 310               	.LM18:
 311 00b0 8399      		sbic 0x10,3
 312 00b2 00C0      		rjmp .L15
 313               	.LBB237:
 314               	.LBB238:
 316               	.Ltext7:
 318               	.LM19:
 319 00b4 86E0      		ldi r24,lo8(6)
 320 00b6 8A95      	1:	dec r24
 321 00b8 01F4      		brne 1b
 322 00ba 00C0      		rjmp .
 323               	.LBE238:
 324               	.LBE237:
 326               	.Ltext8:
  92:main.c        ****    _delay_us(20);
  93:main.c        ****     if ((PIND & (1 << ROT2_A))) {
 328               	.LM20:
 329 00bc 829B      		sbis 0x10,2
 330 00be 00C0      		rjmp .L15
 331               	.LBB239:
 332               	.LBB240:
 334               	.Ltext9:
 336               	.LM21:
 337 00c0 86E0      		ldi r24,lo8(6)
 338 00c2 8A95      	1:	dec r24
 339 00c4 01F4      		brne 1b
 340 00c6 00C0      		rjmp .
 341               	.LBE240:
 342               	.LBE239:
 344               	.Ltext10:
  94:main.c        ****       _delay_us(20);
  95:main.c        ****       if ((PIND & (1 << ROT2_A)) && !(PIND & (1 << ROT2_B))) {
 346               	.LM22:
 347 00c8 829B      		sbis 0x10,2
 348 00ca 00C0      		rjmp .L15
 350               	.LM23:
 351 00cc 8399      		sbic 0x10,3
 352 00ce 00C0      		rjmp .L15
 353               	.LBB241:
 354               	.LBB242:
 356               	.Ltext11:
 358               	.LM24:
 359 00d0 81E2      		ldi r24,lo8(33)
 360 00d2 8A95      	1:	dec r24
 361 00d4 01F4      		brne 1b
 362 00d6 0000      		nop
 363               	.LBE242:
 364               	.LBE241:
 366               	.Ltext12:
  96:main.c        **** 	_delay_us(100);
  97:main.c        **** 	rot_flag = 0x02;
 368               	.LM25:
 369 00d8 82E0      		ldi r24,lo8(2)
 370 00da 8093 0000 		sts rot_flag,r24
 371               	.L15:
 372               	/* epilogue start */
  98:main.c        ****       }
  99:main.c        ****     }
 100:main.c        ****   }
 101:main.c        **** }
 374               	.LM26:
 375 00de 8F91      		pop r24
 376 00e0 0F90      		pop r0
 377 00e2 0FBE      		out __SREG__,r0
 378 00e4 0F90      		pop r0
 379 00e6 1F90      		pop r1
 380 00e8 1895      		reti
 382               	.Lscope4:
 384               	.global	__vector_5
 386               	__vector_5:
 102:main.c        **** 
 103:main.c        **** ISR(INT4_vect) {  // falling level on INT4
 388               	.LM27:
 389               	.LFBB5:
 390 00ea 1F92      		push r1
 391 00ec 0F92      		push r0
 392 00ee 0FB6      		in r0,__SREG__
 393 00f0 0F92      		push r0
 394 00f2 1124      		clr __zero_reg__
 395 00f4 8F93      		push r24
 396 00f6 9F93      		push r25
 397               	/* prologue: Signal */
 398               	/* frame size = 0 */
 399               	/* stack size = 5 */
 400               	.L__stack_usage = 5
 104:main.c        ****   if(!(PINE & (1 << ROT1_A))) {
 402               	.LM28:
 403 00f8 0C99      		sbic 0x1,4
 404 00fa 00C0      		rjmp .L25
 405               	.LBB243:
 406               	.LBB244:
 408               	.Ltext13:
 410               	.LM29:
 411 00fc 83EF      		ldi r24,lo8(499)
 412 00fe 91E0      		ldi r25,hi8(499)
 413 0100 0197      	1:	sbiw r24,1
 414 0102 01F4      		brne 1b
 415 0104 00C0      		rjmp .
 416 0106 0000      		nop
 417               	.LBE244:
 418               	.LBE243:
 420               	.Ltext14:
 105:main.c        ****     _delay_us(2000);
 106:main.c        ****     if ((PINE & (1 << ROT1_B))) {
 422               	.LM30:
 423 0108 0D9B      		sbis 0x1,5
 424 010a 00C0      		rjmp .L25
 425               	.LBB245:
 426               	.LBB246:
 428               	.Ltext15:
 430               	.LM31:
 431 010c 83EF      		ldi r24,lo8(499)
 432 010e 91E0      		ldi r25,hi8(499)
 433 0110 0197      	1:	sbiw r24,1
 434 0112 01F4      		brne 1b
 435 0114 00C0      		rjmp .
 436 0116 0000      		nop
 437               	.LBE246:
 438               	.LBE245:
 440               	.Ltext16:
 107:main.c        ****       _delay_us(2000);
 108:main.c        ****       if (!(PINE & (1 << ROT1_A)) && (PINE & (1 << ROT1_B))) {
 442               	.LM32:
 443 0118 0C99      		sbic 0x1,4
 444 011a 00C0      		rjmp .L25
 446               	.LM33:
 447 011c 0D9B      		sbis 0x1,5
 448 011e 00C0      		rjmp .L25
 449               	.LBB247:
 450               	.LBB248:
 452               	.Ltext17:
 454               	.LM34:
 455 0120 91E2      		ldi r25,lo8(33)
 456 0122 9A95      	1:	dec r25
 457 0124 01F4      		brne 1b
 458 0126 0000      		nop
 459               	.LBE248:
 460               	.LBE247:
 462               	.Ltext18:
 109:main.c        **** 	_delay_us(100);
 110:main.c        **** 	rot_flag = 0x01;
 464               	.LM35:
 465 0128 81E0      		ldi r24,lo8(1)
 466 012a 8093 0000 		sts rot_flag,r24
 467               	.L25:
 468               	/* epilogue start */
 111:main.c        ****       }
 112:main.c        ****     }
 113:main.c        ****   }
 114:main.c        **** }
 470               	.LM36:
 471 012e 9F91      		pop r25
 472 0130 8F91      		pop r24
 473 0132 0F90      		pop r0
 474 0134 0FBE      		out __SREG__,r0
 475 0136 0F90      		pop r0
 476 0138 1F90      		pop r1
 477 013a 1895      		reti
 479               	.Lscope5:
 481               	.global	__vector_6
 483               	__vector_6:
 115:main.c        **** 
 116:main.c        **** ISR(INT5_vect) {  // falling level on INT5
 485               	.LM37:
 486               	.LFBB6:
 487 013c 1F92      		push r1
 488 013e 0F92      		push r0
 489 0140 0FB6      		in r0,__SREG__
 490 0142 0F92      		push r0
 491 0144 1124      		clr __zero_reg__
 492 0146 8F93      		push r24
 493 0148 9F93      		push r25
 494               	/* prologue: Signal */
 495               	/* frame size = 0 */
 496               	/* stack size = 5 */
 497               	.L__stack_usage = 5
 117:main.c        ****   if (!(PINE & (1 << ROT1_B))) {
 499               	.LM38:
 500 014a 0D99      		sbic 0x1,5
 501 014c 00C0      		rjmp .L35
 502               	.LBB249:
 503               	.LBB250:
 505               	.Ltext19:
 507               	.LM39:
 508 014e 83EF      		ldi r24,lo8(499)
 509 0150 91E0      		ldi r25,hi8(499)
 510 0152 0197      	1:	sbiw r24,1
 511 0154 01F4      		brne 1b
 512 0156 00C0      		rjmp .
 513 0158 0000      		nop
 514               	.LBE250:
 515               	.LBE249:
 517               	.Ltext20:
 118:main.c        ****    _delay_us(2000);
 119:main.c        ****     if ((PINE & (1 << ROT1_A))) {
 519               	.LM40:
 520 015a 0C9B      		sbis 0x1,4
 521 015c 00C0      		rjmp .L35
 522               	.LBB251:
 523               	.LBB252:
 525               	.Ltext21:
 527               	.LM41:
 528 015e 83EF      		ldi r24,lo8(499)
 529 0160 91E0      		ldi r25,hi8(499)
 530 0162 0197      	1:	sbiw r24,1
 531 0164 01F4      		brne 1b
 532 0166 00C0      		rjmp .
 533 0168 0000      		nop
 534               	.LBE252:
 535               	.LBE251:
 537               	.Ltext22:
 120:main.c        ****       _delay_us(2000);
 121:main.c        ****       if ((PINE & (1 << ROT1_A)) && !(PINE & (1 << ROT1_B))) {
 539               	.LM42:
 540 016a 0C9B      		sbis 0x1,4
 541 016c 00C0      		rjmp .L35
 543               	.LM43:
 544 016e 0D99      		sbic 0x1,5
 545 0170 00C0      		rjmp .L35
 546               	.LBB253:
 547               	.LBB254:
 549               	.Ltext23:
 551               	.LM44:
 552 0172 91E2      		ldi r25,lo8(33)
 553 0174 9A95      	1:	dec r25
 554 0176 01F4      		brne 1b
 555 0178 0000      		nop
 556               	.LBE254:
 557               	.LBE253:
 559               	.Ltext24:
 122:main.c        **** 	_delay_us(100);
 123:main.c        **** 	rot_flag = 0x02;
 561               	.LM45:
 562 017a 82E0      		ldi r24,lo8(2)
 563 017c 8093 0000 		sts rot_flag,r24
 564               	.L35:
 565               	/* epilogue start */
 124:main.c        ****       }
 125:main.c        ****     }
 126:main.c        ****   }
 127:main.c        **** }
 567               	.LM46:
 568 0180 9F91      		pop r25
 569 0182 8F91      		pop r24
 570 0184 0F90      		pop r0
 571 0186 0FBE      		out __SREG__,r0
 572 0188 0F90      		pop r0
 573 018a 1F90      		pop r1
 574 018c 1895      		reti
 576               	.Lscope6:
 578               	.global	__vector_7
 580               	__vector_7:
 128:main.c        **** 
 129:main.c        **** ISR(INT6_vect) {  // falling level on INT6
 582               	.LM47:
 583               	.LFBB7:
 584 018e 1F92      		push r1
 585 0190 0F92      		push r0
 586 0192 0FB6      		in r0,__SREG__
 587 0194 0F92      		push r0
 588 0196 1124      		clr __zero_reg__
 589 0198 8F93      		push r24
 590 019a 9F93      		push r25
 591               	/* prologue: Signal */
 592               	/* frame size = 0 */
 593               	/* stack size = 5 */
 594               	.L__stack_usage = 5
 130:main.c        ****   if(!(PINE & (1 << VOLROT_A))) {
 596               	.LM48:
 597 019c 0E99      		sbic 0x1,6
 598 019e 00C0      		rjmp .L45
 599               	.LBB255:
 600               	.LBB256:
 602               	.Ltext25:
 604               	.LM49:
 605 01a0 83EF      		ldi r24,lo8(499)
 606 01a2 91E0      		ldi r25,hi8(499)
 607 01a4 0197      	1:	sbiw r24,1
 608 01a6 01F4      		brne 1b
 609 01a8 00C0      		rjmp .
 610 01aa 0000      		nop
 611               	.LBE256:
 612               	.LBE255:
 614               	.Ltext26:
 131:main.c        ****     _delay_us(2000);
 132:main.c        ****     if ((PINE & (1 << VOLROT_B))) {
 616               	.LM50:
 617 01ac 0F9B      		sbis 0x1,7
 618 01ae 00C0      		rjmp .L45
 619               	.LBB257:
 620               	.LBB258:
 622               	.Ltext27:
 624               	.LM51:
 625 01b0 83EF      		ldi r24,lo8(499)
 626 01b2 91E0      		ldi r25,hi8(499)
 627 01b4 0197      	1:	sbiw r24,1
 628 01b6 01F4      		brne 1b
 629 01b8 00C0      		rjmp .
 630 01ba 0000      		nop
 631               	.LBE258:
 632               	.LBE257:
 634               	.Ltext28:
 133:main.c        ****       _delay_us(2000);
 134:main.c        ****       if (!(PINE & (1 << VOLROT_A)) && (PINE & (1 << VOLROT_B))) {
 636               	.LM52:
 637 01bc 0E99      		sbic 0x1,6
 638 01be 00C0      		rjmp .L45
 640               	.LM53:
 641 01c0 0F9B      		sbis 0x1,7
 642 01c2 00C0      		rjmp .L45
 643               	.LBB259:
 644               	.LBB260:
 646               	.Ltext29:
 648               	.LM54:
 649 01c4 91E2      		ldi r25,lo8(33)
 650 01c6 9A95      	1:	dec r25
 651 01c8 01F4      		brne 1b
 652 01ca 0000      		nop
 653               	.LBE260:
 654               	.LBE259:
 656               	.Ltext30:
 135:main.c        **** 	_delay_us(100);
 136:main.c        **** 	vol_flag = 0x02;
 658               	.LM55:
 659 01cc 82E0      		ldi r24,lo8(2)
 660 01ce 8093 0000 		sts vol_flag,r24
 661               	.L45:
 662               	/* epilogue start */
 137:main.c        ****       }
 138:main.c        ****     }
 139:main.c        ****   }
 140:main.c        **** }
 664               	.LM56:
 665 01d2 9F91      		pop r25
 666 01d4 8F91      		pop r24
 667 01d6 0F90      		pop r0
 668 01d8 0FBE      		out __SREG__,r0
 669 01da 0F90      		pop r0
 670 01dc 1F90      		pop r1
 671 01de 1895      		reti
 673               	.Lscope7:
 675               	.global	__vector_8
 677               	__vector_8:
 141:main.c        **** 
 142:main.c        **** ISR(INT7_vect) {  // falling level on INT7
 679               	.LM57:
 680               	.LFBB8:
 681 01e0 1F92      		push r1
 682 01e2 0F92      		push r0
 683 01e4 0FB6      		in r0,__SREG__
 684 01e6 0F92      		push r0
 685 01e8 1124      		clr __zero_reg__
 686 01ea 8F93      		push r24
 687 01ec 9F93      		push r25
 688               	/* prologue: Signal */
 689               	/* frame size = 0 */
 690               	/* stack size = 5 */
 691               	.L__stack_usage = 5
 143:main.c        ****   if (!(PINE & (1 << VOLROT_B))) {
 693               	.LM58:
 694 01ee 0F99      		sbic 0x1,7
 695 01f0 00C0      		rjmp .L49
 696               	.LBB261:
 697               	.LBB262:
 699               	.Ltext31:
 701               	.LM59:
 702 01f2 83EF      		ldi r24,lo8(499)
 703 01f4 91E0      		ldi r25,hi8(499)
 704 01f6 0197      	1:	sbiw r24,1
 705 01f8 01F4      		brne 1b
 706 01fa 00C0      		rjmp .
 707 01fc 0000      		nop
 708               	.LBE262:
 709               	.LBE261:
 711               	.Ltext32:
 144:main.c        ****     _delay_us(2000);
 145:main.c        ****     if ((PINE & (1 << VOLROT_A))) {
 713               	.LM60:
 714 01fe 0E9B      		sbis 0x1,6
 715 0200 00C0      		rjmp .L49
 716               	.LBB263:
 717               	.LBB264:
 719               	.Ltext33:
 721               	.LM61:
 722 0202 83EF      		ldi r24,lo8(499)
 723 0204 91E0      		ldi r25,hi8(499)
 724 0206 0197      	1:	sbiw r24,1
 725 0208 01F4      		brne 1b
 726 020a 00C0      		rjmp .
 727 020c 0000      		nop
 728               	.LBE264:
 729               	.LBE263:
 731               	.Ltext34:
 146:main.c        ****       _delay_us(2000);
 147:main.c        ****       if ((PINE & (1 << VOLROT_A)) && !(PINE & (1 << VOLROT_B))) {
 733               	.LM62:
 734 020e 0E9B      		sbis 0x1,6
 735 0210 00C0      		rjmp .L49
 737               	.LM63:
 738 0212 0F99      		sbic 0x1,7
 739 0214 00C0      		rjmp .L49
 740               	.LBB265:
 741               	.LBB266:
 743               	.Ltext35:
 745               	.LM64:
 746 0216 91E2      		ldi r25,lo8(33)
 747 0218 9A95      	1:	dec r25
 748 021a 01F4      		brne 1b
 749 021c 0000      		nop
 750               	.LBE266:
 751               	.LBE265:
 753               	.Ltext36:
 148:main.c        **** 	_delay_us(100);
 149:main.c        **** 	vol_flag = 0x01;
 755               	.LM65:
 756 021e 81E0      		ldi r24,lo8(1)
 757 0220 8093 0000 		sts vol_flag,r24
 758               	.L49:
 759               	/* epilogue start */
 150:main.c        ****       }
 151:main.c        ****     }
 152:main.c        ****   }
 153:main.c        **** }
 761               	.LM66:
 762 0224 9F91      		pop r25
 763 0226 8F91      		pop r24
 764 0228 0F90      		pop r0
 765 022a 0FBE      		out __SREG__,r0
 766 022c 0F90      		pop r0
 767 022e 1F90      		pop r1
 768 0230 1895      		reti
 770               	.Lscope8:
 772               	.global	TWIinit
 774               	TWIinit:
 154:main.c        **** 
 155:main.c        **** void TWIinit(void) {
 776               	.LM67:
 777               	.LFBB9:
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 0 */
 781               	.L__stack_usage = 0
 156:main.c        ****   TWBR = 0x45;
 783               	.LM68:
 784 0232 85E4      		ldi r24,lo8(69)
 785 0234 8093 7000 		sts 112,r24
 157:main.c        ****   TWCR = (1 << TWEN);
 787               	.LM69:
 788 0238 84E0      		ldi r24,lo8(4)
 789 023a 8093 7400 		sts 116,r24
 790 023e 0895      		ret
 792               	.Lscope9:
 794               	.global	TWIStart
 796               	TWIStart:
 158:main.c        **** }
 159:main.c        **** 
 160:main.c        **** void TWIStart(void) {
 798               	.LM70:
 799               	.LFBB10:
 800               	/* prologue: function */
 801               	/* frame size = 0 */
 802               	/* stack size = 0 */
 803               	.L__stack_usage = 0
 161:main.c        ****   TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 805               	.LM71:
 806 0240 84EA      		ldi r24,lo8(-92)
 807 0242 8093 7400 		sts 116,r24
 808               	.L61:
 162:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 810               	.LM72:
 811 0246 8091 7400 		lds r24,116
 812 024a 87FF      		sbrs r24,7
 813 024c 00C0      		rjmp .L61
 814               	/* epilogue start */
 163:main.c        **** }
 816               	.LM73:
 817 024e 0895      		ret
 819               	.Lscope10:
 821               	.global	TWIStop
 823               	TWIStop:
 164:main.c        **** 
 165:main.c        **** void TWIStop(void) {
 825               	.LM74:
 826               	.LFBB11:
 827               	/* prologue: function */
 828               	/* frame size = 0 */
 829               	/* stack size = 0 */
 830               	.L__stack_usage = 0
 166:main.c        ****   TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
 832               	.LM75:
 833 0250 84E9      		ldi r24,lo8(-108)
 834 0252 8093 7400 		sts 116,r24
 835 0256 0895      		ret
 837               	.Lscope11:
 840               	.global	TWIWrite
 842               	TWIWrite:
 167:main.c        **** }
 168:main.c        **** 
 169:main.c        **** void TWIWrite(uint8_t u8data) {
 844               	.LM76:
 845               	.LFBB12:
 846               	/* prologue: function */
 847               	/* frame size = 0 */
 848               	/* stack size = 0 */
 849               	.L__stack_usage = 0
 170:main.c        ****   TWDR = u8data;
 851               	.LM77:
 852 0258 8093 7300 		sts 115,r24
 171:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN);
 854               	.LM78:
 855 025c 84E8      		ldi r24,lo8(-124)
 856 025e 8093 7400 		sts 116,r24
 857               	.L65:
 172:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 859               	.LM79:
 860 0262 8091 7400 		lds r24,116
 861 0266 87FF      		sbrs r24,7
 862 0268 00C0      		rjmp .L65
 863               	/* epilogue start */
 173:main.c        **** }
 865               	.LM80:
 866 026a 0895      		ret
 868               	.Lscope12:
 870               	.global	TWIReadACK
 872               	TWIReadACK:
 174:main.c        **** 
 175:main.c        **** uint8_t TWIReadACK(void) {
 874               	.LM81:
 875               	.LFBB13:
 876               	/* prologue: function */
 877               	/* frame size = 0 */
 878               	/* stack size = 0 */
 879               	.L__stack_usage = 0
 176:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 881               	.LM82:
 882 026c 84EC      		ldi r24,lo8(-60)
 883 026e 8093 7400 		sts 116,r24
 884               	.L68:
 177:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 886               	.LM83:
 887 0272 8091 7400 		lds r24,116
 888 0276 87FF      		sbrs r24,7
 889 0278 00C0      		rjmp .L68
 178:main.c        ****   return TWDR;
 891               	.LM84:
 892 027a 8091 7300 		lds r24,115
 179:main.c        **** }
 894               	.LM85:
 895 027e 0895      		ret
 897               	.Lscope13:
 899               	.global	TWIReadNACK
 901               	TWIReadNACK:
 180:main.c        **** 
 181:main.c        **** //read byte with NACK
 182:main.c        **** uint8_t TWIReadNACK(void) {
 903               	.LM86:
 904               	.LFBB14:
 905               	/* prologue: function */
 906               	/* frame size = 0 */
 907               	/* stack size = 0 */
 908               	.L__stack_usage = 0
 183:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN);
 910               	.LM87:
 911 0280 84E8      		ldi r24,lo8(-124)
 912 0282 8093 7400 		sts 116,r24
 913               	.L71:
 184:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 915               	.LM88:
 916 0286 8091 7400 		lds r24,116
 917 028a 87FF      		sbrs r24,7
 918 028c 00C0      		rjmp .L71
 185:main.c        ****   return TWDR;
 920               	.LM89:
 921 028e 8091 7300 		lds r24,115
 186:main.c        **** }
 923               	.LM90:
 924 0292 0895      		ret
 926               	.Lscope14:
 928               	.global	TWIGetStatus
 930               	TWIGetStatus:
 187:main.c        **** 
 188:main.c        **** uint8_t TWIGetStatus(void) {
 932               	.LM91:
 933               	.LFBB15:
 934               	/* prologue: function */
 935               	/* frame size = 0 */
 936               	/* stack size = 0 */
 937               	.L__stack_usage = 0
 189:main.c        ****   uint8_t status;
 190:main.c        ****   //mask status
 191:main.c        ****   status = TWSR & 0xF8;
 939               	.LM92:
 940 0294 8091 7100 		lds r24,113
 192:main.c        ****   return status;
 193:main.c        **** }
 942               	.LM93:
 943 0298 887F      		andi r24,lo8(-8)
 944 029a 0895      		ret
 946               	.Lscope15:
 950               	.global	TWI_write_byte
 952               	TWI_write_byte:
 194:main.c        **** 
 195:main.c        **** uint8_t TWI_write_byte(uint8_t addr, uint8_t data) {
 954               	.LM94:
 955               	.LFBB16:
 956 029c 1F93      		push r17
 957 029e CF93      		push r28
 958 02a0 DF93      		push r29
 959 02a2 1F92      		push __zero_reg__
 960 02a4 CDB7      		in r28,__SP_L__
 961 02a6 DEB7      		in r29,__SP_H__
 962               	/* prologue: function */
 963               	/* frame size = 1 */
 964               	/* stack size = 4 */
 965               	.L__stack_usage = 4
 966 02a8 162F      		mov r17,r22
 196:main.c        **** 
 197:main.c        ****   TWIStart();
 968               	.LM95:
 969 02aa 8983      		std Y+1,r24
 970 02ac 0E94 0000 		call TWIStart
 971               	.LBB267:
 972               	.LBB268:
 191:main.c        ****   return status;
 974               	.LM96:
 975 02b0 9091 7100 		lds r25,113
 976 02b4 987F      		andi r25,lo8(-8)
 977               	.LBE268:
 978               	.LBE267:
 198:main.c        ****   if (TWIGetStatus() != 0x08) {
 980               	.LM97:
 981 02b6 8981      		ldd r24,Y+1
 982 02b8 9830      		cpi r25,lo8(8)
 983 02ba 01F0      		breq .L75
 984               	.LBB269:
 985               	.LBB270:
 166:main.c        **** }
 987               	.LM98:
 988 02bc 84E9      		ldi r24,lo8(-108)
 989 02be 8093 7400 		sts 116,r24
 990               	.LBE270:
 991               	.LBE269:
 199:main.c        ****     TWIStop();
 200:main.c        ****     return 0x01;
 993               	.LM99:
 994 02c2 81E0      		ldi r24,lo8(1)
 995 02c4 00C0      		rjmp .L76
 996               	.L75:
 201:main.c        ****   }
 202:main.c        ****   TWIWrite(addr << 1);
 998               	.LM100:
 999 02c6 880F      		lsl r24
 1000 02c8 0E94 0000 		call TWIWrite
 1001               	.LBB271:
 1002               	.LBB272:
 191:main.c        ****   return status;
 1004               	.LM101:
 1005 02cc 9091 7100 		lds r25,113
 1006 02d0 987F      		andi r25,lo8(-8)
 1007               	.LBE272:
 1008               	.LBE271:
 203:main.c        ****   if (TWIGetStatus() != 0x18) {
 1010               	.LM102:
 1011 02d2 9831      		cpi r25,lo8(24)
 1012 02d4 01F0      		breq .L77
 1013               	.LBB273:
 1014               	.LBB274:
 166:main.c        **** }
 1016               	.LM103:
 1017 02d6 84E9      		ldi r24,lo8(-108)
 1018 02d8 8093 7400 		sts 116,r24
 1019               	.LBE274:
 1020               	.LBE273:
 204:main.c        ****     TWIStop();
 205:main.c        ****     return 0x02;
 1022               	.LM104:
 1023 02dc 82E0      		ldi r24,lo8(2)
 1024 02de 00C0      		rjmp .L76
 1025               	.L77:
 206:main.c        ****   }  
 207:main.c        ****   TWIWrite(data);
 1027               	.LM105:
 1028 02e0 812F      		mov r24,r17
 1029 02e2 0E94 0000 		call TWIWrite
 1030               	.LBB275:
 1031               	.LBB276:
 191:main.c        ****   return status;
 1033               	.LM106:
 1034 02e6 8091 7100 		lds r24,113
 1035 02ea 887F      		andi r24,lo8(-8)
 1036               	.LBE276:
 1037               	.LBE275:
 208:main.c        ****   if (TWIGetStatus() != 0x28) {
 1039               	.LM107:
 1040 02ec 8832      		cpi r24,lo8(40)
 1041 02ee 01F0      		breq .L78
 1042               	.LBB277:
 1043               	.LBB278:
 166:main.c        **** }
 1045               	.LM108:
 1046 02f0 84E9      		ldi r24,lo8(-108)
 1047 02f2 8093 7400 		sts 116,r24
 1048               	.LBE278:
 1049               	.LBE277:
 209:main.c        ****     TWIStop();
 210:main.c        ****     return 0x03;
 1051               	.LM109:
 1052 02f6 83E0      		ldi r24,lo8(3)
 1053 02f8 00C0      		rjmp .L76
 1054               	.L78:
 1055               	.LBB279:
 1056               	.LBB280:
 166:main.c        **** }
 1058               	.LM110:
 1059 02fa 84E9      		ldi r24,lo8(-108)
 1060 02fc 8093 7400 		sts 116,r24
 1061               	.LBE280:
 1062               	.LBE279:
 211:main.c        ****   }
 212:main.c        ****   TWIStop();
 213:main.c        ****   return 0x00;
 1064               	.LM111:
 1065 0300 80E0      		ldi r24,0
 1066               	.L76:
 1067               	/* epilogue start */
 214:main.c        **** }
 1069               	.LM112:
 1070 0302 0F90      		pop __tmp_reg__
 1071 0304 DF91      		pop r29
 1072 0306 CF91      		pop r28
 1073 0308 1F91      		pop r17
 1074 030a 0895      		ret
 1076               	.Lscope16:
 1080               	.global	TWI_read_byte
 1082               	TWI_read_byte:
 215:main.c        **** 
 216:main.c        **** uint8_t TWI_read_byte(uint8_t addr, uint8_t* data) {
 1084               	.LM113:
 1085               	.LFBB17:
 1086 030c 0F93      		push r16
 1087 030e 1F93      		push r17
 1088 0310 CF93      		push r28
 1089 0312 DF93      		push r29
 1090 0314 1F92      		push __zero_reg__
 1091 0316 CDB7      		in r28,__SP_L__
 1092 0318 DEB7      		in r29,__SP_H__
 1093               	/* prologue: function */
 1094               	/* frame size = 1 */
 1095               	/* stack size = 5 */
 1096               	.L__stack_usage = 5
 1097 031a 8B01      		movw r16,r22
 217:main.c        **** 
 218:main.c        ****   TWIStart();
 1099               	.LM114:
 1100 031c 8983      		std Y+1,r24
 1101 031e 0E94 0000 		call TWIStart
 1102               	.LBB301:
 1103               	.LBB302:
 191:main.c        ****   return status;
 1105               	.LM115:
 1106 0322 9091 7100 		lds r25,113
 1107 0326 987F      		andi r25,lo8(-8)
 1108               	.LBE302:
 1109               	.LBE301:
 219:main.c        ****   if (TWIGetStatus() != 0x08) {
 1111               	.LM116:
 1112 0328 8981      		ldd r24,Y+1
 1113 032a 9830      		cpi r25,lo8(8)
 1114 032c 01F0      		breq .L80
 1115               	.LBB303:
 1116               	.LBB304:
 166:main.c        **** }
 1118               	.LM117:
 1119 032e 84E9      		ldi r24,lo8(-108)
 1120 0330 8093 7400 		sts 116,r24
 1121               	.LBE304:
 1122               	.LBE303:
 220:main.c        ****     TWIStop();
 221:main.c        ****     return 0x01;
 1124               	.LM118:
 1125 0334 81E0      		ldi r24,lo8(1)
 1126 0336 00C0      		rjmp .L81
 1127               	.L80:
 222:main.c        ****   }
 223:main.c        ****   TWIWrite((addr << 1) | 0x01);
 1129               	.LM119:
 1130 0338 880F      		lsl r24
 1131 033a 8160      		ori r24,lo8(1)
 1132 033c 0E94 0000 		call TWIWrite
 1133               	.LBB305:
 1134               	.LBB306:
 191:main.c        ****   return status;
 1136               	.LM120:
 1137 0340 8091 7100 		lds r24,113
 1138 0344 887F      		andi r24,lo8(-8)
 1139               	.LBE306:
 1140               	.LBE305:
 224:main.c        ****   if (TWIGetStatus() != 0x40) {
 1142               	.LM121:
 1143 0346 8034      		cpi r24,lo8(64)
 1144 0348 01F0      		breq .L82
 1145               	.LBB307:
 1146               	.LBB308:
 166:main.c        **** }
 1148               	.LM122:
 1149 034a 84E9      		ldi r24,lo8(-108)
 1150 034c 8093 7400 		sts 116,r24
 1151               	.LBE308:
 1152               	.LBE307:
 225:main.c        ****     TWIStop();
 226:main.c        ****     return 0x02;
 1154               	.LM123:
 1155 0350 82E0      		ldi r24,lo8(2)
 1156 0352 00C0      		rjmp .L81
 1157               	.L82:
 1158               	.LBB309:
 1159               	.LBB310:
 227:main.c        ****   }
 228:main.c        ****   *data = TWIReadNACK();
 1161               	.LM124:
 1162 0354 0E94 0000 		call TWIReadNACK
 1163 0358 F801      		movw r30,r16
 1164 035a 8083      		st Z,r24
 1165               	.LBB311:
 1166               	.LBB312:
 166:main.c        **** }
 1168               	.LM125:
 1169 035c 84E9      		ldi r24,lo8(-108)
 1170 035e 8093 7400 		sts 116,r24
 1171 0362 80E0      		ldi r24,0
 1172               	.L81:
 1173               	/* epilogue start */
 1174               	.LBE312:
 1175               	.LBE311:
 1176               	.LBE310:
 1177               	.LBE309:
 229:main.c        ****   TWIStop();
 230:main.c        ****   return 0x00;
 231:main.c        **** }
 1179               	.LM126:
 1180 0364 0F90      		pop __tmp_reg__
 1181 0366 DF91      		pop r29
 1182 0368 CF91      		pop r28
 1183 036a 1F91      		pop r17
 1184 036c 0F91      		pop r16
 1185 036e 0895      		ret
 1187               	.Lscope17:
 1190               	.global	TWI_write_word
 1192               	TWI_write_word:
 232:main.c        **** 
 233:main.c        **** uint8_t TWI_write_word(uint8_t addr, uint16_t data_word) {
 1194               	.LM127:
 1195               	.LFBB18:
 1196 0370 0F93      		push r16
 1197 0372 1F93      		push r17
 1198 0374 CF93      		push r28
 1199 0376 DF93      		push r29
 1200 0378 1F92      		push __zero_reg__
 1201 037a CDB7      		in r28,__SP_L__
 1202 037c DEB7      		in r29,__SP_H__
 1203               	/* prologue: function */
 1204               	/* frame size = 1 */
 1205               	/* stack size = 5 */
 1206               	.L__stack_usage = 5
 1207 037e 162F      		mov r17,r22
 1208 0380 072F      		mov r16,r23
 234:main.c        **** 
 235:main.c        ****   TWIStart();
 1210               	.LM128:
 1211 0382 8983      		std Y+1,r24
 1212 0384 0E94 0000 		call TWIStart
 1213               	.LBB345:
 1214               	.LBB346:
 191:main.c        ****   return status;
 1216               	.LM129:
 1217 0388 9091 7100 		lds r25,113
 1218 038c 987F      		andi r25,lo8(-8)
 1219               	.LBE346:
 1220               	.LBE345:
 236:main.c        ****   if (TWIGetStatus() != 0x08) {
 1222               	.LM130:
 1223 038e 8981      		ldd r24,Y+1
 1224 0390 9830      		cpi r25,lo8(8)
 1225 0392 01F0      		breq .L84
 1226               	.LBB347:
 1227               	.LBB348:
 166:main.c        **** }
 1229               	.LM131:
 1230 0394 84E9      		ldi r24,lo8(-108)
 1231 0396 8093 7400 		sts 116,r24
 1232               	.LBE348:
 1233               	.LBE347:
 237:main.c        ****     TWIStop();
 238:main.c        ****     return 0x01;
 1235               	.LM132:
 1236 039a 81E0      		ldi r24,lo8(1)
 1237 039c 00C0      		rjmp .L85
 1238               	.L84:
 239:main.c        ****   }
 240:main.c        ****   TWIWrite(addr << 1);
 1240               	.LM133:
 1241 039e 880F      		lsl r24
 1242 03a0 0E94 0000 		call TWIWrite
 1243               	.LBB349:
 1244               	.LBB350:
 191:main.c        ****   return status;
 1246               	.LM134:
 1247 03a4 9091 7100 		lds r25,113
 1248 03a8 987F      		andi r25,lo8(-8)
 1249               	.LBE350:
 1250               	.LBE349:
 241:main.c        ****   if (TWIGetStatus() != 0x18) {
 1252               	.LM135:
 1253 03aa 9831      		cpi r25,lo8(24)
 1254 03ac 01F0      		breq .L86
 1255               	.LBB351:
 1256               	.LBB352:
 166:main.c        **** }
 1258               	.LM136:
 1259 03ae 84E9      		ldi r24,lo8(-108)
 1260 03b0 8093 7400 		sts 116,r24
 1261               	.LBE352:
 1262               	.LBE351:
 242:main.c        ****     TWIStop();
 243:main.c        ****     return 0x02;  
 1264               	.LM137:
 1265 03b4 82E0      		ldi r24,lo8(2)
 1266 03b6 00C0      		rjmp .L85
 1267               	.L86:
 244:main.c        ****   }
 245:main.c        ****   TWIWrite((uint8_t)((data_word & 0xFF00) >> 8));
 1269               	.LM138:
 1270 03b8 802F      		mov r24,r16
 1271 03ba 0E94 0000 		call TWIWrite
 1272               	.LBB353:
 1273               	.LBB354:
 191:main.c        ****   return status;
 1275               	.LM139:
 1276 03be 9091 7100 		lds r25,113
 1277 03c2 987F      		andi r25,lo8(-8)
 1278               	.LBE354:
 1279               	.LBE353:
 246:main.c        ****   if (TWIGetStatus() != 0x28) {
 1281               	.LM140:
 1282 03c4 9832      		cpi r25,lo8(40)
 1283 03c6 01F0      		breq .L87
 1284               	.LBB355:
 1285               	.LBB356:
 166:main.c        **** }
 1287               	.LM141:
 1288 03c8 84E9      		ldi r24,lo8(-108)
 1289 03ca 8093 7400 		sts 116,r24
 1290               	.LBE356:
 1291               	.LBE355:
 247:main.c        ****     TWIStop();
 248:main.c        ****     return 0x03;
 1293               	.LM142:
 1294 03ce 83E0      		ldi r24,lo8(3)
 1295 03d0 00C0      		rjmp .L85
 1296               	.L87:
 1297               	.LBB357:
 1298               	.LBB358:
 249:main.c        ****   }
 250:main.c        ****   TWIWrite((uint8_t)(data_word & 0x00FF));
 1300               	.LM143:
 1301 03d2 812F      		mov r24,r17
 1302 03d4 0E94 0000 		call TWIWrite
 1303               	.LBB359:
 1304               	.LBB360:
 191:main.c        ****   return status;
 1306               	.LM144:
 1307 03d8 8091 7100 		lds r24,113
 1308 03dc 887F      		andi r24,lo8(-8)
 1309               	.LBE360:
 1310               	.LBE359:
 251:main.c        ****   if (TWIGetStatus() != 0x28) {
 1312               	.LM145:
 1313 03de 8832      		cpi r24,lo8(40)
 1314 03e0 01F0      		breq .L88
 1315               	.LBB361:
 1316               	.LBB362:
 166:main.c        **** }
 1318               	.LM146:
 1319 03e2 84E9      		ldi r24,lo8(-108)
 1320 03e4 8093 7400 		sts 116,r24
 1321               	.LBE362:
 1322               	.LBE361:
 252:main.c        ****     TWIStop();
 253:main.c        ****     return 0x04;
 1324               	.LM147:
 1325 03e8 84E0      		ldi r24,lo8(4)
 1326 03ea 00C0      		rjmp .L85
 1327               	.L88:
 1328               	.LBB363:
 1329               	.LBB364:
 166:main.c        **** }
 1331               	.LM148:
 1332 03ec 84E9      		ldi r24,lo8(-108)
 1333 03ee 8093 7400 		sts 116,r24
 1334               	.LBE364:
 1335               	.LBE363:
 254:main.c        ****   }
 255:main.c        ****   TWIStop();
 256:main.c        ****   return 0x00;
 1337               	.LM149:
 1338 03f2 80E0      		ldi r24,0
 1339               	.L85:
 1340               	/* epilogue start */
 1341               	.LBE358:
 1342               	.LBE357:
 257:main.c        **** }
 1344               	.LM150:
 1345 03f4 0F90      		pop __tmp_reg__
 1346 03f6 DF91      		pop r29
 1347 03f8 CF91      		pop r28
 1348 03fa 1F91      		pop r17
 1349 03fc 0F91      		pop r16
 1350 03fe 0895      		ret
 1352               	.Lscope18:
 1358               	.global	TWI_write_3bytes
 1360               	TWI_write_3bytes:
 258:main.c        **** 
 259:main.c        **** uint8_t TWI_write_3bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3) {
 1362               	.LM151:
 1363               	.LFBB19:
 1364 0400 FF92      		push r15
 1365 0402 0F93      		push r16
 1366 0404 1F93      		push r17
 1367 0406 CF93      		push r28
 1368 0408 DF93      		push r29
 1369 040a 1F92      		push __zero_reg__
 1370 040c CDB7      		in r28,__SP_L__
 1371 040e DEB7      		in r29,__SP_H__
 1372               	/* prologue: function */
 1373               	/* frame size = 1 */
 1374               	/* stack size = 6 */
 1375               	.L__stack_usage = 6
 1376 0410 162F      		mov r17,r22
 1377 0412 042F      		mov r16,r20
 1378 0414 F22E      		mov r15,r18
 260:main.c        **** 
 261:main.c        ****   TWIStart();
 1380               	.LM152:
 1381 0416 8983      		std Y+1,r24
 1382 0418 0E94 0000 		call TWIStart
 1383               	.LBB365:
 1384               	.LBB366:
 191:main.c        ****   return status;
 1386               	.LM153:
 1387 041c 9091 7100 		lds r25,113
 1388 0420 987F      		andi r25,lo8(-8)
 1389               	.LBE366:
 1390               	.LBE365:
 262:main.c        ****   if (TWIGetStatus() != 0x08) {
 1392               	.LM154:
 1393 0422 8981      		ldd r24,Y+1
 1394 0424 9830      		cpi r25,lo8(8)
 1395 0426 01F0      		breq .L90
 1396               	.LBB367:
 1397               	.LBB368:
 166:main.c        **** }
 1399               	.LM155:
 1400 0428 84E9      		ldi r24,lo8(-108)
 1401 042a 8093 7400 		sts 116,r24
 1402               	.LBE368:
 1403               	.LBE367:
 263:main.c        ****     TWIStop();
 264:main.c        ****     return 0x01;
 1405               	.LM156:
 1406 042e 81E0      		ldi r24,lo8(1)
 1407 0430 00C0      		rjmp .L91
 1408               	.L90:
 265:main.c        ****   }
 266:main.c        ****   TWIWrite(addr << 1);
 1410               	.LM157:
 1411 0432 880F      		lsl r24
 1412 0434 0E94 0000 		call TWIWrite
 1413               	.LBB369:
 1414               	.LBB370:
 191:main.c        ****   return status;
 1416               	.LM158:
 1417 0438 9091 7100 		lds r25,113
 1418 043c 987F      		andi r25,lo8(-8)
 1419               	.LBE370:
 1420               	.LBE369:
 267:main.c        ****   if (TWIGetStatus() != 0x18) {
 1422               	.LM159:
 1423 043e 9831      		cpi r25,lo8(24)
 1424 0440 01F0      		breq .L92
 1425               	.LBB371:
 1426               	.LBB372:
 166:main.c        **** }
 1428               	.LM160:
 1429 0442 84E9      		ldi r24,lo8(-108)
 1430 0444 8093 7400 		sts 116,r24
 1431               	.LBE372:
 1432               	.LBE371:
 268:main.c        ****     TWIStop();
 269:main.c        ****     return 0x02;  
 1434               	.LM161:
 1435 0448 82E0      		ldi r24,lo8(2)
 1436 044a 00C0      		rjmp .L91
 1437               	.L92:
 270:main.c        ****   }
 271:main.c        ****   TWIWrite(byte1);
 1439               	.LM162:
 1440 044c 812F      		mov r24,r17
 1441 044e 0E94 0000 		call TWIWrite
 1442               	.LBB373:
 1443               	.LBB374:
 191:main.c        ****   return status;
 1445               	.LM163:
 1446 0452 9091 7100 		lds r25,113
 1447 0456 987F      		andi r25,lo8(-8)
 1448               	.LBE374:
 1449               	.LBE373:
 272:main.c        ****   if (TWIGetStatus() != 0x28) {
 1451               	.LM164:
 1452 0458 9832      		cpi r25,lo8(40)
 1453 045a 01F0      		breq .L93
 1454               	.LBB375:
 1455               	.LBB376:
 166:main.c        **** }
 1457               	.LM165:
 1458 045c 84E9      		ldi r24,lo8(-108)
 1459 045e 8093 7400 		sts 116,r24
 1460               	.LBE376:
 1461               	.LBE375:
 273:main.c        ****     TWIStop();
 274:main.c        ****     return 0x03;
 1463               	.LM166:
 1464 0462 83E0      		ldi r24,lo8(3)
 1465 0464 00C0      		rjmp .L91
 1466               	.L93:
 275:main.c        ****   }
 276:main.c        ****   TWIWrite(byte2);
 1468               	.LM167:
 1469 0466 802F      		mov r24,r16
 1470 0468 0E94 0000 		call TWIWrite
 1471               	.LBB377:
 1472               	.LBB378:
 191:main.c        ****   return status;
 1474               	.LM168:
 1475 046c 9091 7100 		lds r25,113
 1476 0470 987F      		andi r25,lo8(-8)
 1477               	.LBE378:
 1478               	.LBE377:
 277:main.c        ****   if (TWIGetStatus() != 0x28) {
 1480               	.LM169:
 1481 0472 9832      		cpi r25,lo8(40)
 1482 0474 01F4      		brne .L96
 278:main.c        ****     TWIStop();
 279:main.c        ****     return 0x04;
 280:main.c        ****   }
 281:main.c        ****   TWIWrite(byte3);
 1484               	.LM170:
 1485 0476 8F2D      		mov r24,r15
 1486 0478 0E94 0000 		call TWIWrite
 1487               	.LBB379:
 1488               	.LBB380:
 191:main.c        ****   return status;
 1490               	.LM171:
 1491 047c 8091 7100 		lds r24,113
 1492 0480 887F      		andi r24,lo8(-8)
 1493               	.LBE380:
 1494               	.LBE379:
 282:main.c        ****   if (TWIGetStatus() != 0x28) {
 1496               	.LM172:
 1497 0482 8832      		cpi r24,lo8(40)
 1498 0484 01F0      		breq .L95
 1499               	.L96:
 1500               	.LBB381:
 1501               	.LBB382:
 166:main.c        **** }
 1503               	.LM173:
 1504 0486 84E9      		ldi r24,lo8(-108)
 1505 0488 8093 7400 		sts 116,r24
 1506               	.LBE382:
 1507               	.LBE381:
 283:main.c        ****     TWIStop();
 284:main.c        ****     return 0x04;
 1509               	.LM174:
 1510 048c 84E0      		ldi r24,lo8(4)
 1511 048e 00C0      		rjmp .L91
 1512               	.L95:
 1513               	.LBB383:
 1514               	.LBB384:
 166:main.c        **** }
 1516               	.LM175:
 1517 0490 84E9      		ldi r24,lo8(-108)
 1518 0492 8093 7400 		sts 116,r24
 1519               	.LBE384:
 1520               	.LBE383:
 285:main.c        ****   }
 286:main.c        ****   TWIStop();
 287:main.c        ****   return 0x00;
 1522               	.LM176:
 1523 0496 80E0      		ldi r24,0
 1524               	.L91:
 1525               	/* epilogue start */
 288:main.c        **** }
 1527               	.LM177:
 1528 0498 0F90      		pop __tmp_reg__
 1529 049a DF91      		pop r29
 1530 049c CF91      		pop r28
 1531 049e 1F91      		pop r17
 1532 04a0 0F91      		pop r16
 1533 04a2 FF90      		pop r15
 1534 04a4 0895      		ret
 1536               	.Lscope19:
 1543               	.global	TWI_write_4bytes
 1545               	TWI_write_4bytes:
 289:main.c        **** 
 290:main.c        **** uint8_t TWI_write_4bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3, uint8_t byte4) 
 1547               	.LM178:
 1548               	.LFBB20:
 1549 04a6 EF92      		push r14
 1550 04a8 FF92      		push r15
 1551 04aa 0F93      		push r16
 1552 04ac 1F93      		push r17
 1553 04ae CF93      		push r28
 1554 04b0 DF93      		push r29
 1555 04b2 1F92      		push __zero_reg__
 1556 04b4 CDB7      		in r28,__SP_L__
 1557 04b6 DEB7      		in r29,__SP_H__
 1558               	/* prologue: function */
 1559               	/* frame size = 1 */
 1560               	/* stack size = 7 */
 1561               	.L__stack_usage = 7
 1562 04b8 162F      		mov r17,r22
 1563 04ba F42E      		mov r15,r20
 1564 04bc E22E      		mov r14,r18
 291:main.c        **** 
 292:main.c        ****   TWIStart();
 1566               	.LM179:
 1567 04be 8983      		std Y+1,r24
 1568 04c0 0E94 0000 		call TWIStart
 1569               	.LBB385:
 1570               	.LBB386:
 191:main.c        ****   return status;
 1572               	.LM180:
 1573 04c4 9091 7100 		lds r25,113
 1574 04c8 987F      		andi r25,lo8(-8)
 1575               	.LBE386:
 1576               	.LBE385:
 293:main.c        ****   if (TWIGetStatus() != 0x08) {
 1578               	.LM181:
 1579 04ca 8981      		ldd r24,Y+1
 1580 04cc 9830      		cpi r25,lo8(8)
 1581 04ce 01F0      		breq .L98
 1582               	.LBB387:
 1583               	.LBB388:
 166:main.c        **** }
 1585               	.LM182:
 1586 04d0 84E9      		ldi r24,lo8(-108)
 1587 04d2 8093 7400 		sts 116,r24
 1588               	.LBE388:
 1589               	.LBE387:
 294:main.c        ****     TWIStop();
 295:main.c        ****     return 0x01;
 1591               	.LM183:
 1592 04d6 81E0      		ldi r24,lo8(1)
 1593 04d8 00C0      		rjmp .L99
 1594               	.L98:
 296:main.c        ****   }
 297:main.c        ****   TWIWrite(addr << 1);
 1596               	.LM184:
 1597 04da 880F      		lsl r24
 1598 04dc 0E94 0000 		call TWIWrite
 1599               	.LBB389:
 1600               	.LBB390:
 191:main.c        ****   return status;
 1602               	.LM185:
 1603 04e0 9091 7100 		lds r25,113
 1604 04e4 987F      		andi r25,lo8(-8)
 1605               	.LBE390:
 1606               	.LBE389:
 298:main.c        ****   if (TWIGetStatus() != 0x18) {
 1608               	.LM186:
 1609 04e6 9831      		cpi r25,lo8(24)
 1610 04e8 01F0      		breq .L100
 1611               	.LBB391:
 1612               	.LBB392:
 166:main.c        **** }
 1614               	.LM187:
 1615 04ea 84E9      		ldi r24,lo8(-108)
 1616 04ec 8093 7400 		sts 116,r24
 1617               	.LBE392:
 1618               	.LBE391:
 299:main.c        ****     TWIStop();
 300:main.c        ****     return 0x02;  
 1620               	.LM188:
 1621 04f0 82E0      		ldi r24,lo8(2)
 1622 04f2 00C0      		rjmp .L99
 1623               	.L100:
 301:main.c        ****   }
 302:main.c        ****   TWIWrite(byte1);
 1625               	.LM189:
 1626 04f4 812F      		mov r24,r17
 1627 04f6 0E94 0000 		call TWIWrite
 1628               	.LBB393:
 1629               	.LBB394:
 191:main.c        ****   return status;
 1631               	.LM190:
 1632 04fa 9091 7100 		lds r25,113
 1633 04fe 987F      		andi r25,lo8(-8)
 1634               	.LBE394:
 1635               	.LBE393:
 303:main.c        ****   if (TWIGetStatus() != 0x28) {
 1637               	.LM191:
 1638 0500 9832      		cpi r25,lo8(40)
 1639 0502 01F0      		breq .L101
 1640               	.LBB395:
 1641               	.LBB396:
 166:main.c        **** }
 1643               	.LM192:
 1644 0504 84E9      		ldi r24,lo8(-108)
 1645 0506 8093 7400 		sts 116,r24
 1646               	.LBE396:
 1647               	.LBE395:
 304:main.c        ****     TWIStop();
 305:main.c        ****     return 0x03;
 1649               	.LM193:
 1650 050a 83E0      		ldi r24,lo8(3)
 1651 050c 00C0      		rjmp .L99
 1652               	.L101:
 306:main.c        ****   }
 307:main.c        ****   TWIWrite(byte2);
 1654               	.LM194:
 1655 050e 8F2D      		mov r24,r15
 1656 0510 0E94 0000 		call TWIWrite
 1657               	.LBB397:
 1658               	.LBB398:
 191:main.c        ****   return status;
 1660               	.LM195:
 1661 0514 9091 7100 		lds r25,113
 1662 0518 987F      		andi r25,lo8(-8)
 1663               	.LBE398:
 1664               	.LBE397:
 308:main.c        ****   if (TWIGetStatus() != 0x28) {
 1666               	.LM196:
 1667 051a 9832      		cpi r25,lo8(40)
 1668 051c 01F4      		brne .L106
 309:main.c        ****     TWIStop();
 310:main.c        ****     return 0x04;
 311:main.c        ****   }
 312:main.c        ****   TWIWrite(byte3);
 1670               	.LM197:
 1671 051e 8E2D      		mov r24,r14
 1672 0520 0E94 0000 		call TWIWrite
 1673               	.LBB399:
 1674               	.LBB400:
 191:main.c        ****   return status;
 1676               	.LM198:
 1677 0524 9091 7100 		lds r25,113
 1678 0528 987F      		andi r25,lo8(-8)
 1679               	.LBE400:
 1680               	.LBE399:
 313:main.c        ****   if (TWIGetStatus() != 0x28) {
 1682               	.LM199:
 1683 052a 9832      		cpi r25,lo8(40)
 1684 052c 01F4      		brne .L106
 314:main.c        ****     TWIStop();
 315:main.c        ****     return 0x04;
 316:main.c        ****   }
 317:main.c        ****   TWIWrite(byte4);
 1686               	.LM200:
 1687 052e 802F      		mov r24,r16
 1688 0530 0E94 0000 		call TWIWrite
 1689               	.LBB401:
 1690               	.LBB402:
 191:main.c        ****   return status;
 1692               	.LM201:
 1693 0534 8091 7100 		lds r24,113
 1694 0538 887F      		andi r24,lo8(-8)
 1695               	.LBE402:
 1696               	.LBE401:
 318:main.c        ****   if (TWIGetStatus() != 0x28) {
 1698               	.LM202:
 1699 053a 8832      		cpi r24,lo8(40)
 1700 053c 01F0      		breq .L104
 1701               	.L106:
 1702               	.LBB403:
 1703               	.LBB404:
 166:main.c        **** }
 1705               	.LM203:
 1706 053e 84E9      		ldi r24,lo8(-108)
 1707 0540 8093 7400 		sts 116,r24
 1708               	.LBE404:
 1709               	.LBE403:
 319:main.c        ****     TWIStop();
 320:main.c        ****     return 0x04;
 1711               	.LM204:
 1712 0544 84E0      		ldi r24,lo8(4)
 1713 0546 00C0      		rjmp .L99
 1714               	.L104:
 1715               	.LBB405:
 1716               	.LBB406:
 166:main.c        **** }
 1718               	.LM205:
 1719 0548 84E9      		ldi r24,lo8(-108)
 1720 054a 8093 7400 		sts 116,r24
 1721               	.LBE406:
 1722               	.LBE405:
 321:main.c        ****   }
 322:main.c        ****   TWIStop();
 323:main.c        ****   return 0x00;
 1724               	.LM206:
 1725 054e 80E0      		ldi r24,0
 1726               	.L99:
 1727               	/* epilogue start */
 324:main.c        **** }
 1729               	.LM207:
 1730 0550 0F90      		pop __tmp_reg__
 1731 0552 DF91      		pop r29
 1732 0554 CF91      		pop r28
 1733 0556 1F91      		pop r17
 1734 0558 0F91      		pop r16
 1735 055a FF90      		pop r15
 1736 055c EF90      		pop r14
 1737 055e 0895      		ret
 1739               	.Lscope20:
 1747               	.global	TWI_write_5bytes
 1749               	TWI_write_5bytes:
 325:main.c        **** 
 326:main.c        **** uint8_t TWI_write_5bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3, uint8_t byte4, 
 1751               	.LM208:
 1752               	.LFBB21:
 1753 0560 DF92      		push r13
 1754 0562 EF92      		push r14
 1755 0564 FF92      		push r15
 1756 0566 0F93      		push r16
 1757 0568 1F93      		push r17
 1758 056a CF93      		push r28
 1759 056c DF93      		push r29
 1760 056e 1F92      		push __zero_reg__
 1761 0570 CDB7      		in r28,__SP_L__
 1762 0572 DEB7      		in r29,__SP_H__
 1763               	/* prologue: function */
 1764               	/* frame size = 1 */
 1765               	/* stack size = 8 */
 1766               	.L__stack_usage = 8
 1767 0574 162F      		mov r17,r22
 1768 0576 F42E      		mov r15,r20
 1769 0578 D22E      		mov r13,r18
 327:main.c        **** 
 328:main.c        ****   TWIStart();
 1771               	.LM209:
 1772 057a 8983      		std Y+1,r24
 1773 057c 0E94 0000 		call TWIStart
 1774               	.LBB455:
 1775               	.LBB456:
 191:main.c        ****   return status;
 1777               	.LM210:
 1778 0580 9091 7100 		lds r25,113
 1779 0584 987F      		andi r25,lo8(-8)
 1780               	.LBE456:
 1781               	.LBE455:
 329:main.c        ****   if (TWIGetStatus() != 0x08) {
 1783               	.LM211:
 1784 0586 8981      		ldd r24,Y+1
 1785 0588 9830      		cpi r25,lo8(8)
 1786 058a 01F0      		breq .L108
 1787               	.LBB457:
 1788               	.LBB458:
 166:main.c        **** }
 1790               	.LM212:
 1791 058c 84E9      		ldi r24,lo8(-108)
 1792 058e 8093 7400 		sts 116,r24
 1793               	.LBE458:
 1794               	.LBE457:
 330:main.c        ****     TWIStop();
 331:main.c        ****     return 0x01;
 1796               	.LM213:
 1797 0592 81E0      		ldi r24,lo8(1)
 1798 0594 00C0      		rjmp .L109
 1799               	.L108:
 332:main.c        ****   }
 333:main.c        ****   TWIWrite(addr << 1);
 1801               	.LM214:
 1802 0596 880F      		lsl r24
 1803 0598 0E94 0000 		call TWIWrite
 1804               	.LBB459:
 1805               	.LBB460:
 191:main.c        ****   return status;
 1807               	.LM215:
 1808 059c 9091 7100 		lds r25,113
 1809 05a0 987F      		andi r25,lo8(-8)
 1810               	.LBE460:
 1811               	.LBE459:
 334:main.c        ****   if (TWIGetStatus() != 0x18) {
 1813               	.LM216:
 1814 05a2 9831      		cpi r25,lo8(24)
 1815 05a4 01F0      		breq .L110
 1816               	.LBB461:
 1817               	.LBB462:
 166:main.c        **** }
 1819               	.LM217:
 1820 05a6 84E9      		ldi r24,lo8(-108)
 1821 05a8 8093 7400 		sts 116,r24
 1822               	.LBE462:
 1823               	.LBE461:
 335:main.c        ****     TWIStop();
 336:main.c        ****     return 0x02;  
 1825               	.LM218:
 1826 05ac 82E0      		ldi r24,lo8(2)
 1827 05ae 00C0      		rjmp .L109
 1828               	.L110:
 337:main.c        ****   }
 338:main.c        ****   TWIWrite(byte1);
 1830               	.LM219:
 1831 05b0 812F      		mov r24,r17
 1832 05b2 0E94 0000 		call TWIWrite
 1833               	.LBB463:
 1834               	.LBB464:
 191:main.c        ****   return status;
 1836               	.LM220:
 1837 05b6 9091 7100 		lds r25,113
 1838 05ba 987F      		andi r25,lo8(-8)
 1839               	.LBE464:
 1840               	.LBE463:
 339:main.c        ****   if (TWIGetStatus() != 0x28) {
 1842               	.LM221:
 1843 05bc 9832      		cpi r25,lo8(40)
 1844 05be 01F0      		breq .L111
 1845               	.LBB465:
 1846               	.LBB466:
 166:main.c        **** }
 1848               	.LM222:
 1849 05c0 84E9      		ldi r24,lo8(-108)
 1850 05c2 8093 7400 		sts 116,r24
 1851               	.LBE466:
 1852               	.LBE465:
 340:main.c        ****     TWIStop();
 341:main.c        ****     return 0x03;
 1854               	.LM223:
 1855 05c6 83E0      		ldi r24,lo8(3)
 1856 05c8 00C0      		rjmp .L109
 1857               	.L111:
 342:main.c        ****   }
 343:main.c        ****   TWIWrite(byte2);
 1859               	.LM224:
 1860 05ca 8F2D      		mov r24,r15
 1861 05cc 0E94 0000 		call TWIWrite
 1862               	.LBB467:
 1863               	.LBB468:
 191:main.c        ****   return status;
 1865               	.LM225:
 1866 05d0 9091 7100 		lds r25,113
 1867 05d4 987F      		andi r25,lo8(-8)
 1868               	.LBE468:
 1869               	.LBE467:
 344:main.c        ****   if (TWIGetStatus() != 0x28) {
 1871               	.LM226:
 1872 05d6 9832      		cpi r25,lo8(40)
 1873 05d8 01F4      		brne .L116
 1874               	.LBB469:
 1875               	.LBB470:
 345:main.c        ****     TWIStop();
 346:main.c        ****     return 0x04;
 347:main.c        ****   }
 348:main.c        ****   TWIWrite(byte3);
 1877               	.LM227:
 1878 05da 8D2D      		mov r24,r13
 1879 05dc 0E94 0000 		call TWIWrite
 1880               	.LBB471:
 1881               	.LBB472:
 191:main.c        ****   return status;
 1883               	.LM228:
 1884 05e0 9091 7100 		lds r25,113
 1885 05e4 987F      		andi r25,lo8(-8)
 1886               	.LBE472:
 1887               	.LBE471:
 349:main.c        ****   if (TWIGetStatus() != 0x28) {
 1889               	.LM229:
 1890 05e6 9832      		cpi r25,lo8(40)
 1891 05e8 01F4      		brne .L116
 350:main.c        ****     TWIStop();
 351:main.c        ****     return 0x04;
 352:main.c        ****   }
 353:main.c        ****   TWIWrite(byte4);
 1893               	.LM230:
 1894 05ea 802F      		mov r24,r16
 1895 05ec 0E94 0000 		call TWIWrite
 1896               	.LBB473:
 1897               	.LBB474:
 191:main.c        ****   return status;
 1899               	.LM231:
 1900 05f0 9091 7100 		lds r25,113
 1901 05f4 987F      		andi r25,lo8(-8)
 1902               	.LBE474:
 1903               	.LBE473:
 354:main.c        ****   if (TWIGetStatus() != 0x28) {
 1905               	.LM232:
 1906 05f6 9832      		cpi r25,lo8(40)
 1907 05f8 01F4      		brne .L116
 355:main.c        ****     TWIStop();
 356:main.c        ****     return 0x04;
 357:main.c        ****   }
 358:main.c        ****   TWIWrite(byte5);
 1909               	.LM233:
 1910 05fa 8E2D      		mov r24,r14
 1911 05fc 0E94 0000 		call TWIWrite
 1912               	.LBB475:
 1913               	.LBB476:
 191:main.c        ****   return status;
 1915               	.LM234:
 1916 0600 8091 7100 		lds r24,113
 1917 0604 887F      		andi r24,lo8(-8)
 1918               	.LBE476:
 1919               	.LBE475:
 359:main.c        ****   if (TWIGetStatus() != 0x28) {
 1921               	.LM235:
 1922 0606 8832      		cpi r24,lo8(40)
 1923 0608 01F0      		breq .L115
 1924               	.L116:
 1925               	.LBB477:
 1926               	.LBB478:
 166:main.c        **** }
 1928               	.LM236:
 1929 060a 84E9      		ldi r24,lo8(-108)
 1930 060c 8093 7400 		sts 116,r24
 1931               	.LBE478:
 1932               	.LBE477:
 360:main.c        ****     TWIStop();
 361:main.c        ****     return 0x04;
 1934               	.LM237:
 1935 0610 84E0      		ldi r24,lo8(4)
 1936 0612 00C0      		rjmp .L109
 1937               	.L115:
 1938               	.LBB479:
 1939               	.LBB480:
 166:main.c        **** }
 1941               	.LM238:
 1942 0614 84E9      		ldi r24,lo8(-108)
 1943 0616 8093 7400 		sts 116,r24
 1944               	.LBE480:
 1945               	.LBE479:
 362:main.c        ****   }
 363:main.c        ****   TWIStop();
 364:main.c        ****   return 0x00;
 1947               	.LM239:
 1948 061a 80E0      		ldi r24,0
 1949               	.L109:
 1950               	/* epilogue start */
 1951               	.LBE470:
 1952               	.LBE469:
 365:main.c        **** }
 1954               	.LM240:
 1955 061c 0F90      		pop __tmp_reg__
 1956 061e DF91      		pop r29
 1957 0620 CF91      		pop r28
 1958 0622 1F91      		pop r17
 1959 0624 0F91      		pop r16
 1960 0626 FF90      		pop r15
 1961 0628 EF90      		pop r14
 1962 062a DF90      		pop r13
 1963 062c 0895      		ret
 1965               	.Lscope21:
 1966               	.global	__divsf3
 1967               	.global	__floatsisf
 1968               	.global	__addsf3
 1969               	.global	__fixsfsi
 1970               		.section	.rodata.str1.1,"aMS",@progbits,1
 1971               	.LC0:
 1972 0000 2564 2C25 		.string	"%d,%06.2f     "
 1972      3036 2E32 
 1972      6620 2020 
 1972      2020 00
 1973               	.LC1:
 1974 000f 2B00      		.string	"+"
 1975               	.LC2:
 1976 0011 2D00      		.string	"-"
 1977               	.LC3:
 1978 0013 2000      		.string	" "
 1979               		.text
 1981               	.global	lcd_freq
 1983               	lcd_freq:
 366:main.c        **** 
 367:main.c        **** void lcd_freq() {
 1985               	.LM241:
 1986               	.LFBB22:
 1987 062e 8F92      		push r8
 1988 0630 9F92      		push r9
 1989 0632 AF92      		push r10
 1990 0634 BF92      		push r11
 1991 0636 CF92      		push r12
 1992 0638 DF92      		push r13
 1993 063a EF92      		push r14
 1994 063c FF92      		push r15
 1995 063e 0F93      		push r16
 1996 0640 1F93      		push r17
 1997 0642 CF93      		push r28
 1998 0644 DF93      		push r29
 1999 0646 CDB7      		in r28,__SP_L__
 2000 0648 DEB7      		in r29,__SP_H__
 2001 064a EC97      		sbiw r28,60
 2002 064c 0FB6      		in __tmp_reg__,__SREG__
 2003 064e F894      		cli
 2004 0650 DEBF      		out __SP_H__,r29
 2005 0652 0FBE      		out __SREG__,__tmp_reg__
 2006 0654 CDBF      		out __SP_L__,r28
 2007               	/* prologue: function */
 2008               	/* frame size = 60 */
 2009               	/* stack size = 72 */
 2010               	.L__stack_usage = 72
 368:main.c        ****   char buffer[60];
 369:main.c        **** 
 370:main.c        ****   if (mode == AM || mode == AMN || mode == FM) {
 2012               	.LM242:
 2013 0656 8091 0000 		lds r24,mode
 2014 065a 8830      		cpi r24,lo8(8)
 2015 065c 01F0      		breq .L118
 2017               	.LM243:
 2018 065e 8091 0000 		lds r24,mode
 2019 0662 8930      		cpi r24,lo8(9)
 2020 0664 01F0      		breq .L118
 2022               	.LM244:
 2023 0666 8091 0000 		lds r24,mode
 2024 066a 8A30      		cpi r24,lo8(10)
 2025 066c 01F4      		brne .L119
 2026               	.L118:
 371:main.c        ****     freq = round(freq);
 2028               	.LM245:
 2029 066e 6091 0000 		lds r22,freq
 2030 0672 7091 0000 		lds r23,freq+1
 2031 0676 8091 0000 		lds r24,freq+2
 2032 067a 9091 0000 		lds r25,freq+3
 2033 067e 0E94 0000 		call round
 2034 0682 6093 0000 		sts freq,r22
 2035 0686 7093 0000 		sts freq+1,r23
 2036 068a 8093 0000 		sts freq+2,r24
 2037 068e 9093 0000 		sts freq+3,r25
 2038               	.L119:
 372:main.c        ****   }
 373:main.c        ****   lcd_goto(0x04);
 2040               	.LM246:
 2041 0692 84E0      		ldi r24,lo8(4)
 2042 0694 0E94 0000 		call lcd_goto
 374:main.c        ****   sprintf(buffer,"%d,%06.2f     ",(int)floor(freq/1000+freq_offset),fmod(freq,1000));
 2044               	.LM247:
 2045 0698 6091 0000 		lds r22,freq
 2046 069c 7091 0000 		lds r23,freq+1
 2047 06a0 8091 0000 		lds r24,freq+2
 2048 06a4 9091 0000 		lds r25,freq+3
 2049 06a8 20E0      		ldi r18,0
 2050 06aa 30E0      		ldi r19,0
 2051 06ac 4AE7      		ldi r20,lo8(122)
 2052 06ae 54E4      		ldi r21,lo8(68)
 2053 06b0 0E94 0000 		call fmod
 2054 06b4 F62E      		mov r15,r22
 2055 06b6 E72E      		mov r14,r23
 2056 06b8 D82E      		mov r13,r24
 2057 06ba C92E      		mov r12,r25
 2058 06bc 6091 0000 		lds r22,freq
 2059 06c0 7091 0000 		lds r23,freq+1
 2060 06c4 8091 0000 		lds r24,freq+2
 2061 06c8 9091 0000 		lds r25,freq+3
 2062 06cc 0091 0000 		lds r16,freq_offset
 2063 06d0 1091 0000 		lds r17,freq_offset+1
 2064 06d4 20E0      		ldi r18,0
 2065 06d6 30E0      		ldi r19,0
 2066 06d8 4AE7      		ldi r20,lo8(122)
 2067 06da 54E4      		ldi r21,lo8(68)
 2068 06dc 0E94 0000 		call __divsf3
 2069 06e0 4B01      		movw r8,r22
 2070 06e2 5C01      		movw r10,r24
 2071 06e4 B801      		movw r22,r16
 2072 06e6 110F      		lsl r17
 2073 06e8 880B      		sbc r24,r24
 2074 06ea 990B      		sbc r25,r25
 2075 06ec 0E94 0000 		call __floatsisf
 2076 06f0 9B01      		movw r18,r22
 2077 06f2 AC01      		movw r20,r24
 2078 06f4 C501      		movw r24,r10
 2079 06f6 B401      		movw r22,r8
 2080 06f8 0E94 0000 		call __addsf3
 2081 06fc 0E94 0000 		call floor
 2082 0700 CF92      		push r12
 2083 0702 DF92      		push r13
 2084 0704 EF92      		push r14
 2085 0706 FF92      		push r15
 2086 0708 0E94 0000 		call __fixsfsi
 2087 070c 7F93      		push r23
 2088 070e 6F93      		push r22
 2089 0710 80E0      		ldi r24,lo8(.LC0)
 2090 0712 90E0      		ldi r25,hi8(.LC0)
 2091 0714 9F93      		push r25
 2092 0716 8F93      		push r24
 2093 0718 8E01      		movw r16,r28
 2094 071a 0F5F      		subi r16,-1
 2095 071c 1F4F      		sbci r17,-1
 2096 071e 1F93      		push r17
 2097 0720 0F93      		push r16
 2098 0722 0E94 0000 		call sprintf
 375:main.c        ****   lcd_puts(buffer);
 2100               	.LM248:
 2101 0726 C801      		movw r24,r16
 2102 0728 0E94 0000 		call lcd_puts
 376:main.c        ****   lcd_goto(0x0f);
 2104               	.LM249:
 2105 072c 8FE0      		ldi r24,lo8(15)
 2106 072e 0E94 0000 		call lcd_goto
 377:main.c        ****   if (clar > 10)
 2108               	.LM250:
 2109 0732 8091 0000 		lds r24,clar
 2110 0736 0FB6      		in __tmp_reg__,__SREG__
 2111 0738 F894      		cli
 2112 073a DEBF      		out __SP_H__,r29
 2113 073c 0FBE      		out __SREG__,__tmp_reg__
 2114 073e CDBF      		out __SP_L__,r28
 2115 0740 8B30      		cpi r24,lo8(11)
 2116 0742 04F0      		brlt .L120
 378:main.c        ****     sprintf(buffer,"+");
 2118               	.LM251:
 2119 0744 60E0      		ldi r22,lo8(.LC1)
 2120 0746 70E0      		ldi r23,hi8(.LC1)
 2121 0748 00C0      		rjmp .L129
 2122               	.L120:
 379:main.c        ****   else if (clar < -10)
 2124               	.LM252:
 2125 074a 8091 0000 		lds r24,clar
 2126 074e 863F      		cpi r24,lo8(-10)
 2127 0750 04F4      		brge .L122
 380:main.c        ****     sprintf(buffer,"-");
 2129               	.LM253:
 2130 0752 60E0      		ldi r22,lo8(.LC2)
 2131 0754 70E0      		ldi r23,hi8(.LC2)
 2132 0756 00C0      		rjmp .L129
 2133               	.L122:
 381:main.c        ****   else
 382:main.c        ****     sprintf(buffer," ");
 2135               	.LM254:
 2136 0758 60E0      		ldi r22,lo8(.LC3)
 2137 075a 70E0      		ldi r23,hi8(.LC3)
 2138               	.L129:
 2139 075c C801      		movw r24,r16
 2140 075e 0E94 0000 		call strcpy
 383:main.c        ****   lcd_puts(buffer);
 2142               	.LM255:
 2143 0762 C801      		movw r24,r16
 2144 0764 0E94 0000 		call lcd_puts
 2145               	/* epilogue start */
 384:main.c        **** }
 2147               	.LM256:
 2148 0768 EC96      		adiw r28,60
 2149 076a 0FB6      		in __tmp_reg__,__SREG__
 2150 076c F894      		cli
 2151 076e DEBF      		out __SP_H__,r29
 2152 0770 0FBE      		out __SREG__,__tmp_reg__
 2153 0772 CDBF      		out __SP_L__,r28
 2154 0774 DF91      		pop r29
 2155 0776 CF91      		pop r28
 2156 0778 1F91      		pop r17
 2157 077a 0F91      		pop r16
 2158 077c FF90      		pop r15
 2159 077e EF90      		pop r14
 2160 0780 DF90      		pop r13
 2161 0782 CF90      		pop r12
 2162 0784 BF90      		pop r11
 2163 0786 AF90      		pop r10
 2164 0788 9F90      		pop r9
 2165 078a 8F90      		pop r8
 2166 078c 0895      		ret
 2171               	.Lscope22:
 2175               	.global	updateVolumeSquelch
 2177               	updateVolumeSquelch:
 385:main.c        **** 
 386:main.c        **** uint8_t updateVolumeSquelch(uint8_t vol, uint8_t sq) {
 2179               	.LM257:
 2180               	.LFBB23:
 2181 078e EF92      		push r14
 2182 0790 0F93      		push r16
 2183               	/* prologue: function */
 2184               	/* frame size = 0 */
 2185               	/* stack size = 2 */
 2186               	.L__stack_usage = 2
 387:main.c        ****   
 388:main.c        ****   uint8_t addr, err;
 389:main.c        **** 
 390:main.c        ****   addr = 0x80; // Address for audio conf
 391:main.c        **** 
 392:main.c        ****   err = TWI_write_5bytes(fpga_addr, addr, 0x00, 0x00, sq, vol);
 2188               	.LM258:
 2189 0792 E82E      		mov r14,r24
 2190 0794 062F      		mov r16,r22
 2191 0796 20E0      		ldi r18,0
 2192 0798 40E0      		ldi r20,0
 2193 079a 60E8      		ldi r22,lo8(-128)
 2194 079c 83E2      		ldi r24,lo8(35)
 2195 079e 0E94 0000 		call TWI_write_5bytes
 2196               	/* epilogue start */
 393:main.c        ****   if(err)
 394:main.c        ****     return err;
 395:main.c        ****   return 0x00;
 396:main.c        **** }
 2198               	.LM259:
 2199 07a2 0F91      		pop r16
 2200 07a4 EF90      		pop r14
 2201 07a6 0895      		ret
 2203               	.Lscope23:
 2205               	.global	readClar
 2207               	readClar:
 397:main.c        **** 
 398:main.c        **** uint16_t readClar(void) {
 2209               	.LM260:
 2210               	.LFBB24:
 2211               	/* prologue: function */
 2212               	/* frame size = 0 */
 2213               	/* stack size = 0 */
 2214               	.L__stack_usage = 0
 399:main.c        ****   return (ADC);
 2216               	.LM261:
 2217 07a8 84B1      		in r24,0x4
 2218 07aa 95B1      		in r25,0x4+1
 400:main.c        **** }
 2220               	.LM262:
 2221 07ac 0895      		ret
 2223               	.Lscope24:
 2225               	.global	updateRFFE
 2227               	updateRFFE:
 401:main.c        **** 
 402:main.c        **** uint8_t updateRFFE(void) {
 2229               	.LM263:
 2230               	.LFBB25:
 2231               	/* prologue: function */
 2232               	/* frame size = 0 */
 2233               	/* stack size = 0 */
 2234               	.L__stack_usage = 0
 403:main.c        ****   uint8_t err;
 404:main.c        ****   uint16_t rxatt;
 405:main.c        **** 
 406:main.c        ****   if (rx_att)
 2236               	.LM264:
 2237 07ae 4091 0000 		lds r20,rx_att
 407:main.c        ****     rxatt = 0x0001;
 408:main.c        ****   else
 409:main.c        ****     rxatt = 0x0000;
 410:main.c        **** 
 411:main.c        ****   err = TWI_write_word(pll_addr,(pll_n & 0x0fff) | (tx << 15) | (bandf << 14) | (rxatt << 13));
 2239               	.LM265:
 2240 07b2 8091 0000 		lds r24,pll_n
 2241 07b6 9091 0000 		lds r25,pll_n+1
 2242 07ba 6091 0000 		lds r22,tx
 2243 07be 7091 0000 		lds r23,tx+1
 2244 07c2 2091 0000 		lds r18,bandf
 2245 07c6 3091 0000 		lds r19,bandf+1
 2246 07ca 7727      		clr r23
 2247 07cc 6695      		lsr r22
 2248 07ce 7795      		ror r23
 2249 07d0 6627      		clr r22
 2250 07d2 9F70      		andi r25,15
 2251 07d4 682B      		or r22,r24
 2252 07d6 792B      		or r23,r25
 2253 07d8 30E4      		ldi r19,0x40
 2254 07da 239F      		mul r18,r19
 2255 07dc 302D      		mov r19,r0
 2256 07de 2227      		clr r18
 2257 07e0 1124      		clr __zero_reg__
 2258 07e2 622B      		or r22,r18
 2259 07e4 732B      		or r23,r19
 406:main.c        ****     rxatt = 0x0001;
 2261               	.LM266:
 2262 07e6 21E0      		ldi r18,lo8(1)
 2263 07e8 4111      		cpse r20,__zero_reg__
 2264 07ea 00C0      		rjmp .L133
 2265 07ec 20E0      		ldi r18,0
 2266               	.L133:
 2268               	.LM267:
 2269 07ee 80E0      		ldi r24,0
 2270 07f0 90E0      		ldi r25,0
 2271 07f2 922F      		mov r25,r18
 2272 07f4 9295      		swap r25
 2273 07f6 990F      		lsl r25
 2274 07f8 907E      		andi r25,lo8(-32)
 2275 07fa 682B      		or r22,r24
 2276 07fc 792B      		or r23,r25
 2277 07fe 82E2      		ldi r24,lo8(34)
 2278 0800 0E94 0000 		call TWI_write_word
 412:main.c        ****   if (err)
 2280               	.LM268:
 2281 0804 8823      		tst r24
 2282 0806 01F0      		breq .L135
 413:main.c        ****     return err+5;
 2284               	.LM269:
 2285 0808 8B5F      		subi r24,lo8(-(5))
 2286 080a 0895      		ret
 2287               	.L135:
 414:main.c        ****   return 0x00;
 2289               	.LM270:
 2290 080c 80E0      		ldi r24,0
 415:main.c        **** } 
 2292               	.LM271:
 2293 080e 0895      		ret
 2298               	.Lscope25:
 2299               	.global	__subsf3
 2300               	.global	__mulsf3
 2301               	.global	__fixunssfsi
 2304               	.global	updateFreq
 2306               	updateFreq:
 416:main.c        ****   
 417:main.c        **** uint8_t updateFreq(uint8_t all_update) {
 2308               	.LM272:
 2309               	.LFBB26:
 2310 0810 8F92      		push r8
 2311 0812 9F92      		push r9
 2312 0814 AF92      		push r10
 2313 0816 BF92      		push r11
 2314 0818 CF92      		push r12
 2315 081a DF92      		push r13
 2316 081c EF92      		push r14
 2317 081e FF92      		push r15
 2318 0820 0F93      		push r16
 2319 0822 1F93      		push r17
 2320 0824 CF93      		push r28
 2321 0826 DF93      		push r29
 2322 0828 1F92      		push __zero_reg__
 2323 082a CDB7      		in r28,__SP_L__
 2324 082c DEB7      		in r29,__SP_H__
 2325               	/* prologue: function */
 2326               	/* frame size = 1 */
 2327               	/* stack size = 13 */
 2328               	.L__stack_usage = 13
 418:main.c        ****   //   char buffer[60];
 419:main.c        ****   uint8_t byte1, byte2, byte3, byte4, byte5, err;
 420:main.c        ****   uint16_t pll_n_ = pll_n;
 2330               	.LM273:
 2331 082e 2091 0000 		lds r18,pll_n
 2332 0832 3091 0000 		lds r19,pll_n+1
 421:main.c        ****   double freq_lo, if_freq, ref_freq, ftw;
 422:main.c        ****   static double ftw_toptop, ftw_topbot, ftw_bottop, ftw_botbot;
 423:main.c        **** 
 424:main.c        ****   /*  if (band < 200) { 
 425:main.c        ****     freq_lo = (double)(freq_MHz*1000 + 45000 + freq_kHz);
 426:main.c        ****     bandf = 0;
 427:main.c        ****   }
 428:main.c        ****   else {
 429:main.c        ****     if (freq < 200*1e6) 
 430:main.c        ****       freq_lo = (double)(freq_MHz*1000 + 21400 + freq_kHz);
 431:main.c        ****     else
 432:main.c        ****       freq_lo = (double)((freq_MHz - 1152)*1000 + 21400 + freq_kHz);
 433:main.c        ****     bandf = 1;
 434:main.c        ****     }*/
 435:main.c        **** 
 436:main.c        ****   if (all_update) {
 2334               	.LM274:
 2335 0836 8823      		tst r24
 2336 0838 01F4      		brne .+2
 2337 083a 00C0      		rjmp .L137
 437:main.c        **** #if F_IF == 21
 438:main.c        ****     if_freq=21400;
 439:main.c        **** #elif F_IF == 45
 440:main.c        ****     if_freq=45000;
 441:main.c        **** #endif
 442:main.c        **** #ifdef LO_FREQ_PLUS_IF
 443:main.c        ****     freq_lo = freq + if_freq;
 444:main.c        **** #endif
 445:main.c        **** #ifdef LO_FREQ_MINUS_IF
 446:main.c        ****     freq_lo = freq - if_freq;
 447:main.c        **** #endif
 448:main.c        **** #ifdef LO_IF_PLUS_FREQ
 449:main.c        ****     freq_lo = if_freq + freq;
 450:main.c        **** #endif
 451:main.c        **** #ifdef LO_IF_MINUS_FREQ
 452:main.c        ****     freq_lo = if_freq - freq;
 2339               	.LM275:
 2340 083c 2091 0000 		lds r18,freq
 2341 0840 3091 0000 		lds r19,freq+1
 2342 0844 4091 0000 		lds r20,freq+2
 2343 0848 5091 0000 		lds r21,freq+3
 2344 084c 60E0      		ldi r22,0
 2345 084e 78EC      		ldi r23,lo8(-56)
 2346 0850 8FE2      		ldi r24,lo8(47)
 2347 0852 97E4      		ldi r25,lo8(71)
 2348 0854 0E94 0000 		call __subsf3
 453:main.c        **** #endif
 454:main.c        **** 
 455:main.c        ****     bandf = 1;
 2350               	.LM276:
 2351 0858 21E0      		ldi r18,lo8(1)
 2352 085a 30E0      		ldi r19,0
 2353 085c 3093 0000 		sts bandf+1,r19
 2354 0860 2093 0000 		sts bandf,r18
 456:main.c        **** 
 457:main.c        ****     if (mode == USB) {
 2356               	.LM277:
 2357 0864 2091 0000 		lds r18,mode
 2358 0868 2330      		cpi r18,lo8(3)
 2359 086a 01F4      		brne .L138
 458:main.c        ****       freq_lo -= (double)1.8;
 2361               	.LM278:
 2362 086c 26E6      		ldi r18,lo8(102)
 2363 086e 36E6      		ldi r19,lo8(102)
 2364 0870 46EE      		ldi r20,lo8(-26)
 2365 0872 5FE3      		ldi r21,lo8(63)
 2366 0874 0E94 0000 		call __subsf3
 2367 0878 00C0      		rjmp .L139
 2368               	.L138:
 459:main.c        ****     }
 460:main.c        ****     else if (mode == CW) {
 2370               	.LM279:
 2371 087a 2091 0000 		lds r18,mode
 2372 087e 2530      		cpi r18,lo8(5)
 2373 0880 01F4      		brne .L140
 461:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 462:main.c        ****       freq_lo -= (double)0.9;  // CW = USB
 463:main.c        **** #else
 464:main.c        ****       freq_lo += (double)0.9;  // CW = LSB
 2375               	.LM280:
 2376 0882 26E6      		ldi r18,lo8(102)
 2377 0884 36E6      		ldi r19,lo8(102)
 2378 0886 46E6      		ldi r20,lo8(102)
 2379 0888 5FE3      		ldi r21,lo8(63)
 2380 088a 00C0      		rjmp .L147
 2381               	.L140:
 465:main.c        **** #endif
 466:main.c        **** 
 467:main.c        ****     }
 468:main.c        ****     else if (mode == CWN) {
 2383               	.LM281:
 2384 088c 2091 0000 		lds r18,mode
 2385 0890 2630      		cpi r18,lo8(6)
 2386 0892 01F0      		breq .L139
 469:main.c        ****       //freq_lo += (double)0.9;
 470:main.c        ****     }
 471:main.c        ****     else if (mode == LSB ) {
 2388               	.LM282:
 2389 0894 2091 0000 		lds r18,mode
 2390 0898 2130      		cpi r18,lo8(1)
 2391 089a 01F4      		brne .L139
 472:main.c        ****       freq_lo += (double)1.8;
 2393               	.LM283:
 2394 089c 26E6      		ldi r18,lo8(102)
 2395 089e 36E6      		ldi r19,lo8(102)
 2396 08a0 46EE      		ldi r20,lo8(-26)
 2397 08a2 5FE3      		ldi r21,lo8(63)
 2398               	.L147:
 2399 08a4 0E94 0000 		call __addsf3
 2400               	.L139:
 473:main.c        ****     }
 474:main.c        **** 
 475:main.c        **** #ifdef INDIRECT_FREQ
 476:main.c        ****     pll_n_ = (uint16_t)lround(freq_lo/(double)100);  // 100 kHz step
 477:main.c        ****     ref_freq = 170*freq_lo/pll_n_;  // 170 ref divider value
 478:main.c        ****     ftw = ref_freq*(double)279.62026666667; // 20MHz,25bit: 279.620266667 19.2MHz,22bit: 36.4088889
 479:main.c        ****     ftw_toptop = floor(ftw/(double)16777216);
 480:main.c        ****     ftw_topbot = floor((ftw-ftw_toptop*(double)16777216)/(double)65536);
 481:main.c        ****     ftw_bottop = floor((ftw-ftw_toptop*(double)16777216-ftw_topbot*(double)65536)/(double)256);
 482:main.c        ****     ftw_botbot = fmod(ftw,256);
 483:main.c        **** #endif
 484:main.c        **** #ifdef DIRECT_FREQ
 485:main.c        ****     ftw = freq_lo*(double)279.62026666667; // 20MHz,25bit: 279.620266667 19.2MHz,22bit: 36.4088889
 2402               	.LM284:
 2403 08a8 25E6      		ldi r18,lo8(101)
 2404 08aa 3FEC      		ldi r19,lo8(-49)
 2405 08ac 4BE8      		ldi r20,lo8(-117)
 2406 08ae 53E4      		ldi r21,lo8(67)
 2407 08b0 0E94 0000 		call __mulsf3
 2408 08b4 6B01      		movw r12,r22
 2409 08b6 7C01      		movw r14,r24
 486:main.c        ****     ftw_toptop = floor(ftw/(double)16777216);
 2411               	.LM285:
 2412 08b8 20E0      		ldi r18,0
 2413 08ba 30E0      		ldi r19,0
 2414 08bc 40E8      		ldi r20,lo8(-128)
 2415 08be 53E3      		ldi r21,lo8(51)
 2416 08c0 0E94 0000 		call __mulsf3
 2417 08c4 0E94 0000 		call floor
 2418 08c8 6093 0000 		sts ftw_toptop.2407,r22
 2419 08cc 7093 0000 		sts ftw_toptop.2407+1,r23
 2420 08d0 8093 0000 		sts ftw_toptop.2407+2,r24
 2421 08d4 9093 0000 		sts ftw_toptop.2407+3,r25
 487:main.c        ****     ftw_topbot = floor((ftw-ftw_toptop*(double)16777216)/(double)65536);
 2423               	.LM286:
 2424 08d8 20E0      		ldi r18,0
 2425 08da 30E0      		ldi r19,0
 2426 08dc 40E8      		ldi r20,lo8(-128)
 2427 08de 5BE4      		ldi r21,lo8(75)
 2428 08e0 0E94 0000 		call __mulsf3
 2429 08e4 9B01      		movw r18,r22
 2430 08e6 AC01      		movw r20,r24
 2431 08e8 C701      		movw r24,r14
 2432 08ea B601      		movw r22,r12
 2433 08ec 0E94 0000 		call __subsf3
 2434 08f0 4B01      		movw r8,r22
 2435 08f2 5C01      		movw r10,r24
 2436 08f4 20E0      		ldi r18,0
 2437 08f6 30E0      		ldi r19,0
 2438 08f8 40E8      		ldi r20,lo8(-128)
 2439 08fa 57E3      		ldi r21,lo8(55)
 2440 08fc 0E94 0000 		call __mulsf3
 2441 0900 0E94 0000 		call floor
 2442 0904 6093 0000 		sts ftw_topbot.2408,r22
 2443 0908 7093 0000 		sts ftw_topbot.2408+1,r23
 2444 090c 8093 0000 		sts ftw_topbot.2408+2,r24
 2445 0910 9093 0000 		sts ftw_topbot.2408+3,r25
 488:main.c        ****     ftw_bottop = floor((ftw-ftw_toptop*(double)16777216-ftw_topbot*(double)65536)/(double)256);
 2447               	.LM287:
 2448 0914 20E0      		ldi r18,0
 2449 0916 30E0      		ldi r19,0
 2450 0918 40E8      		ldi r20,lo8(-128)
 2451 091a 57E4      		ldi r21,lo8(71)
 2452 091c 0E94 0000 		call __mulsf3
 2453 0920 9B01      		movw r18,r22
 2454 0922 AC01      		movw r20,r24
 2455 0924 C501      		movw r24,r10
 2456 0926 B401      		movw r22,r8
 2457 0928 0E94 0000 		call __subsf3
 2458 092c 20E0      		ldi r18,0
 2459 092e 30E0      		ldi r19,0
 2460 0930 40E8      		ldi r20,lo8(-128)
 2461 0932 5BE3      		ldi r21,lo8(59)
 2462 0934 0E94 0000 		call __mulsf3
 2463 0938 0E94 0000 		call floor
 2464 093c 6093 0000 		sts ftw_bottop.2409,r22
 2465 0940 7093 0000 		sts ftw_bottop.2409+1,r23
 2466 0944 8093 0000 		sts ftw_bottop.2409+2,r24
 2467 0948 9093 0000 		sts ftw_bottop.2409+3,r25
 489:main.c        ****     ftw_botbot = fmod(ftw,256);
 2469               	.LM288:
 2470 094c 20E0      		ldi r18,0
 2471 094e 30E0      		ldi r19,0
 2472 0950 40E8      		ldi r20,lo8(-128)
 2473 0952 53E4      		ldi r21,lo8(67)
 2474 0954 C701      		movw r24,r14
 2475 0956 B601      		movw r22,r12
 2476 0958 0E94 0000 		call fmod
 2477 095c 6093 0000 		sts ftw_botbot.2410,r22
 2478 0960 7093 0000 		sts ftw_botbot.2410+1,r23
 2479 0964 8093 0000 		sts ftw_botbot.2410+2,r24
 2480 0968 9093 0000 		sts ftw_botbot.2410+3,r25
 2481               	.L137:
 490:main.c        **** #endif    
 491:main.c        ****   }
 492:main.c        **** 
 493:main.c        **** #if defined(LO_FREQ_PLUS_IF) || defined(LO_IF_PLUS_FREQ)
 494:main.c        ****   clar = -(clar+1);  // For arch with LO above RF freq
 495:main.c        **** #endif
 496:main.c        ****   byte1 = 0xc0;
 497:main.c        ****   byte2 = (uint8_t)(ftw_toptop) | (clar & 0xfe);
 2483               	.LM289:
 2484 096c 1091 0000 		lds r17,clar
 498:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 499:main.c        ****   byte4 = (uint8_t)ftw_bottop;
 500:main.c        ****   byte5 = (uint8_t)ftw_botbot;
 2486               	.LM290:
 2487 0970 6091 0000 		lds r22,ftw_botbot.2410
 2488 0974 7091 0000 		lds r23,ftw_botbot.2410+1
 2489 0978 8091 0000 		lds r24,ftw_botbot.2410+2
 2490 097c 9091 0000 		lds r25,ftw_botbot.2410+3
 2491 0980 0E94 0000 		call __fixunssfsi
 2492 0984 E62E      		mov r14,r22
 499:main.c        ****   byte5 = (uint8_t)ftw_botbot;
 2494               	.LM291:
 2495 0986 6091 0000 		lds r22,ftw_bottop.2409
 2496 098a 7091 0000 		lds r23,ftw_bottop.2409+1
 2497 098e 8091 0000 		lds r24,ftw_bottop.2409+2
 2498 0992 9091 0000 		lds r25,ftw_bottop.2409+3
 2499 0996 0E94 0000 		call __fixunssfsi
 2500 099a 062F      		mov r16,r22
 498:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 2502               	.LM292:
 2503 099c 6091 0000 		lds r22,ftw_topbot.2408
 2504 09a0 7091 0000 		lds r23,ftw_topbot.2408+1
 2505 09a4 8091 0000 		lds r24,ftw_topbot.2408+2
 2506 09a8 9091 0000 		lds r25,ftw_topbot.2408+3
 2507 09ac 0E94 0000 		call __fixunssfsi
 2508 09b0 262F      		mov r18,r22
 497:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 2510               	.LM293:
 2511 09b2 6091 0000 		lds r22,ftw_toptop.2407
 2512 09b6 7091 0000 		lds r23,ftw_toptop.2407+1
 2513 09ba 8091 0000 		lds r24,ftw_toptop.2407+2
 2514 09be 9091 0000 		lds r25,ftw_toptop.2407+3
 2515 09c2 2983      		std Y+1,r18
 2516 09c4 0E94 0000 		call __fixunssfsi
 2517 09c8 412F      		mov r20,r17
 2518 09ca 4E7F      		andi r20,lo8(-2)
 2519 09cc 462B      		or r20,r22
 501:main.c        **** 
 502:main.c        ****   err = TWI_write_5bytes(fpga_addr, byte1, byte2, byte3, byte4, byte5);
 2521               	.LM294:
 2522 09ce 2981      		ldd r18,Y+1
 2523 09d0 60EC      		ldi r22,lo8(-64)
 2524 09d2 83E2      		ldi r24,lo8(35)
 2525 09d4 0E94 0000 		call TWI_write_5bytes
 2526               	/* epilogue start */
 503:main.c        ****   if(err)
 504:main.c        ****     return err;
 505:main.c        ****  
 506:main.c        **** #ifdef INDIRECT_FREQ
 507:main.c        ****   _delay_us(50);
 508:main.c        ****   if (pll_n != pll_n_) {
 509:main.c        ****     pll_n = pll_n_;
 510:main.c        ****     err = updateRFFE();
 511:main.c        ****     if (err)
 512:main.c        ****       return err+5;
 513:main.c        ****   }
 514:main.c        **** #endif
 515:main.c        ****   return 0x00;
 516:main.c        **** }
 2528               	.LM295:
 2529 09d8 0F90      		pop __tmp_reg__
 2530 09da DF91      		pop r29
 2531 09dc CF91      		pop r28
 2532 09de 1F91      		pop r17
 2533 09e0 0F91      		pop r16
 2534 09e2 FF90      		pop r15
 2535 09e4 EF90      		pop r14
 2536 09e6 DF90      		pop r13
 2537 09e8 CF90      		pop r12
 2538 09ea BF90      		pop r11
 2539 09ec AF90      		pop r10
 2540 09ee 9F90      		pop r9
 2541 09f0 8F90      		pop r8
 2542 09f2 0895      		ret
 2552               	.Lscope26:
 2554               	.global	updateSettings
 2556               	updateSettings:
 517:main.c        **** 
 518:main.c        **** uint8_t updateSettings (void) {
 2558               	.LM296:
 2559               	.LFBB27:
 2560 09f4 EF92      		push r14
 2561 09f6 0F93      		push r16
 2562               	/* prologue: function */
 2563               	/* frame size = 0 */
 2564               	/* stack size = 2 */
 2565               	.L__stack_usage = 2
 519:main.c        **** 
 520:main.c        ****   uint8_t err;
 521:main.c        ****   uint8_t byte0, byte1, byte2, byte3, byte4;
 522:main.c        **** 
 523:main.c        ****   switch (mode) {  
 2567               	.LM297:
 2568 09f8 9091 0000 		lds r25,mode
 2569 09fc 9530      		cpi r25,lo8(5)
 2570 09fe 01F0      		breq .L150
 2571 0a00 00F4      		brsh .L151
 2572 0a02 9130      		cpi r25,lo8(1)
 2573 0a04 01F0      		breq .L150
 2574 0a06 9330      		cpi r25,lo8(3)
 2575 0a08 01F0      		breq .+2
 2576 0a0a 00C0      		rjmp .L149
 524:main.c        ****   case LSB:
 525:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 526:main.c        ****     byte0 = 0b01111000; // Set USB
 527:main.c        **** #else
 528:main.c        ****     byte0 = 0b01110000; // Set LSB
 529:main.c        **** #endif
 530:main.c        **** #if F_IF == 21
 531:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 532:main.c        ****     byte2 = 0x08;
 533:main.c        **** #elif F_IF == 45
 534:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 535:main.c        ****     byte2 = 0x88;
 536:main.c        **** #endif
 537:main.c        ****     byte3 = 0x00;
 538:main.c        ****     byte4 = 0x00;
 539:main.c        ****     break;
 540:main.c        **** 
 541:main.c        ****   case USB:
 542:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 543:main.c        ****     byte0 = 0b01110000; // Set LSB
 544:main.c        **** #else
 545:main.c        ****     byte0 = 0b01111000; // Set USB
 546:main.c        **** #endif
 547:main.c        **** #if F_IF == 21
 548:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 549:main.c        ****     byte2 = 0x08;
 550:main.c        **** #elif F_IF == 45
 551:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2578               	.LM298:
 2579 0a0c 9091 0000 		lds r25,tx_att
 2580 0a10 8091 0000 		lds r24,rx_att
 2581 0a14 28E0      		ldi r18,lo8(8)
 2582 0a16 829F      		mul r24,r18
 2583 0a18 A001      		movw r20,r0
 2584 0a1a 1124      		clr __zero_reg__
 2585 0a1c 20E4      		ldi r18,lo8(64)
 2586 0a1e 929F      		mul r25,r18
 2587 0a20 C001      		movw r24,r0
 2588 0a22 1124      		clr __zero_reg__
 2589 0a24 482B      		or r20,r24
 545:main.c        **** #endif
 2591               	.LM299:
 2592 0a26 68E7      		ldi r22,lo8(120)
 552:main.c        ****     byte2 = 0x88;
 553:main.c        **** #endif
 554:main.c        ****     byte3 = 0x00;
 555:main.c        ****     byte4 = 0x00;
 556:main.c        ****     break;
 2594               	.LM300:
 2595 0a28 00C0      		rjmp .L149
 2596               	.L151:
 523:main.c        ****   case LSB:
 2598               	.LM301:
 2599 0a2a 9830      		cpi r25,lo8(8)
 2600 0a2c 01F0      		breq .L154
 2601 0a2e 9A30      		cpi r25,lo8(10)
 2602 0a30 01F0      		breq .L155
 2603 0a32 9630      		cpi r25,lo8(6)
 2604 0a34 01F4      		brne .L149
 557:main.c        **** 
 558:main.c        ****   case CW:
 559:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 560:main.c        ****     byte0 = 0b01111000; // Set USB
 561:main.c        **** #else
 562:main.c        ****     byte0 = 0b01110000; // Set LSB
 563:main.c        **** #endif
 564:main.c        **** #if F_IF == 21
 565:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 566:main.c        ****     byte2 = 0x08;
 567:main.c        **** #elif F_IF == 45
 568:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 569:main.c        ****     byte2 = 0x88;
 570:main.c        **** #endif
 571:main.c        ****     byte3 = 0x00;
 572:main.c        ****     byte4 = 0x00;
 573:main.c        ****     break;
 574:main.c        **** 
 575:main.c        ****   case CWN:
 576:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 577:main.c        ****     byte0 = 0b01101000; // Set narrow USB
 578:main.c        **** #else
 579:main.c        ****     byte0 = 0b01100000; // Set narrow LSB
 580:main.c        **** #endif
 581:main.c        **** #if F_IF == 21
 582:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 583:main.c        ****     byte2 = 0x08;
 584:main.c        **** #elif F_IF == 45
 585:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2606               	.LM302:
 2607 0a36 9091 0000 		lds r25,tx_att
 2608 0a3a 8091 0000 		lds r24,rx_att
 2609 0a3e 28E0      		ldi r18,lo8(8)
 2610 0a40 829F      		mul r24,r18
 2611 0a42 A001      		movw r20,r0
 2612 0a44 1124      		clr __zero_reg__
 2613 0a46 20E4      		ldi r18,lo8(64)
 2614 0a48 929F      		mul r25,r18
 2615 0a4a C001      		movw r24,r0
 2616 0a4c 1124      		clr __zero_reg__
 2617 0a4e 482B      		or r20,r24
 579:main.c        **** #endif
 2619               	.LM303:
 2620 0a50 60E6      		ldi r22,lo8(96)
 586:main.c        ****     byte2 = 0x88;
 587:main.c        **** #endif
 588:main.c        ****     byte3 = 0x00;
 589:main.c        ****     byte4 = 0x00;
 590:main.c        ****     break;
 2622               	.LM304:
 2623 0a52 00C0      		rjmp .L149
 2624               	.L150:
 568:main.c        ****     byte2 = 0x88;
 2626               	.LM305:
 2627 0a54 9091 0000 		lds r25,tx_att
 2628 0a58 8091 0000 		lds r24,rx_att
 2629 0a5c 28E0      		ldi r18,lo8(8)
 2630 0a5e 829F      		mul r24,r18
 2631 0a60 A001      		movw r20,r0
 2632 0a62 1124      		clr __zero_reg__
 2633 0a64 20E4      		ldi r18,lo8(64)
 2634 0a66 929F      		mul r25,r18
 2635 0a68 C001      		movw r24,r0
 2636 0a6a 1124      		clr __zero_reg__
 2637 0a6c 482B      		or r20,r24
 562:main.c        **** #endif
 2639               	.LM306:
 2640 0a6e 60E7      		ldi r22,lo8(112)
 573:main.c        **** 
 2642               	.LM307:
 2643 0a70 00C0      		rjmp .L149
 2644               	.L154:
 591:main.c        **** 
 592:main.c        ****   case AM:
 593:main.c        ****     byte0 = 0b01000000;
 594:main.c        **** #if F_IF == 21
 595:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 596:main.c        ****     byte2 = 0x08;
 597:main.c        **** #elif F_IF == 45
 598:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2646               	.LM308:
 2647 0a72 9091 0000 		lds r25,tx_att
 2648 0a76 8091 0000 		lds r24,rx_att
 2649 0a7a 28E0      		ldi r18,lo8(8)
 2650 0a7c 829F      		mul r24,r18
 2651 0a7e A001      		movw r20,r0
 2652 0a80 1124      		clr __zero_reg__
 2653 0a82 20E4      		ldi r18,lo8(64)
 2654 0a84 929F      		mul r25,r18
 2655 0a86 C001      		movw r24,r0
 2656 0a88 1124      		clr __zero_reg__
 2657 0a8a 482B      		or r20,r24
 593:main.c        **** #if F_IF == 21
 2659               	.LM309:
 2660 0a8c 60E4      		ldi r22,lo8(64)
 599:main.c        ****     byte2 = 0x88;
 600:main.c        **** #endif
 601:main.c        ****     byte3 = 0x00;
 602:main.c        ****     byte4 = 0x00;
 603:main.c        ****     break;
 2662               	.LM310:
 2663 0a8e 00C0      		rjmp .L149
 2664               	.L155:
 604:main.c        **** 
 605:main.c        ****   case FM:
 606:main.c        ****     byte0 = 0b01000001;
 607:main.c        **** #if F_IF == 21
 608:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 609:main.c        ****     byte2 = 0x08;
 610:main.c        **** #elif F_IF == 45
 611:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2666               	.LM311:
 2667 0a90 9091 0000 		lds r25,tx_att
 2668 0a94 8091 0000 		lds r24,rx_att
 2669 0a98 28E0      		ldi r18,lo8(8)
 2670 0a9a 829F      		mul r24,r18
 2671 0a9c A001      		movw r20,r0
 2672 0a9e 1124      		clr __zero_reg__
 2673 0aa0 20E4      		ldi r18,lo8(64)
 2674 0aa2 929F      		mul r25,r18
 2675 0aa4 C001      		movw r24,r0
 2676 0aa6 1124      		clr __zero_reg__
 2677 0aa8 482B      		or r20,r24
 606:main.c        **** #if F_IF == 21
 2679               	.LM312:
 2680 0aaa 61E4      		ldi r22,lo8(65)
 2681               	.L149:
 612:main.c        ****     byte2 = 0x88;
 613:main.c        **** #endif
 614:main.c        ****     byte3 = 0x00;
 615:main.c        ****     byte4 = 0x00;
 616:main.c        ****   }
 617:main.c        ****   
 618:main.c        ****   err = TWI_write_5bytes(fpga_addr, byte0, byte1, byte2, byte3, byte4);
 2683               	.LM313:
 2684 0aac E12C      		mov r14,__zero_reg__
 2685 0aae 00E0      		ldi r16,0
 2686 0ab0 28E8      		ldi r18,lo8(-120)
 2687 0ab2 83E2      		ldi r24,lo8(35)
 2688 0ab4 0E94 0000 		call TWI_write_5bytes
 2689               	/* epilogue start */
 619:main.c        ****   if (err)
 620:main.c        ****     return err;
 621:main.c        **** 
 622:main.c        ****   return 0x00;
 623:main.c        **** 
 624:main.c        **** }
 2691               	.LM314:
 2692 0ab8 0F91      		pop r16
 2693 0aba EF90      		pop r14
 2694 0abc 0895      		ret
 2700               	.Lscope27:
 2702               	.global	adcInit
 2704               	adcInit:
 625:main.c        **** 
 626:main.c        **** void adcInit(void) {
 2706               	.LM315:
 2707               	.LFBB28:
 2708               	/* prologue: function */
 2709               	/* frame size = 0 */
 2710               	/* stack size = 0 */
 2711               	.L__stack_usage = 0
 627:main.c        ****   ADCSRA = (1 << ADEN) | (1 << ADFR) | (1 << ADPS2) | (1 << ADPS1); // Free run, /64 -> 77 kHz
 2713               	.LM316:
 2714 0abe 86EA      		ldi r24,lo8(-90)
 2715 0ac0 86B9      		out 0x6,r24
 628:main.c        ****   ADMUX = 0x43; // ADC3, AVCC ref
 2717               	.LM317:
 2718 0ac2 83E4      		ldi r24,lo8(67)
 2719 0ac4 87B9      		out 0x7,r24
 629:main.c        ****   ADCSRA |= (1 << ADSC); // Start conversion
 2721               	.LM318:
 2722 0ac6 369A      		sbi 0x6,6
 2723 0ac8 0895      		ret
 2725               	.Lscope28:
 2727               	.global	Timer0Init
 2729               	Timer0Init:
 630:main.c        **** 
 631:main.c        **** }
 632:main.c        **** 
 633:main.c        **** void Timer0Init(void) {
 2731               	.LM319:
 2732               	.LFBB29:
 2733               	/* prologue: function */
 2734               	/* frame size = 0 */
 2735               	/* stack size = 0 */
 2736               	.L__stack_usage = 0
 634:main.c        **** 
 635:main.c        ****   TCCR0 = 0x0f; // CTC mode, 1024 prescaler
 2738               	.LM320:
 2739 0aca 8FE0      		ldi r24,lo8(15)
 2740 0acc 83BF      		out 0x33,r24
 636:main.c        ****   OCR0 = (uint8_t)10; // 1000000/(1024*10) = 100 Hz, 10ms
 2742               	.LM321:
 2743 0ace 8AE0      		ldi r24,lo8(10)
 2744 0ad0 81BF      		out 0x31,r24
 637:main.c        ****   TIMSK |= (1 << OCIE0); // Interrupt at compare match
 2746               	.LM322:
 2747 0ad2 87B7      		in r24,0x37
 2748 0ad4 8260      		ori r24,lo8(2)
 2749 0ad6 87BF      		out 0x37,r24
 2750 0ad8 0895      		ret
 2752               	.Lscope29:
 2754               	.global	Timer1Init
 2756               	Timer1Init:
 638:main.c        **** }
 639:main.c        **** 
 640:main.c        **** void Timer1Init(void) {
 2758               	.LM323:
 2759               	.LFBB30:
 2760               	/* prologue: function */
 2761               	/* frame size = 0 */
 2762               	/* stack size = 0 */
 2763               	.L__stack_usage = 0
 641:main.c        **** 
 642:main.c        ****   TCCR1A = 0x00;  
 2765               	.LM324:
 2766 0ada 1FBC      		out 0x2f,__zero_reg__
 643:main.c        ****   TCCR1B = 0x0b; // CTC mode, 64 prescaler
 2768               	.LM325:
 2769 0adc 8BE0      		ldi r24,lo8(11)
 2770 0ade 8EBD      		out 0x2e,r24
 644:main.c        ****   OCR1A = (uint16_t)1563; // 1000000/(64*1563) = 10 Hz, 100ms
 2772               	.LM326:
 2773 0ae0 8BE1      		ldi r24,lo8(27)
 2774 0ae2 96E0      		ldi r25,lo8(6)
 2775 0ae4 9BBD      		out 0x2a+1,r25
 2776 0ae6 8ABD      		out 0x2a,r24
 645:main.c        ****   TIMSK |= (1 << OCIE1A); // Interrupt at compare match
 2778               	.LM327:
 2779 0ae8 87B7      		in r24,0x37
 2780 0aea 8061      		ori r24,lo8(16)
 2781 0aec 87BF      		out 0x37,r24
 2782 0aee 0895      		ret
 2784               	.Lscope30:
 2785               		.section	.rodata.str1.1
 2786               	.LC4:
 2787 0015 4572 7220 		.string	"Err %x         "
 2787      2578 2020 
 2787      2020 2020 
 2787      2020 2000 
 2788               	.global	__nesf2
 2789               	.LC5:
 2790 0025 532D 2D2D 		.string	"S---9+++   "
 2790      392B 2B2B 
 2790      2020 2000 
 2791               	.LC6:
 2792 0031 5325 6420 		.string	"S%d         "
 2792      2020 2020 
 2792      2020 2020 
 2792      00
 2793               	.LC7:
 2794 003e 532D 2564 		.string	"S-%d        "
 2794      2020 2020 
 2794      2020 2020 
 2794      00
 2795               	.LC8:
 2796 004b 532D 2D25 		.string	"S--%d       "
 2796      6420 2020 
 2796      2020 2020 
 2796      00
 2797               	.LC9:
 2798 0058 532D 2D2D 		.string	"S---%d      "
 2798      2564 2020 
 2798      2020 2020 
 2798      00
 2799               	.LC10:
 2800 0065 532D 2D2D 		.string	"S----%d     "
 2800      2D25 6420 
 2800      2020 2020 
 2800      00
 2801               	.LC11:
 2802 0072 532D 2D2D 		.string	"S----9+    "
 2802      2D39 2B20 
 2802      2020 2000 
 2803               	.LC12:
 2804 007e 532D 2D2D 		.string	"S----9++   "
 2804      2D39 2B2B 
 2804      2020 2000 
 2805               	.LC13:
 2806 008a 5553 4220 		.string	"USB "
 2806      00
 2807               	.LC14:
 2808 008f 4357 2020 		.string	"CW  "
 2808      00
 2809               	.LC15:
 2810 0094 4357 4E20 		.string	"CWN "
 2810      00
 2811               	.LC16:
 2812 0099 414D 2020 		.string	"AM  "
 2812      00
 2813               	.LC17:
 2814 009e 464D 2020 		.string	"FM  "
 2814      00
 2815               	.LC18:
 2816 00a3 4C53 4220 		.string	"LSB "
 2816      00
 2817               	.global	__ltsf2
 2818               	.LC19:
 2819 00a8 4572 7220 		.string	"Err freq %x         "
 2819      6672 6571 
 2819      2025 7820 
 2819      2020 2020 
 2819      2020 2020 
 2820               	.LC20:
 2821 00bd 4572 7220 		.string	"Err sett %x         "
 2821      7365 7474 
 2821      2025 7820 
 2821      2020 2020 
 2821      2020 2020 
 2822               	.LC21:
 2823 00d2 566F 6C20 		.string	"Vol %d    "
 2823      2564 2020 
 2823      2020 00
 2824               	.LC22:
 2825 00dd 4572 7220 		.string	"Err Vol %x         "
 2825      566F 6C20 
 2825      2578 2020 
 2825      2020 2020 
 2825      2020 2000 
 2826               	.LC23:
 2827 00f1 5371 2025 		.string	"Sq %d    "
 2827      6420 2020 
 2827      2000 
 2828               	.LC24:
 2829 00fb 4572 7220 		.string	"Err Sq %x         "
 2829      5371 2025 
 2829      7820 2020 
 2829      2020 2020 
 2829      2020 00
 2830               		.section	.text.startup,"ax",@progbits
 2832               	.global	main
 2834               	main:
 646:main.c        **** }
 647:main.c        **** 
 648:main.c        **** int main(void)
 649:main.c        **** {
 2836               	.LM328:
 2837               	.LFBB31:
 2838 0000 CF93      		push r28
 2839 0002 DF93      		push r29
 2840 0004 CDB7      		in r28,__SP_L__
 2841 0006 DEB7      		in r29,__SP_H__
 2842 0008 C354      		subi r28,67
 2843 000a D109      		sbc r29,__zero_reg__
 2844 000c 0FB6      		in __tmp_reg__,__SREG__
 2845 000e F894      		cli
 2846 0010 DEBF      		out __SP_H__,r29
 2847 0012 0FBE      		out __SREG__,__tmp_reg__
 2848 0014 CDBF      		out __SP_L__,r28
 2849               	/* prologue: function */
 2850               	/* frame size = 67 */
 2851               	/* stack size = 69 */
 2852               	.L__stack_usage = 69
 650:main.c        ****   char buffer[60];
 651:main.c        ****   double freq_last;
 652:main.c        ****   int16_t clarval, clarval_last;
 653:main.c        ****   uint8_t err, data;
 654:main.c        ****   uint8_t rssi, rssi_max=0, rssi_count=0;
 655:main.c        ****   uint8_t last_dir;
 656:main.c        ****   uint8_t squelch = 0;
 657:main.c        ****   uint8_t tx_last = 255;
 658:main.c        ****   uint8_t vol = 0x18;
 659:main.c        ****   uint16_t steps;
 660:main.c        ****   
 661:main.c        ****   static const char string_intro_row1[] PROGMEM = "*** SM6VFZ";
 662:main.c        ****   static const char string_intro_row2[] PROGMEM = "Starting radio";
 663:main.c        **** 
 664:main.c        ****   DDRA = 0xFF;
 2854               	.LM329:
 2855 0016 8FEF      		ldi r24,lo8(-1)
 2856 0018 8ABB      		out 0x1a,r24
 665:main.c        ****   DDRB = 0xFF;
 2858               	.LM330:
 2859 001a 87BB      		out 0x17,r24
 666:main.c        ****   DDRC = 0xFF;
 2861               	.LM331:
 2862 001c 84BB      		out 0x14,r24
 667:main.c        ****   DDRD = ~(uint8_t)((1 << ROT2_A)|(1 << ROT2_B));
 2864               	.LM332:
 2865 001e 93EF      		ldi r25,lo8(-13)
 2866 0020 91BB      		out 0x11,r25
 668:main.c        ****   DDRE = ~(uint8_t)((1 << ROT1_A)|(1 << ROT1_B)|(1 << VOLROT_A)|(1 << VOLROT_B)|(1 << FREQ_BUTTON))
 2868               	.LM333:
 2869 0022 97E0      		ldi r25,lo8(7)
 2870 0024 92B9      		out 0x2,r25
 669:main.c        ****   DDRF = ~(uint8_t)((1 << VOL_BUTTON)|(1 << MODE_BUTTON)|(1 << BAND_BUTTON)|(1 << CLAR_POT)|(1 << M
 2872               	.LM334:
 2873 0026 90EE      		ldi r25,lo8(-32)
 2874 0028 9093 6100 		sts 97,r25
 670:main.c        ****   DDRG = 0xFF;  
 2876               	.LM335:
 2877 002c 8093 6400 		sts 100,r24
 671:main.c        **** 	
 672:main.c        ****   PORTA = 0x00;
 2879               	.LM336:
 2880 0030 1BBA      		out 0x1b,__zero_reg__
 673:main.c        ****   PORTB = 0x00;
 2882               	.LM337:
 2883 0032 18BA      		out 0x18,__zero_reg__
 674:main.c        ****   PORTC = 0x00;
 2885               	.LM338:
 2886 0034 15BA      		out 0x15,__zero_reg__
 675:main.c        ****   PORTD = (uint8_t)((1 << ROT2_A)|(1 << ROT2_B));
 2888               	.LM339:
 2889 0036 8CE0      		ldi r24,lo8(12)
 2890 0038 82BB      		out 0x12,r24
 676:main.c        ****   PORTE = (uint8_t)((1 << ROT1_A)|(1 << ROT1_B)|(1 << VOLROT_A)|(1 << VOLROT_B)|(1 << FREQ_BUTTON)|
 2892               	.LM340:
 2893 003a 88EF      		ldi r24,lo8(-8)
 2894 003c 83B9      		out 0x3,r24
 677:main.c        ****   PORTF = (uint8_t)((1 << VOL_BUTTON)|(1 << MODE_BUTTON)|(1 << BAND_BUTTON)|(1 << MODE_BUTTON)|(1 <
 2896               	.LM341:
 2897 003e 83E1      		ldi r24,lo8(19)
 2898 0040 8093 6200 		sts 98,r24
 678:main.c        ****   PORTG = 0x00;
 2900               	.LM342:
 2901 0044 1092 6500 		sts 101,__zero_reg__
 679:main.c        **** 	
 680:main.c        ****   // turn off the analog comparator
 681:main.c        ****   ACSR = 0x40U;
 2903               	.LM343:
 2904 0048 80E4      		ldi r24,lo8(64)
 2905 004a 88B9      		out 0x8,r24
 682:main.c        **** 	
 683:main.c        ****   // turn off SPI, TWI and USART0
 684:main.c        ****   //PRR  = 0x86U;
 685:main.c        **** 	
 686:main.c        ****   EICRA = (1<<ISC21)|(1<<ISC31);
 2907               	.LM344:
 2908 004c 80EA      		ldi r24,lo8(-96)
 2909 004e 8093 6A00 		sts 106,r24
 687:main.c        ****   EICRB = (1<<ISC41)|(1<<ISC51)|(1<<ISC61)|(1<<ISC71);
 2911               	.LM345:
 2912 0052 8AEA      		ldi r24,lo8(-86)
 2913 0054 8ABF      		out 0x3a,r24
 688:main.c        **** 
 689:main.c        ****   EIMSK = (1 << INTF2)|(1 << INTF3)|(1 << INTF4)|(1 << INTF5)|(1 << INTF6)|(1 << INTF7);
 2915               	.LM346:
 2916 0056 8CEF      		ldi r24,lo8(-4)
 2917 0058 89BF      		out 0x39,r24
 2918               	.LBB481:
 2919               	.LBB482:
 2921               	.Ltext37:
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** 
 102:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 103:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** #else
 105:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 106:/usr/lib/avr/include/avr/wdt.h **** #endif
 107:/usr/lib/avr/include/avr/wdt.h **** 
 108:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 109:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 110:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 111:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 112:/usr/lib/avr/include/avr/wdt.h **** #else
 113:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 114:/usr/lib/avr/include/avr/wdt.h **** #endif
 115:/usr/lib/avr/include/avr/wdt.h **** 
 116:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 117:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 118:/usr/lib/avr/include/avr/wdt.h **** #else
 119:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 120:/usr/lib/avr/include/avr/wdt.h **** #endif
 121:/usr/lib/avr/include/avr/wdt.h **** 
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** /**
 124:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 125:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 126:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 127:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 128:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 129:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 130:/usr/lib/avr/include/avr/wdt.h **** 
 131:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 132:/usr/lib/avr/include/avr/wdt.h **** */
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h **** 
 135:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** /*
 138:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 139:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 140:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 141:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 142:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 143:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 144:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 145:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 146:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 147:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 148:/usr/lib/avr/include/avr/wdt.h **** */
 149:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 150:/usr/lib/avr/include/avr/wdt.h **** do { \
 151:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 152:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 153:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 155:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 156:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 157:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 158:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 159:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 160:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 161:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 162:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 163:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 164:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 165:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 166:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 167:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 168:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 169:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 170:/usr/lib/avr/include/avr/wdt.h **** ); \
 171:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 172:/usr/lib/avr/include/avr/wdt.h **** 
 173:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 174:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 175:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 176:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 177:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 178:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 179:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 180:/usr/lib/avr/include/avr/wdt.h ****     : \
 181:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 182:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 183:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 184:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 185:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 186:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 187:/usr/lib/avr/include/avr/wdt.h **** );
 188:/usr/lib/avr/include/avr/wdt.h **** 
 189:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 190:/usr/lib/avr/include/avr/wdt.h **** 
 191:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 192:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 193:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 194:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 195:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 196:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 197:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 198:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 199:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 200:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 201:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 202:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 203:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 204:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 205:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 206:/usr/lib/avr/include/avr/wdt.h **** )
 207:/usr/lib/avr/include/avr/wdt.h **** 
 208:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 209:/usr/lib/avr/include/avr/wdt.h **** do { \
 210:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 211:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 212:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 213:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 214:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 215:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 216:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 217:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 218:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 219:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 220:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 221:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 222:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 223:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 224:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 225:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 226:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 227:/usr/lib/avr/include/avr/wdt.h **** ); \
 228:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 229:/usr/lib/avr/include/avr/wdt.h **** 
 230:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 231:/usr/lib/avr/include/avr/wdt.h **** 
 232:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 233:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 234:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 235:/usr/lib/avr/include/avr/wdt.h **** {
 236:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 237:/usr/lib/avr/include/avr/wdt.h **** 	{
 238:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 239:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 240:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 241:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 242:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 243:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 244:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 245:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 246:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 247:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 248:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 249:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 250:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 251:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 252:/usr/lib/avr/include/avr/wdt.h **** 			);
 253:/usr/lib/avr/include/avr/wdt.h **** 	}
 254:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 255:/usr/lib/avr/include/avr/wdt.h **** 	{
 256:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 257:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 258:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 259:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 260:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 261:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 262:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 263:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 264:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 265:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 266:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 267:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 268:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 269:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 270:/usr/lib/avr/include/avr/wdt.h **** 			);
 271:/usr/lib/avr/include/avr/wdt.h **** 	}
 272:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 273:/usr/lib/avr/include/avr/wdt.h **** 	{
 274:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 275:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 276:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 277:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 278:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 279:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 280:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 281:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 282:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 283:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 284:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 285:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 286:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 287:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 288:/usr/lib/avr/include/avr/wdt.h **** 			);
 289:/usr/lib/avr/include/avr/wdt.h **** 	}
 290:/usr/lib/avr/include/avr/wdt.h **** 	else
 291:/usr/lib/avr/include/avr/wdt.h ****  	{
 292:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 293:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 294:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 295:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 296:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 297:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 298:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 299:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 300:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 301:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 302:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 303:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 304:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 305:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 306:/usr/lib/avr/include/avr/wdt.h **** 			);
 307:/usr/lib/avr/include/avr/wdt.h **** 	}
 308:/usr/lib/avr/include/avr/wdt.h **** }
 309:/usr/lib/avr/include/avr/wdt.h **** 
 310:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 311:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 312:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 313:/usr/lib/avr/include/avr/wdt.h **** {
 314:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 315:/usr/lib/avr/include/avr/wdt.h **** 	{
 316:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 317:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 318:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 319:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 320:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 321:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 322:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 323:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 327:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 328:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 329:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 330:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 331:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 332:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 333:/usr/lib/avr/include/avr/wdt.h **** 				);
 334:/usr/lib/avr/include/avr/wdt.h **** 	}
 335:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 336:/usr/lib/avr/include/avr/wdt.h **** 	{
 337:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 338:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 339:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 340:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 341:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 348:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 352:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 353:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 				);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 357:/usr/lib/avr/include/avr/wdt.h **** 	{
 358:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 359:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 360:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 361:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 362:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 363:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 364:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 365:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 366:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 369:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 370:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 371:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 372:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 373:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 374:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 375:/usr/lib/avr/include/avr/wdt.h **** 				);
 376:/usr/lib/avr/include/avr/wdt.h **** 	}
 377:/usr/lib/avr/include/avr/wdt.h **** 	else
 378:/usr/lib/avr/include/avr/wdt.h **** 	{
 379:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 380:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 381:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 382:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 383:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 384:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 385:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 386:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 387:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 390:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 391:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 392:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 393:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 394:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 395:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 396:/usr/lib/avr/include/avr/wdt.h **** 				);
 397:/usr/lib/avr/include/avr/wdt.h **** 	}
 398:/usr/lib/avr/include/avr/wdt.h **** }
 399:/usr/lib/avr/include/avr/wdt.h **** 
 400:/usr/lib/avr/include/avr/wdt.h **** #else
 401:/usr/lib/avr/include/avr/wdt.h **** 
 402:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 403:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 404:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 405:/usr/lib/avr/include/avr/wdt.h **** {
 406:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 407:/usr/lib/avr/include/avr/wdt.h **** 	{
 408:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 409:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 416:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 417:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 418:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 419:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 420:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 421:/usr/lib/avr/include/avr/wdt.h **** 		);
 422:/usr/lib/avr/include/avr/wdt.h **** 	}
 423:/usr/lib/avr/include/avr/wdt.h **** 	else
 424:/usr/lib/avr/include/avr/wdt.h **** 	{
 425:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 426:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 427:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 428:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 429:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 433:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 434:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 435:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 436:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 437:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 438:/usr/lib/avr/include/avr/wdt.h **** 		);
 439:/usr/lib/avr/include/avr/wdt.h **** 	}
 440:/usr/lib/avr/include/avr/wdt.h **** }
 441:/usr/lib/avr/include/avr/wdt.h **** 
 442:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 443:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 444:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 445:/usr/lib/avr/include/avr/wdt.h **** {
 446:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 447:/usr/lib/avr/include/avr/wdt.h **** 	{
 448:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 449:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2923               	.LM347:
 2924               	/* #APP */
 2925               	 ;  449 "/usr/lib/avr/include/avr/wdt.h" 1
 2926 005a 0FB6      		in __tmp_reg__,__SREG__
 2927 005c F894      		cli
 2928 005e A895      		wdr
 2929 0060 81B5      		in  r24,33
 2930 0062 8861      		ori r24,24
 2931 0064 81BD      		out 33,r24
 2932 0066 11BC      		out 33,__zero_reg__
 2933 0068 0FBE      		out __SREG__,__tmp_reg__
 2934               		
 2935               	 ;  0 "" 2
 2936               	/* #NOAPP */
 2937               	.LBE482:
 2938               	.LBE481:
 2939               	.LBB483:
 2940               	.LBB484:
 2942               	.Ltext38:
 163:/usr/lib/avr/include/util/delay.h **** 
 2944               	.LM348:
 2945 006a 2FE9      		ldi r18,lo8(99999)
 2946 006c 86E8      		ldi r24,hi8(99999)
 2947 006e 91E0      		ldi r25,hlo8(99999)
 2948 0070 2150      	1:	subi r18,1
 2949 0072 8040      		sbci r24,0
 2950 0074 9040      		sbci r25,0
 2951 0076 01F4      		brne 1b
 2952 0078 00C0      		rjmp .
 2953 007a 0000      		nop
 2954               	.LBE484:
 2955               	.LBE483:
 2957               	.Ltext39:
 690:main.c        **** 
 691:main.c        ****   wdt_disable();
 692:main.c        **** 
 693:main.c        ****   _delay_ms(500);
 694:main.c        **** 
 695:main.c        ****   PORTD |= (1 << LED_RED) | (1 << LED_GREEN);
 2959               	.LM349:
 2960 007c 82B3      		in r24,0x12
 2961 007e 8066      		ori r24,lo8(96)
 2962 0080 82BB      		out 0x12,r24
 696:main.c        **** 
 697:main.c        ****   TIMSK = 0;
 2964               	.LM350:
 2965 0082 17BE      		out 0x37,__zero_reg__
 698:main.c        ****   Timer0Init();
 2967               	.LM351:
 2968 0084 0E94 0000 		call Timer0Init
 699:main.c        ****   Timer1Init();
 2970               	.LM352:
 2971 0088 0E94 0000 		call Timer1Init
 700:main.c        ****   TWIinit();
 2973               	.LM353:
 2974 008c 0E94 0000 		call TWIinit
 701:main.c        ****   lcd_init();
 2976               	.LM354:
 2977 0090 0E94 0000 		call lcd_init
 702:main.c        ****   lcd_clrscr();
 2979               	.LM355:
 2980 0094 0E94 0000 		call lcd_clrscr
 703:main.c        ****   adcInit();
 2982               	.LM356:
 2983 0098 0E94 0000 		call adcInit
 2984               	.LBB485:
 2985               	.LBB486:
 2987               	.Ltext40:
 163:/usr/lib/avr/include/util/delay.h **** 
 2989               	.LM357:
 2990 009c AFE4      		ldi r26,lo8(-15537)
 2991 009e B3EC      		ldi r27,hi8(-15537)
 2992 00a0 1197      	1:	sbiw r26,1
 2993 00a2 01F4      		brne 1b
 2994 00a4 00C0      		rjmp .
 2995 00a6 0000      		nop
 2996               	.LBE486:
 2997               	.LBE485:
 2999               	.Ltext41:
 704:main.c        **** 
 705:main.c        ****   _delay_ms(200);
 706:main.c        **** 
 707:main.c        ****   PORTD &= ~((1 << LED_RED) | (1 << LED_GREEN));
 3001               	.LM358:
 3002 00a8 82B3      		in r24,0x12
 3003 00aa 8F79      		andi r24,lo8(-97)
 3004 00ac 82BB      		out 0x12,r24
 708:main.c        **** 
 709:main.c        ****   strcpy_P(buffer, string_intro_row1);
 3006               	.LM359:
 3007 00ae 60E0      		ldi r22,lo8(string_intro_row1.2453)
 3008 00b0 70E0      		ldi r23,hi8(string_intro_row1.2453)
 3009 00b2 8E01      		movw r16,r28
 3010 00b4 0F5F      		subi r16,-1
 3011 00b6 1F4F      		sbci r17,-1
 3012 00b8 C801      		movw r24,r16
 3013 00ba 0E94 0000 		call strcpy_P
 710:main.c        ****   lcd_puts(buffer);
 3015               	.LM360:
 3016 00be C801      		movw r24,r16
 3017 00c0 0E94 0000 		call lcd_puts
 711:main.c        ****   lcd_goto(0x40);
 3019               	.LM361:
 3020 00c4 80E4      		ldi r24,lo8(64)
 3021 00c6 0E94 0000 		call lcd_goto
 712:main.c        ****   strcpy_P(buffer, string_intro_row2);
 3023               	.LM362:
 3024 00ca 60E0      		ldi r22,lo8(string_intro_row2.2454)
 3025 00cc 70E0      		ldi r23,hi8(string_intro_row2.2454)
 3026 00ce C801      		movw r24,r16
 3027 00d0 0E94 0000 		call strcpy_P
 713:main.c        ****   lcd_puts(buffer);
 3029               	.LM363:
 3030 00d4 C801      		movw r24,r16
 3031 00d6 0E94 0000 		call lcd_puts
 714:main.c        **** 
 715:main.c        ****   rot_flag = 0x01;
 3033               	.LM364:
 3034 00da 81E0      		ldi r24,lo8(1)
 3035 00dc 8093 0000 		sts rot_flag,r24
 716:main.c        ****   mode_flag = 0x01;
 3037               	.LM365:
 3038 00e0 8093 0000 		sts mode_flag,r24
 717:main.c        ****   band_flag = 0x02;
 3040               	.LM366:
 3041 00e4 82E0      		ldi r24,lo8(2)
 3042 00e6 8093 0000 		sts band_flag,r24
 718:main.c        ****   timer_flag = 0x00;
 3044               	.LM367:
 3045 00ea 1092 0000 		sts timer_flag,__zero_reg__
 719:main.c        **** 
 720:main.c        ****   band = 10;
 3047               	.LM368:
 3048 00ee 8AE0      		ldi r24,lo8(10)
 3049 00f0 8093 0000 		sts band,r24
 721:main.c        ****   freq = 7010;
 3051               	.LM369:
 3052 00f4 80E0      		ldi r24,0
 3053 00f6 90E1      		ldi r25,lo8(16)
 3054 00f8 ABED      		ldi r26,lo8(-37)
 3055 00fa B5E4      		ldi r27,lo8(69)
 3056 00fc 8093 0000 		sts freq,r24
 3057 0100 9093 0000 		sts freq+1,r25
 3058 0104 A093 0000 		sts freq+2,r26
 3059 0108 B093 0000 		sts freq+3,r27
 722:main.c        ****   step_timer = 255;
 3061               	.LM370:
 3062 010c 8FEF      		ldi r24,lo8(-1)
 3063 010e 90E0      		ldi r25,0
 3064 0110 9093 0000 		sts step_timer+1,r25
 3065 0114 8093 0000 		sts step_timer,r24
 723:main.c        ****   steps = 0;
 724:main.c        ****   last_dir = 0x00;
 725:main.c        ****   mode = 0x00;
 3067               	.LM371:
 3068 0118 1092 0000 		sts mode,__zero_reg__
 726:main.c        ****   tx = 0x0000;
 3070               	.LM372:
 3071 011c 1092 0000 		sts tx+1,__zero_reg__
 3072 0120 1092 0000 		sts tx,__zero_reg__
 727:main.c        ****   rx_att = 0x00;
 3074               	.LM373:
 3075 0124 1092 0000 		sts rx_att,__zero_reg__
 728:main.c        ****   tx_att = 0x00;
 3077               	.LM374:
 3078 0128 1092 0000 		sts tx_att,__zero_reg__
 729:main.c        ****   rffe_rx_att = false;
 3080               	.LM375:
 3081 012c 1092 0000 		sts rffe_rx_att,__zero_reg__
 730:main.c        **** 
 731:main.c        ****   err = updateVolumeSquelch(vol, squelch);
 3083               	.LM376:
 3084 0130 60E0      		ldi r22,0
 3085 0132 88E1      		ldi r24,lo8(24)
 3086 0134 0E94 0000 		call updateVolumeSquelch
 3087               	.LBB487:
 3088               	.LBB488:
 3090               	.Ltext42:
 163:/usr/lib/avr/include/util/delay.h **** 
 3092               	.LM377:
 3093 0138 BFE7      		ldi r27,lo8(399999)
 3094 013a 2AE1      		ldi r18,hi8(399999)
 3095 013c 86E0      		ldi r24,hlo8(399999)
 3096 013e B150      	1:	subi r27,1
 3097 0140 2040      		sbci r18,0
 3098 0142 8040      		sbci r24,0
 3099 0144 01F4      		brne 1b
 3100 0146 00C0      		rjmp .
 3101 0148 0000      		nop
 3102               	.LBE488:
 3103               	.LBE487:
 3105               	.Ltext43:
 732:main.c        ****   
 733:main.c        ****   _delay_ms(2000);
 734:main.c        **** 
 735:main.c        ****   lcd_clrscr();
 3107               	.LM378:
 3108 014a 0E94 0000 		call lcd_clrscr
 736:main.c        ****   
 737:main.c        ****   sei();
 3110               	.LM379:
 3111               	/* #APP */
 3112               	 ;  737 "main.c" 1
 3113 014e 7894      		sei
 3114               	 ;  0 "" 2
 723:main.c        ****   last_dir = 0x00;
 3116               	.LM380:
 3117               	/* #NOAPP */
 3118 0150 C12C      		mov r12,__zero_reg__
 3119 0152 D12C      		mov r13,__zero_reg__
 658:main.c        ****   uint16_t steps;
 3121               	.LM381:
 3122 0154 38E1      		ldi r19,lo8(24)
 3123 0156 A32E      		mov r10,r19
 657:main.c        ****   uint8_t vol = 0x18;
 3125               	.LM382:
 3126 0158 9FEF      		ldi r25,lo8(-1)
 3127 015a 9EAF      		std Y+62,r25
 656:main.c        ****   uint8_t tx_last = 255;
 3129               	.LM383:
 3130 015c B12C      		mov r11,__zero_reg__
 724:main.c        ****   mode = 0x00;
 3132               	.LM384:
 3133 015e 1FAE      		std Y+63,__zero_reg__
 654:main.c        ****   uint8_t last_dir;
 3135               	.LM385:
 3136 0160 E12C      		mov r14,__zero_reg__
 3137 0162 F12C      		mov r15,__zero_reg__
 738:main.c        **** 
 739:main.c        ****   while (1) {
 740:main.c        ****     if (timer_flag) {
 741:main.c        **** 
 742:main.c        **** #ifdef CLARPOT
 743:main.c        ****       clarval = readClar();
 744:main.c        **** #endif
 745:main.c        **** #ifndef CLARPOT
 746:main.c        ****       clarval = 0;
 747:main.c        **** #endif
 748:main.c        **** 
 749:main.c        ****       if ((clarval < clarval_last - 10) || (clarval > clarval_last + 10)) {
 750:main.c        **** 	clar = (int8_t)((clarval - 512) >> 2);
 751:main.c        **** 	err = updateFreq(0);
 752:main.c        **** 	if (err) {
 753:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 754:main.c        **** 	  lcd_goto(0x40);
 755:main.c        **** 	  lcd_puts(buffer);	
 756:main.c        **** 	}
 757:main.c        **** 	else {
 758:main.c        **** 	  lcd_freq();
 759:main.c        **** 	}
 760:main.c        **** 	clarval_last = clarval;
 761:main.c        ****       }
 762:main.c        **** 
 763:main.c        ****       if (vol_timer < 255)
 764:main.c        **** 	vol_timer ++;
 765:main.c        **** 
 766:main.c        ****       // Band button
 767:main.c        **** 
 768:main.c        ****       if (band_timer < 9) { // Recently pressed ?
 769:main.c        **** 	band_timer ++;
 770:main.c        **** 	if ((band_timer < 9) && (PINF & (1 << BAND_BUTTON))) {
 771:main.c        **** 	  band_flag = 0x01; // short press
 772:main.c        **** 	  band_timer = 255;
 773:main.c        **** 	}
 774:main.c        **** 	if ((band_timer == 9) && (!(PINF & (1 << BAND_BUTTON)))) 
 775:main.c        **** 	  band_flag = 0x02; // long press
 776:main.c        ****       }
 777:main.c        ****       else if (!(PINF & (1 << BAND_BUTTON))) {  // New press
 778:main.c        **** 	band_timer = 0;
 779:main.c        ****       }
 780:main.c        **** 
 781:main.c        ****       // Mode button
 782:main.c        **** 
 783:main.c        ****       if (!(PINF & (1 << MODE_BUTTON))) {
 784:main.c        **** 	mode_flag = 0x01;
 785:main.c        ****       }
 786:main.c        ****       
 787:main.c        ****       // Update frequency if necessary:
 788:main.c        ****       if (freq != freq_last) {
 789:main.c        **** 	lcd_freq();
 790:main.c        **** 	err = updateFreq(1);
 791:main.c        **** 	if (err) {
 792:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 793:main.c        **** 	  lcd_goto(0x40);
 794:main.c        **** 	  lcd_puts(buffer);	
 795:main.c        **** 	}
 796:main.c        **** 	freq_last = freq;
 797:main.c        ****       }
 798:main.c        **** 
 799:main.c        ****       // Read RSSI and status:
 800:main.c        ****       err = TWI_read_byte(fpga_addr, &data);
 801:main.c        ****       if (!err) {
 802:main.c        **** 	if ((data & 0x80) && (tx_last != 1)) { // Shift to TX ?
 803:main.c        **** 	  tx = 0x0001;
 804:main.c        **** 	  updateRFFE();
 805:main.c        **** 	  PORTD |= (1 << LED_RED);
 806:main.c        **** 	  PORTD &= ~(1 << LED_GREEN);
 807:main.c        **** 	  tx_last = 1;
 808:main.c        **** 	}
 809:main.c        **** 	else if (!(data & 0x80) && (tx_last != 0)) { // Shift to RX ?
 810:main.c        **** 	  tx = 0x0000;
 811:main.c        **** 	  updateRFFE();
 812:main.c        **** 	  PORTD |= (1 << LED_GREEN);
 813:main.c        **** 	  PORTD &= ~(1 << LED_RED);
 814:main.c        **** 	  tx_last = 0;
 815:main.c        **** 	}
 816:main.c        ****       }
 817:main.c        ****       else { // error
 818:main.c        **** 	PORTD &= ~((1 << LED_RED)|(1 << LED_GREEN));
 819:main.c        ****       }
 820:main.c        **** 
 821:main.c        ****       rssi = (0x3f & data); 
 822:main.c        ****       if (rssi_max < rssi) 
 823:main.c        **** 	rssi_max = rssi;
 824:main.c        ****       rssi_count ++;
 825:main.c        ****       if ((!rffe_rx_att && rssi_count > 2) || (rffe_rx_att && rssi_count > 2)) {
 826:main.c        **** 	rssi_count = 0;
 827:main.c        **** 	if (rssi_max < 4)
 828:main.c        **** 	  rssi = 0;
 829:main.c        **** 	else 
 830:main.c        **** 	  rssi = rssi_max - 4;
 831:main.c        **** 	rssi_max = 0;
 832:main.c        **** 
 833:main.c        **** 	if (vol_timer < 10); // Don't print if vol info
 834:main.c        **** 	else if (rffe_rx_att && (rssi>9)) {
 835:main.c        **** 	  sprintf(buffer,"S---9+++   ");
 836:main.c        **** 	  lcd_goto(0x40);
 837:main.c        **** 	  lcd_puts(buffer);
 838:main.c        **** 	}
 839:main.c        **** 	else if (rffe_rx_att && (rssi < 10)) {
 840:main.c        **** 	  rffe_rx_att = false;
 841:main.c        **** 	  err = updateRFFE();
 842:main.c        **** 	}
 843:main.c        **** 	else if (rssi < 2) { 
 844:main.c        **** 	  sprintf(buffer,"S%d         ",rssi);
 845:main.c        **** 	  lcd_goto(0x40);
 846:main.c        **** 	  lcd_puts(buffer);
 847:main.c        **** 	}
 848:main.c        **** 	else if (rssi < 4) {
 849:main.c        **** 	  sprintf(buffer,"S-%d        ",rssi);
 850:main.c        **** 	  lcd_goto(0x40);
 851:main.c        **** 	  lcd_puts(buffer);
 852:main.c        ****  	}
 853:main.c        **** 	else if (rssi < 6) {
 854:main.c        **** 	  sprintf(buffer,"S--%d       ",rssi);
 855:main.c        **** 	  lcd_goto(0x40);
 856:main.c        **** 	  lcd_puts(buffer);
 857:main.c        **** 	}
 858:main.c        **** 	else if (rssi < 8) {
 859:main.c        **** 	  sprintf(buffer,"S---%d      ",rssi);
 860:main.c        **** 	  lcd_goto(0x40);
 861:main.c        **** 	  lcd_puts(buffer);
 862:main.c        **** 	}
 863:main.c        **** 	else if (rssi < 10) {
 864:main.c        **** 	  sprintf(buffer,"S----%d     ",rssi);
 865:main.c        **** 	  lcd_goto(0x40);
 866:main.c        **** 	  lcd_puts(buffer);
 867:main.c        **** 	}
 868:main.c        **** 	else if (rssi < 12) {
 869:main.c        **** 	  sprintf(buffer,"S----9+    ");
 870:main.c        **** 	  lcd_goto(0x40);
 871:main.c        **** 	  lcd_puts(buffer);
 872:main.c        **** 	}
 873:main.c        **** 	else if (rssi < 13 ){
 874:main.c        **** 	  sprintf(buffer,"S----9++   ");
 875:main.c        **** 	  lcd_goto(0x40);
 876:main.c        **** 	  lcd_puts(buffer);
 877:main.c        **** 	}
 878:main.c        **** 	else {
 879:main.c        **** 	  rffe_rx_att = true;
 880:main.c        **** 	  err = updateRFFE();
 881:main.c        **** 	}
 882:main.c        **** 	rssi = 0;
 883:main.c        ****       }
 884:main.c        ****       timer_flag = 0;
 885:main.c        ****     }
 886:main.c        ****     else if (mode_flag) {
 887:main.c        ****       switch (mode) {
 888:main.c        ****       case LSB:
 889:main.c        **** 	mode = USB;
 890:main.c        **** 	if (!updateSettings()) { 
 891:main.c        **** 	  lcd_goto(0x00);
 892:main.c        **** 	  sprintf(buffer,"USB ");
 893:main.c        **** 	  lcd_puts(buffer);
 894:main.c        **** 	}
 895:main.c        **** 	break;
 896:main.c        ****       case USB:
 897:main.c        **** 	mode = CW;
 898:main.c        **** 	if(!updateSettings()) {
 899:main.c        **** 	  lcd_goto(0x00);
 900:main.c        **** 	  sprintf(buffer,"CW  ");
 901:main.c        **** 	  lcd_puts(buffer);
 902:main.c        **** 	}
 903:main.c        **** 	break;
 904:main.c        ****       case CW:
 905:main.c        **** 	mode = CWN;
 906:main.c        **** 	if(!updateSettings()) {
 907:main.c        **** 	  lcd_goto(0x00);
 908:main.c        **** 	  sprintf(buffer,"CWN ");
 909:main.c        **** 	  lcd_puts(buffer);
 910:main.c        **** 	}
 911:main.c        **** 	break;
 912:main.c        ****       case CWN:
 913:main.c        **** 	if (band < 200) {
 914:main.c        **** 	  mode = AM;
 915:main.c        **** 	  if(!updateSettings()) {
 916:main.c        **** 	    lcd_goto(0x00);
 917:main.c        **** 	    sprintf(buffer,"AM  ");
 918:main.c        **** 	    lcd_puts(buffer);
 919:main.c        **** 	  }
 920:main.c        **** 	}
 921:main.c        **** 	else {
 922:main.c        **** 	  mode = FM;
 923:main.c        **** 	  if(!updateSettings()) {
 924:main.c        **** 	    lcd_goto(0x00);
 925:main.c        **** 	    sprintf(buffer,"FM  ");
 926:main.c        **** 	    lcd_puts(buffer);
 927:main.c        **** 	  }
 928:main.c        **** 	}	  
 929:main.c        **** 	break;
 930:main.c        ****       case AM:
 931:main.c        ****       case FM:
 932:main.c        ****       default:
 933:main.c        **** 	mode = LSB;
 934:main.c        **** 	if(!updateSettings()) { 
 935:main.c        **** 	  lcd_goto(0x00);
 936:main.c        **** 	  sprintf(buffer,"LSB ");
 937:main.c        **** 	  lcd_puts(buffer);
 938:main.c        **** 	}
 939:main.c        **** 	break;
 940:main.c        ****       }
 941:main.c        ****       _delay_ms(250);
 942:main.c        ****       err = updateFreq(1);  // To shift +/-
 943:main.c        ****       mode_flag = 0x00;
 944:main.c        ****     }
 945:main.c        **** 
 946:main.c        ****     if (band_flag) {
 947:main.c        ****       if (band_flag == 0x02) { // long press
 948:main.c        **** #ifdef TWOMETER_TRANSV
 949:main.c        **** 	if (band == 200) {
 950:main.c        **** 	  band = 201;
 951:main.c        **** 	  freq_offset = 1152;
 952:main.c        **** 	  freq = 144200;
 953:main.c        **** 	  tx_att = 0x01;
 954:main.c        **** 	  rx_att = 0x00;
 955:main.c        **** 	  updateSettings();
 956:main.c        **** 	}
 957:main.c        **** 	else if (band == 201) {
 958:main.c        **** 	  band = 202;
 959:main.c        **** 	  freq_offset = 5616;
 960:main.c        **** 	  freq = 144200;
 961:main.c        **** 	  tx_att = 0x01;
 962:main.c        **** 	  rx_att = 0x00;
 963:main.c        **** 	  updateSettings();
 964:main.c        **** 	}
 965:main.c        **** 	else {
 966:main.c        **** 	  band = 200;
 967:main.c        **** 	  freq_offset = 0;
 968:main.c        **** 	  freq = 144300;
 969:main.c        **** 	  tx_att = 0x00;
 970:main.c        **** 	  rx_att = 0x00;
 971:main.c        **** 	  updateSettings();
 972:main.c        **** 	  /*
 973:main.c        **** 	  band = 160;
 974:main.c        **** 	  freq_offset = 0;
 975:main.c        **** 	  freq = 1810;
 976:main.c        **** 	  tx_att = 0x00;
 977:main.c        **** 	  */
 978:main.c        **** 	}
 979:main.c        **** #endif
 980:main.c        ****       }
 981:main.c        ****       else {
 982:main.c        **** #ifdef HF_HAM
 983:main.c        **** 	if (freq<3500)
 984:main.c        **** 	  freq = 3510;
 3139               	.LM386:
 3140 0164 412C      		mov r4,__zero_reg__
 3141 0166 40E6      		ldi r20,lo8(96)
 3142 0168 542E      		mov r5,r20
 3143 016a 4BE5      		ldi r20,lo8(91)
 3144 016c 642E      		mov r6,r20
 3145 016e 45E4      		ldi r20,lo8(69)
 3146 0170 742E      		mov r7,r20
 3147               	.L161:
 740:main.c        **** 
 3149               	.LM387:
 3150 0172 8091 0000 		lds r24,timer_flag
 3151 0176 8823      		tst r24
 3152 0178 01F4      		brne .+2
 3153 017a 00C0      		rjmp .L162
 3154               	.LBB489:
 3155               	.LBB490:
 399:main.c        **** }
 3157               	.LM388:
 3158 017c 84B0      		in r8,0x4
 3159 017e 95B0      		in r9,0x4+1
 3160               	.LBE490:
 3161               	.LBE489:
 749:main.c        **** 	clar = (int8_t)((clarval - 512) >> 2);
 3163               	.LM389:
 3164 0180 C101      		movw r24,r2
 3165 0182 0A97      		sbiw r24,10
 3166 0184 8816      		cp r8,r24
 3167 0186 9906      		cpc r9,r25
 3168 0188 04F0      		brlt .L163
 749:main.c        **** 	clar = (int8_t)((clarval - 512) >> 2);
 3170               	.LM390:
 3171 018a 4496      		adiw r24,20
 3172 018c 8815      		cp r24,r8
 3173 018e 9905      		cpc r25,r9
 3174 0190 04F4      		brge .L164
 3175               	.L163:
 750:main.c        **** 	err = updateFreq(0);
 3177               	.LM391:
 3178 0192 C401      		movw r24,r8
 3179 0194 9250      		subi r25,2
 3180 0196 9595      		asr r25
 3181 0198 8795      		ror r24
 3182 019a 9595      		asr r25
 3183 019c 8795      		ror r24
 3184 019e 8093 0000 		sts clar,r24
 751:main.c        **** 	if (err) {
 3186               	.LM392:
 3187 01a2 80E0      		ldi r24,0
 3188 01a4 0E94 0000 		call updateFreq
 752:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 3190               	.LM393:
 3191 01a8 8823      		tst r24
 3192 01aa 01F0      		breq .L165
 753:main.c        **** 	  lcd_goto(0x40);
 3194               	.LM394:
 3195 01ac 1F92      		push __zero_reg__
 3196 01ae 8F93      		push r24
 3197 01b0 80E0      		ldi r24,lo8(.LC4)
 3198 01b2 90E0      		ldi r25,hi8(.LC4)
 3199 01b4 9F93      		push r25
 3200 01b6 8F93      		push r24
 3201 01b8 1F93      		push r17
 3202 01ba 0F93      		push r16
 3203 01bc 0E94 0000 		call sprintf
 754:main.c        **** 	  lcd_puts(buffer);	
 3205               	.LM395:
 3206 01c0 80E4      		ldi r24,lo8(64)
 3207 01c2 0E94 0000 		call lcd_goto
 755:main.c        **** 	}
 3209               	.LM396:
 3210 01c6 C801      		movw r24,r16
 3211 01c8 0E94 0000 		call lcd_puts
 3212 01cc 0F90      		pop __tmp_reg__
 3213 01ce 0F90      		pop __tmp_reg__
 3214 01d0 0F90      		pop __tmp_reg__
 3215 01d2 0F90      		pop __tmp_reg__
 3216 01d4 0F90      		pop __tmp_reg__
 3217 01d6 0F90      		pop __tmp_reg__
 3218 01d8 00C0      		rjmp .L337
 3219               	.L165:
 758:main.c        **** 	}
 3221               	.LM397:
 3222 01da 0E94 0000 		call lcd_freq
 3223               	.L337:
 743:main.c        **** #endif
 3225               	.LM398:
 3226 01de 1401      		movw r2,r8
 3227               	.L164:
 763:main.c        **** 	vol_timer ++;
 3229               	.LM399:
 3230 01e0 8091 0000 		lds r24,vol_timer
 3231 01e4 8F3F      		cpi r24,lo8(-1)
 3232 01e6 01F0      		breq .L166
 764:main.c        **** 
 3234               	.LM400:
 3235 01e8 8091 0000 		lds r24,vol_timer
 3236 01ec 8F5F      		subi r24,lo8(-(1))
 3237 01ee 8093 0000 		sts vol_timer,r24
 3238               	.L166:
 768:main.c        **** 	band_timer ++;
 3240               	.LM401:
 3241 01f2 8091 0000 		lds r24,band_timer
 3242 01f6 8930      		cpi r24,lo8(9)
 3243 01f8 00F4      		brsh .L167
 769:main.c        **** 	if ((band_timer < 9) && (PINF & (1 << BAND_BUTTON))) {
 3245               	.LM402:
 3246 01fa 8091 0000 		lds r24,band_timer
 3247 01fe 8F5F      		subi r24,lo8(-(1))
 3248 0200 8093 0000 		sts band_timer,r24
 770:main.c        **** 	  band_flag = 0x01; // short press
 3250               	.LM403:
 3251 0204 8091 0000 		lds r24,band_timer
 3252 0208 8930      		cpi r24,lo8(9)
 3253 020a 00F4      		brsh .L168
 770:main.c        **** 	  band_flag = 0x01; // short press
 3255               	.LM404:
 3256 020c 009B      		sbis 0,0
 3257 020e 00C0      		rjmp .L168
 771:main.c        **** 	  band_timer = 255;
 3259               	.LM405:
 3260 0210 81E0      		ldi r24,lo8(1)
 3261 0212 8093 0000 		sts band_flag,r24
 772:main.c        **** 	}
 3263               	.LM406:
 3264 0216 8FEF      		ldi r24,lo8(-1)
 3265 0218 8093 0000 		sts band_timer,r24
 3266               	.L168:
 774:main.c        **** 	  band_flag = 0x02; // long press
 3268               	.LM407:
 3269 021c 8091 0000 		lds r24,band_timer
 3270 0220 8930      		cpi r24,lo8(9)
 3271 0222 01F4      		brne .L170
 774:main.c        **** 	  band_flag = 0x02; // long press
 3273               	.LM408:
 3274 0224 0099      		sbic 0,0
 3275 0226 00C0      		rjmp .L170
 775:main.c        ****       }
 3277               	.LM409:
 3278 0228 82E0      		ldi r24,lo8(2)
 3279 022a 8093 0000 		sts band_flag,r24
 3280 022e 00C0      		rjmp .L170
 3281               	.L167:
 777:main.c        **** 	band_timer = 0;
 3283               	.LM410:
 3284 0230 009B      		sbis 0,0
 778:main.c        ****       }
 3286               	.LM411:
 3287 0232 1092 0000 		sts band_timer,__zero_reg__
 3288               	.L170:
 783:main.c        **** 	mode_flag = 0x01;
 3290               	.LM412:
 3291 0236 0199      		sbic 0,1
 3292 0238 00C0      		rjmp .L172
 784:main.c        ****       }
 3294               	.LM413:
 3295 023a 81E0      		ldi r24,lo8(1)
 3296 023c 8093 0000 		sts mode_flag,r24
 3297               	.L172:
 788:main.c        **** 	lcd_freq();
 3299               	.LM414:
 3300 0240 6091 0000 		lds r22,freq
 3301 0244 7091 0000 		lds r23,freq+1
 3302 0248 8091 0000 		lds r24,freq+2
 3303 024c 9091 0000 		lds r25,freq+3
 3304 0250 2496      		adiw r28,64-60
 3305 0252 2CAD      		ldd r18,Y+60
 3306 0254 3DAD      		ldd r19,Y+61
 3307 0256 4EAD      		ldd r20,Y+62
 3308 0258 5FAD      		ldd r21,Y+63
 3309 025a 2497      		sbiw r28,64-60
 3310 025c 0E94 0000 		call __nesf2
 3311 0260 8823      		tst r24
 3312 0262 01F0      		breq .L173
 789:main.c        **** 	err = updateFreq(1);
 3314               	.LM415:
 3315 0264 0E94 0000 		call lcd_freq
 790:main.c        **** 	if (err) {
 3317               	.LM416:
 3318 0268 81E0      		ldi r24,lo8(1)
 3319 026a 0E94 0000 		call updateFreq
 791:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 3321               	.LM417:
 3322 026e 8823      		tst r24
 3323 0270 01F0      		breq .L175
 792:main.c        **** 	  lcd_goto(0x40);
 3325               	.LM418:
 3326 0272 1F92      		push __zero_reg__
 3327 0274 8F93      		push r24
 3328 0276 80E0      		ldi r24,lo8(.LC4)
 3329 0278 90E0      		ldi r25,hi8(.LC4)
 3330 027a 9F93      		push r25
 3331 027c 8F93      		push r24
 3332 027e 1F93      		push r17
 3333 0280 0F93      		push r16
 3334 0282 0E94 0000 		call sprintf
 793:main.c        **** 	  lcd_puts(buffer);	
 3336               	.LM419:
 3337 0286 80E4      		ldi r24,lo8(64)
 3338 0288 0E94 0000 		call lcd_goto
 794:main.c        **** 	}
 3340               	.LM420:
 3341 028c C801      		movw r24,r16
 3342 028e 0E94 0000 		call lcd_puts
 3343 0292 0F90      		pop __tmp_reg__
 3344 0294 0F90      		pop __tmp_reg__
 3345 0296 0F90      		pop __tmp_reg__
 3346 0298 0F90      		pop __tmp_reg__
 3347 029a 0F90      		pop __tmp_reg__
 3348 029c 0F90      		pop __tmp_reg__
 3349               	.L175:
 796:main.c        ****       }
 3351               	.LM421:
 3352 029e 8091 0000 		lds r24,freq
 3353 02a2 9091 0000 		lds r25,freq+1
 3354 02a6 A091 0000 		lds r26,freq+2
 3355 02aa B091 0000 		lds r27,freq+3
 3356 02ae 2496      		adiw r28,64-60
 3357 02b0 8CAF      		std Y+60,r24
 3358 02b2 9DAF      		std Y+61,r25
 3359 02b4 AEAF      		std Y+62,r26
 3360 02b6 BFAF      		std Y+63,r27
 3361 02b8 2497      		sbiw r28,64-60
 3362               	.L173:
 800:main.c        ****       if (!err) {
 3364               	.LM422:
 3365 02ba BE01      		movw r22,r28
 3366 02bc 635C      		subi r22,-61
 3367 02be 7F4F      		sbci r23,-1
 3368 02c0 83E2      		ldi r24,lo8(35)
 3369 02c2 0E94 0000 		call TWI_read_byte
 801:main.c        **** 	if ((data & 0x80) && (tx_last != 1)) { // Shift to TX ?
 3371               	.LM423:
 3372 02c6 8111      		cpse r24,__zero_reg__
 3373 02c8 00C0      		rjmp .L176
 802:main.c        **** 	  tx = 0x0001;
 3375               	.LM424:
 3376 02ca 8DAD      		ldd r24,Y+61
 3377 02cc 87FF      		sbrs r24,7
 3378 02ce 00C0      		rjmp .L177
 802:main.c        **** 	  tx = 0x0001;
 3380               	.LM425:
 3381 02d0 9EAD      		ldd r25,Y+62
 3382 02d2 9130      		cpi r25,lo8(1)
 3383 02d4 01F0      		breq .L178
 803:main.c        **** 	  updateRFFE();
 3385               	.LM426:
 3386 02d6 81E0      		ldi r24,lo8(1)
 3387 02d8 90E0      		ldi r25,0
 3388 02da 9093 0000 		sts tx+1,r25
 3389 02de 8093 0000 		sts tx,r24
 804:main.c        **** 	  PORTD |= (1 << LED_RED);
 3391               	.LM427:
 3392 02e2 0E94 0000 		call updateRFFE
 805:main.c        **** 	  PORTD &= ~(1 << LED_GREEN);
 3394               	.LM428:
 3395 02e6 969A      		sbi 0x12,6
 806:main.c        **** 	  tx_last = 1;
 3397               	.LM429:
 3398 02e8 9598      		cbi 0x12,5
 807:main.c        **** 	}
 3400               	.LM430:
 3401 02ea A1E0      		ldi r26,lo8(1)
 3402 02ec AEAF      		std Y+62,r26
 3403 02ee 00C0      		rjmp .L178
 3404               	.L177:
 809:main.c        **** 	  tx = 0x0000;
 3406               	.LM431:
 3407 02f0 BEAD      		ldd r27,Y+62
 3408 02f2 BB23      		tst r27
 3409 02f4 01F0      		breq .L178
 810:main.c        **** 	  updateRFFE();
 3411               	.LM432:
 3412 02f6 1092 0000 		sts tx+1,__zero_reg__
 3413 02fa 1092 0000 		sts tx,__zero_reg__
 811:main.c        **** 	  PORTD |= (1 << LED_GREEN);
 3415               	.LM433:
 3416 02fe 0E94 0000 		call updateRFFE
 812:main.c        **** 	  PORTD &= ~(1 << LED_RED);
 3418               	.LM434:
 3419 0302 959A      		sbi 0x12,5
 813:main.c        **** 	  tx_last = 0;
 3421               	.LM435:
 3422 0304 9698      		cbi 0x12,6
 814:main.c        **** 	}
 3424               	.LM436:
 3425 0306 1EAE      		std Y+62,__zero_reg__
 3426 0308 00C0      		rjmp .L178
 3427               	.L176:
 818:main.c        ****       }
 3429               	.LM437:
 3430 030a 82B3      		in r24,0x12
 3431 030c 8F79      		andi r24,lo8(-97)
 3432 030e 82BB      		out 0x12,r24
 3433               	.L178:
 821:main.c        ****       if (rssi_max < rssi) 
 3435               	.LM438:
 3436 0310 8DAD      		ldd r24,Y+61
 3437 0312 8F73      		andi r24,lo8(63)
 3438 0314 F816      		cp r15,r24
 3439 0316 00F4      		brsh .L179
 3440 0318 F82E      		mov r15,r24
 3441               	.L179:
 824:main.c        ****       if ((!rffe_rx_att && rssi_count > 2) || (rffe_rx_att && rssi_count > 2)) {
 3443               	.LM439:
 3444 031a E394      		inc r14
 825:main.c        **** 	rssi_count = 0;
 3446               	.LM440:
 3447 031c 8091 0000 		lds r24,rffe_rx_att
 3448 0320 8111      		cpse r24,__zero_reg__
 3449 0322 00C0      		rjmp .L180
 825:main.c        **** 	rssi_count = 0;
 3451               	.LM441:
 3452 0324 22E0      		ldi r18,lo8(2)
 3453 0326 2E15      		cp r18,r14
 3454 0328 00F0      		brlo .L181
 3455               	.L180:
 825:main.c        **** 	rssi_count = 0;
 3457               	.LM442:
 3458 032a 8091 0000 		lds r24,rffe_rx_att
 3459 032e 8823      		tst r24
 3460 0330 01F4      		brne .+2
 3461 0332 00C0      		rjmp .L182
 825:main.c        **** 	rssi_count = 0;
 3463               	.LM443:
 3464 0334 82E0      		ldi r24,lo8(2)
 3465 0336 8E15      		cp r24,r14
 3466 0338 00F0      		brlo .+2
 3467 033a 00C0      		rjmp .L182
 3468               	.L181:
 827:main.c        **** 	  rssi = 0;
 3470               	.LM444:
 3471 033c 93E0      		ldi r25,lo8(3)
 3472 033e 9F15      		cp r25,r15
 3473 0340 00F4      		brsh .L266
 830:main.c        **** 	rssi_max = 0;
 3475               	.LM445:
 3476 0342 8CEF      		ldi r24,lo8(-4)
 3477 0344 8F0D      		add r24,r15
 3478 0346 00C0      		rjmp .L183
 3479               	.L266:
 828:main.c        **** 	else 
 3481               	.LM446:
 3482 0348 80E0      		ldi r24,0
 3483               	.L183:
 833:main.c        **** 	else if (rffe_rx_att && (rssi>9)) {
 3485               	.LM447:
 3486 034a 9091 0000 		lds r25,vol_timer
 3487 034e 9A30      		cpi r25,lo8(10)
 3488 0350 00F4      		brsh .+2
 3489 0352 00C0      		rjmp .L267
 834:main.c        **** 	  sprintf(buffer,"S---9+++   ");
 3491               	.LM448:
 3492 0354 9091 0000 		lds r25,rffe_rx_att
 3493 0358 9923      		tst r25
 3494 035a 01F0      		breq .L184
 834:main.c        **** 	  sprintf(buffer,"S---9+++   ");
 3496               	.LM449:
 3497 035c 8A30      		cpi r24,lo8(10)
 3498 035e 00F0      		brlo .L184
 835:main.c        **** 	  lcd_goto(0x40);
 3500               	.LM450:
 3501 0360 60E0      		ldi r22,lo8(.LC5)
 3502 0362 70E0      		ldi r23,hi8(.LC5)
 3503 0364 00C0      		rjmp .L344
 3504               	.L184:
 839:main.c        **** 	  rffe_rx_att = false;
 3506               	.LM451:
 3507 0366 9091 0000 		lds r25,rffe_rx_att
 3508 036a 9923      		tst r25
 3509 036c 01F0      		breq .L185
 839:main.c        **** 	  rffe_rx_att = false;
 3511               	.LM452:
 3512 036e 8A30      		cpi r24,lo8(10)
 3513 0370 00F4      		brsh .L186
 840:main.c        **** 	  err = updateRFFE();
 3515               	.LM453:
 3516 0372 1092 0000 		sts rffe_rx_att,__zero_reg__
 3517 0376 00C0      		rjmp .L343
 3518               	.L185:
 843:main.c        **** 	  sprintf(buffer,"S%d         ",rssi);
 3520               	.LM454:
 3521 0378 8230      		cpi r24,lo8(2)
 3522 037a 00F4      		brsh .L187
 844:main.c        **** 	  lcd_goto(0x40);
 3524               	.LM455:
 3525 037c 1F92      		push __zero_reg__
 3526 037e 8F93      		push r24
 3527 0380 80E0      		ldi r24,lo8(.LC6)
 3528 0382 90E0      		ldi r25,hi8(.LC6)
 3529 0384 00C0      		rjmp .L349
 3530               	.L187:
 848:main.c        **** 	  sprintf(buffer,"S-%d        ",rssi);
 3532               	.LM456:
 3533 0386 8430      		cpi r24,lo8(4)
 3534 0388 00F4      		brsh .L186
 849:main.c        **** 	  lcd_goto(0x40);
 3536               	.LM457:
 3537 038a 1F92      		push __zero_reg__
 3538 038c 8F93      		push r24
 3539 038e 80E0      		ldi r24,lo8(.LC7)
 3540 0390 90E0      		ldi r25,hi8(.LC7)
 3541 0392 00C0      		rjmp .L349
 3542               	.L186:
 853:main.c        **** 	  sprintf(buffer,"S--%d       ",rssi);
 3544               	.LM458:
 3545 0394 8630      		cpi r24,lo8(6)
 3546 0396 00F4      		brsh .L188
 854:main.c        **** 	  lcd_goto(0x40);
 3548               	.LM459:
 3549 0398 1F92      		push __zero_reg__
 3550 039a 8F93      		push r24
 3551 039c 80E0      		ldi r24,lo8(.LC8)
 3552 039e 90E0      		ldi r25,hi8(.LC8)
 3553               	.L349:
 3554 03a0 9F93      		push r25
 3555 03a2 8F93      		push r24
 3556 03a4 00C0      		rjmp .L345
 3557               	.L188:
 858:main.c        **** 	  sprintf(buffer,"S---%d      ",rssi);
 3559               	.LM460:
 3560 03a6 8830      		cpi r24,lo8(8)
 3561 03a8 00F4      		brsh .L189
 859:main.c        **** 	  lcd_goto(0x40);
 3563               	.LM461:
 3564 03aa 1F92      		push __zero_reg__
 3565 03ac 8F93      		push r24
 3566 03ae A0E0      		ldi r26,lo8(.LC9)
 3567 03b0 B0E0      		ldi r27,hi8(.LC9)
 3568 03b2 00C0      		rjmp .L346
 3569               	.L189:
 863:main.c        **** 	  sprintf(buffer,"S----%d     ",rssi);
 3571               	.LM462:
 3572 03b4 8A30      		cpi r24,lo8(10)
 3573 03b6 00F4      		brsh .L190
 864:main.c        **** 	  lcd_goto(0x40);
 3575               	.LM463:
 3576 03b8 1F92      		push __zero_reg__
 3577 03ba 8F93      		push r24
 3578 03bc A0E0      		ldi r26,lo8(.LC10)
 3579 03be B0E0      		ldi r27,hi8(.LC10)
 3580               	.L346:
 3581 03c0 BF93      		push r27
 3582 03c2 AF93      		push r26
 3583               	.L345:
 3584 03c4 1F93      		push r17
 3585 03c6 0F93      		push r16
 3586 03c8 0E94 0000 		call sprintf
 865:main.c        **** 	  lcd_puts(buffer);
 3588               	.LM464:
 3589 03cc 80E4      		ldi r24,lo8(64)
 3590 03ce 0E94 0000 		call lcd_goto
 866:main.c        **** 	}
 3592               	.LM465:
 3593 03d2 C801      		movw r24,r16
 3594 03d4 0E94 0000 		call lcd_puts
 3595 03d8 0F90      		pop __tmp_reg__
 3596 03da 0F90      		pop __tmp_reg__
 3597 03dc 0F90      		pop __tmp_reg__
 3598 03de 0F90      		pop __tmp_reg__
 3599 03e0 0F90      		pop __tmp_reg__
 3600 03e2 0F90      		pop __tmp_reg__
 3601 03e4 00C0      		rjmp .L267
 3602               	.L190:
 868:main.c        **** 	  sprintf(buffer,"S----9+    ");
 3604               	.LM466:
 3605 03e6 8C30      		cpi r24,lo8(12)
 3606 03e8 00F4      		brsh .L191
 869:main.c        **** 	  lcd_goto(0x40);
 3608               	.LM467:
 3609 03ea 60E0      		ldi r22,lo8(.LC11)
 3610 03ec 70E0      		ldi r23,hi8(.LC11)
 3611 03ee 00C0      		rjmp .L344
 3612               	.L191:
 873:main.c        **** 	  sprintf(buffer,"S----9++   ");
 3614               	.LM468:
 3615 03f0 8C30      		cpi r24,lo8(12)
 3616 03f2 01F4      		brne .L192
 874:main.c        **** 	  lcd_goto(0x40);
 3618               	.LM469:
 3619 03f4 60E0      		ldi r22,lo8(.LC12)
 3620 03f6 70E0      		ldi r23,hi8(.LC12)
 3621               	.L344:
 3622 03f8 C801      		movw r24,r16
 3623 03fa 0E94 0000 		call strcpy
 875:main.c        **** 	  lcd_puts(buffer);
 3625               	.LM470:
 3626 03fe 80E4      		ldi r24,lo8(64)
 3627 0400 0E94 0000 		call lcd_goto
 876:main.c        **** 	}
 3629               	.LM471:
 3630 0404 C801      		movw r24,r16
 3631 0406 0E94 0000 		call lcd_puts
 3632 040a 00C0      		rjmp .L267
 3633               	.L192:
 879:main.c        **** 	  err = updateRFFE();
 3635               	.LM472:
 3636 040c 81E0      		ldi r24,lo8(1)
 3637 040e 8093 0000 		sts rffe_rx_att,r24
 3638               	.L343:
 880:main.c        **** 	}
 3640               	.LM473:
 3641 0412 0E94 0000 		call updateRFFE
 3642               	.L267:
 826:main.c        **** 	if (rssi_max < 4)
 3644               	.LM474:
 3645 0416 E12C      		mov r14,__zero_reg__
 831:main.c        **** 
 3647               	.LM475:
 3648 0418 F12C      		mov r15,__zero_reg__
 3649               	.L182:
 884:main.c        ****     }
 3651               	.LM476:
 3652 041a 1092 0000 		sts timer_flag,__zero_reg__
 3653 041e 00C0      		rjmp .L193
 3654               	.L162:
 886:main.c        ****       switch (mode) {
 3656               	.LM477:
 3657 0420 8091 0000 		lds r24,mode_flag
 3658 0424 8823      		tst r24
 3659 0426 01F4      		brne .+2
 3660 0428 00C0      		rjmp .L193
 887:main.c        ****       case LSB:
 3662               	.LM478:
 3663 042a 8091 0000 		lds r24,mode
 3664 042e 8330      		cpi r24,lo8(3)
 3665 0430 01F0      		breq .L195
 3666 0432 00F4      		brsh .L196
 3667 0434 8130      		cpi r24,lo8(1)
 3668 0436 01F0      		breq .L197
 3669 0438 00C0      		rjmp .L194
 3670               	.L196:
 3671 043a 8530      		cpi r24,lo8(5)
 3672 043c 01F0      		breq .L198
 3673 043e 8630      		cpi r24,lo8(6)
 3674 0440 01F0      		breq .L199
 3675 0442 00C0      		rjmp .L194
 3676               	.L197:
 889:main.c        **** 	if (!updateSettings()) { 
 3678               	.LM479:
 3679 0444 83E0      		ldi r24,lo8(3)
 3680 0446 8093 0000 		sts mode,r24
 890:main.c        **** 	  lcd_goto(0x00);
 3682               	.LM480:
 3683 044a 0E94 0000 		call updateSettings
 3684 044e 8111      		cpse r24,__zero_reg__
 3685 0450 00C0      		rjmp .L201
 891:main.c        **** 	  sprintf(buffer,"USB ");
 3687               	.LM481:
 3688 0452 0E94 0000 		call lcd_goto
 892:main.c        **** 	  lcd_puts(buffer);
 3690               	.LM482:
 3691 0456 60E0      		ldi r22,lo8(.LC13)
 3692 0458 70E0      		ldi r23,hi8(.LC13)
 3693 045a 00C0      		rjmp .L338
 3694               	.L195:
 897:main.c        **** 	if(!updateSettings()) {
 3696               	.LM483:
 3697 045c 85E0      		ldi r24,lo8(5)
 3698 045e 8093 0000 		sts mode,r24
 898:main.c        **** 	  lcd_goto(0x00);
 3700               	.LM484:
 3701 0462 0E94 0000 		call updateSettings
 3702 0466 8111      		cpse r24,__zero_reg__
 3703 0468 00C0      		rjmp .L201
 899:main.c        **** 	  sprintf(buffer,"CW  ");
 3705               	.LM485:
 3706 046a 0E94 0000 		call lcd_goto
 900:main.c        **** 	  lcd_puts(buffer);
 3708               	.LM486:
 3709 046e 60E0      		ldi r22,lo8(.LC14)
 3710 0470 70E0      		ldi r23,hi8(.LC14)
 3711 0472 00C0      		rjmp .L338
 3712               	.L198:
 905:main.c        **** 	if(!updateSettings()) {
 3714               	.LM487:
 3715 0474 86E0      		ldi r24,lo8(6)
 3716 0476 8093 0000 		sts mode,r24
 906:main.c        **** 	  lcd_goto(0x00);
 3718               	.LM488:
 3719 047a 0E94 0000 		call updateSettings
 3720 047e 8111      		cpse r24,__zero_reg__
 3721 0480 00C0      		rjmp .L201
 907:main.c        **** 	  sprintf(buffer,"CWN ");
 3723               	.LM489:
 3724 0482 0E94 0000 		call lcd_goto
 908:main.c        **** 	  lcd_puts(buffer);
 3726               	.LM490:
 3727 0486 60E0      		ldi r22,lo8(.LC15)
 3728 0488 70E0      		ldi r23,hi8(.LC15)
 3729 048a 00C0      		rjmp .L338
 3730               	.L199:
 913:main.c        **** 	  mode = AM;
 3732               	.LM491:
 3733 048c 8091 0000 		lds r24,band
 3734 0490 883C      		cpi r24,lo8(-56)
 3735 0492 00F4      		brsh .L203
 914:main.c        **** 	  if(!updateSettings()) {
 3737               	.LM492:
 3738 0494 88E0      		ldi r24,lo8(8)
 3739 0496 8093 0000 		sts mode,r24
 915:main.c        **** 	    lcd_goto(0x00);
 3741               	.LM493:
 3742 049a 0E94 0000 		call updateSettings
 3743 049e 8111      		cpse r24,__zero_reg__
 3744 04a0 00C0      		rjmp .L201
 916:main.c        **** 	    sprintf(buffer,"AM  ");
 3746               	.LM494:
 3747 04a2 0E94 0000 		call lcd_goto
 917:main.c        **** 	    lcd_puts(buffer);
 3749               	.LM495:
 3750 04a6 60E0      		ldi r22,lo8(.LC16)
 3751 04a8 70E0      		ldi r23,hi8(.LC16)
 3752 04aa 00C0      		rjmp .L338
 3753               	.L203:
 922:main.c        **** 	  if(!updateSettings()) {
 3755               	.LM496:
 3756 04ac 8AE0      		ldi r24,lo8(10)
 3757 04ae 8093 0000 		sts mode,r24
 923:main.c        **** 	    lcd_goto(0x00);
 3759               	.LM497:
 3760 04b2 0E94 0000 		call updateSettings
 3761 04b6 8111      		cpse r24,__zero_reg__
 3762 04b8 00C0      		rjmp .L201
 924:main.c        **** 	    sprintf(buffer,"FM  ");
 3764               	.LM498:
 3765 04ba 0E94 0000 		call lcd_goto
 925:main.c        **** 	    lcd_puts(buffer);
 3767               	.LM499:
 3768 04be 60E0      		ldi r22,lo8(.LC17)
 3769 04c0 70E0      		ldi r23,hi8(.LC17)
 3770 04c2 00C0      		rjmp .L338
 3771               	.L194:
 933:main.c        **** 	if(!updateSettings()) { 
 3773               	.LM500:
 3774 04c4 81E0      		ldi r24,lo8(1)
 3775 04c6 8093 0000 		sts mode,r24
 934:main.c        **** 	  lcd_goto(0x00);
 3777               	.LM501:
 3778 04ca 0E94 0000 		call updateSettings
 3779 04ce 8111      		cpse r24,__zero_reg__
 3780 04d0 00C0      		rjmp .L201
 935:main.c        **** 	  sprintf(buffer,"LSB ");
 3782               	.LM502:
 3783 04d2 0E94 0000 		call lcd_goto
 936:main.c        **** 	  lcd_puts(buffer);
 3785               	.LM503:
 3786 04d6 60E0      		ldi r22,lo8(.LC18)
 3787 04d8 70E0      		ldi r23,hi8(.LC18)
 3788               	.L338:
 3789 04da C801      		movw r24,r16
 3790 04dc 0E94 0000 		call strcpy
 937:main.c        **** 	}
 3792               	.LM504:
 3793 04e0 C801      		movw r24,r16
 3794 04e2 0E94 0000 		call lcd_puts
 3795               	.L201:
 3796               	.LBB491:
 3797               	.LBB492:
 3799               	.Ltext44:
 163:/usr/lib/avr/include/util/delay.h **** 
 3801               	.LM505:
 3802 04e6 83E2      		ldi r24,lo8(-3037)
 3803 04e8 94EF      		ldi r25,hi8(-3037)
 3804 04ea 0197      	1:	sbiw r24,1
 3805 04ec 01F4      		brne 1b
 3806 04ee 00C0      		rjmp .
 3807 04f0 0000      		nop
 3808               	.LBE492:
 3809               	.LBE491:
 3811               	.Ltext45:
 942:main.c        ****       mode_flag = 0x00;
 3813               	.LM506:
 3814 04f2 81E0      		ldi r24,lo8(1)
 3815 04f4 0E94 0000 		call updateFreq
 943:main.c        ****     }
 3817               	.LM507:
 3818 04f8 1092 0000 		sts mode_flag,__zero_reg__
 3819               	.L193:
 946:main.c        ****       if (band_flag == 0x02) { // long press
 3821               	.LM508:
 3822 04fc 8091 0000 		lds r24,band_flag
 3823 0500 8823      		tst r24
 3824 0502 01F4      		brne .+2
 3825 0504 00C0      		rjmp .L204
 947:main.c        **** #ifdef TWOMETER_TRANSV
 3827               	.LM509:
 3828 0506 8091 0000 		lds r24,band_flag
 3829 050a 8230      		cpi r24,lo8(2)
 3830 050c 01F4      		brne .+2
 3831 050e 00C0      		rjmp .L205
 983:main.c        **** 	  freq = 3510;
 3833               	.LM510:
 3834 0510 6091 0000 		lds r22,freq
 3835 0514 7091 0000 		lds r23,freq+1
 3836 0518 8091 0000 		lds r24,freq+2
 3837 051c 9091 0000 		lds r25,freq+3
 3838 0520 20E0      		ldi r18,0
 3839 0522 30EC      		ldi r19,lo8(-64)
 3840 0524 4AE5      		ldi r20,lo8(90)
 3841 0526 55E4      		ldi r21,lo8(69)
 3842 0528 0E94 0000 		call __ltsf2
 3843 052c 87FF      		sbrs r24,7
 3844 052e 00C0      		rjmp .L326
 3846               	.LM511:
 3847 0530 4092 0000 		sts freq,r4
 3848 0534 5092 0000 		sts freq+1,r5
 3849 0538 6092 0000 		sts freq+2,r6
 3850 053c 7092 0000 		sts freq+3,r7
 3851 0540 00C0      		rjmp .L205
 3852               	.L326:
 985:main.c        **** 	else if(freq<7000)
 3854               	.LM512:
 3855 0542 6091 0000 		lds r22,freq
 3856 0546 7091 0000 		lds r23,freq+1
 3857 054a 8091 0000 		lds r24,freq+2
 3858 054e 9091 0000 		lds r25,freq+3
 3859 0552 20E0      		ldi r18,0
 3860 0554 30EC      		ldi r19,lo8(-64)
 3861 0556 4AED      		ldi r20,lo8(-38)
 3862 0558 55E4      		ldi r21,lo8(69)
 3863 055a 0E94 0000 		call __ltsf2
 3864 055e 87FF      		sbrs r24,7
 3865 0560 00C0      		rjmp .L327
 986:main.c        **** 	  freq = 7010;
 3867               	.LM513:
 3868 0562 80E0      		ldi r24,0
 3869 0564 90E1      		ldi r25,lo8(16)
 3870 0566 ABED      		ldi r26,lo8(-37)
 3871 0568 B5E4      		ldi r27,lo8(69)
 3872 056a 00C0      		rjmp .L339
 3873               	.L327:
 987:main.c        **** 	else if(freq<10100)
 3875               	.LM514:
 3876 056c 6091 0000 		lds r22,freq
 3877 0570 7091 0000 		lds r23,freq+1
 3878 0574 8091 0000 		lds r24,freq+2
 3879 0578 9091 0000 		lds r25,freq+3
 3880 057c 20E0      		ldi r18,0
 3881 057e 30ED      		ldi r19,lo8(-48)
 3882 0580 4DE1      		ldi r20,lo8(29)
 3883 0582 56E4      		ldi r21,lo8(70)
 3884 0584 0E94 0000 		call __ltsf2
 3885 0588 87FF      		sbrs r24,7
 3886 058a 00C0      		rjmp .L328
 988:main.c        **** 	  freq = 10110;
 3888               	.LM515:
 3889 058c 80E0      		ldi r24,0
 3890 058e 98EF      		ldi r25,lo8(-8)
 3891 0590 ADE1      		ldi r26,lo8(29)
 3892 0592 B6E4      		ldi r27,lo8(70)
 3893 0594 00C0      		rjmp .L339
 3894               	.L328:
 989:main.c        **** 	else if(freq<14000)
 3896               	.LM516:
 3897 0596 6091 0000 		lds r22,freq
 3898 059a 7091 0000 		lds r23,freq+1
 3899 059e 8091 0000 		lds r24,freq+2
 3900 05a2 9091 0000 		lds r25,freq+3
 3901 05a6 20E0      		ldi r18,0
 3902 05a8 30EC      		ldi r19,lo8(-64)
 3903 05aa 4AE5      		ldi r20,lo8(90)
 3904 05ac 56E4      		ldi r21,lo8(70)
 3905 05ae 0E94 0000 		call __ltsf2
 3906 05b2 87FF      		sbrs r24,7
 3907 05b4 00C0      		rjmp .L329
 990:main.c        **** 	  freq = 14010;
 3909               	.LM517:
 3910 05b6 80E0      		ldi r24,0
 3911 05b8 98EE      		ldi r25,lo8(-24)
 3912 05ba AAE5      		ldi r26,lo8(90)
 3913 05bc B6E4      		ldi r27,lo8(70)
 3914 05be 00C0      		rjmp .L339
 3915               	.L329:
 991:main.c        **** 	else if(freq<18068)
 3917               	.LM518:
 3918 05c0 6091 0000 		lds r22,freq
 3919 05c4 7091 0000 		lds r23,freq+1
 3920 05c8 8091 0000 		lds r24,freq+2
 3921 05cc 9091 0000 		lds r25,freq+3
 3922 05d0 20E0      		ldi r18,0
 3923 05d2 38E2      		ldi r19,lo8(40)
 3924 05d4 4DE8      		ldi r20,lo8(-115)
 3925 05d6 56E4      		ldi r21,lo8(70)
 3926 05d8 0E94 0000 		call __ltsf2
 3927 05dc 87FF      		sbrs r24,7
 3928 05de 00C0      		rjmp .L330
 992:main.c        **** 	  freq = 18078;
 3930               	.LM519:
 3931 05e0 80E0      		ldi r24,0
 3932 05e2 9CE3      		ldi r25,lo8(60)
 3933 05e4 ADE8      		ldi r26,lo8(-115)
 3934 05e6 B6E4      		ldi r27,lo8(70)
 3935 05e8 00C0      		rjmp .L339
 3936               	.L330:
 993:main.c        **** 	else if(freq<21000)
 3938               	.LM520:
 3939 05ea 6091 0000 		lds r22,freq
 3940 05ee 7091 0000 		lds r23,freq+1
 3941 05f2 8091 0000 		lds r24,freq+2
 3942 05f6 9091 0000 		lds r25,freq+3
 3943 05fa 20E0      		ldi r18,0
 3944 05fc 30E1      		ldi r19,lo8(16)
 3945 05fe 44EA      		ldi r20,lo8(-92)
 3946 0600 56E4      		ldi r21,lo8(70)
 3947 0602 0E94 0000 		call __ltsf2
 3948 0606 87FF      		sbrs r24,7
 3949 0608 00C0      		rjmp .L331
 994:main.c        **** 	  freq = 21010;
 3951               	.LM521:
 3952 060a 80E0      		ldi r24,0
 3953 060c 94E2      		ldi r25,lo8(36)
 3954 060e A4EA      		ldi r26,lo8(-92)
 3955 0610 B6E4      		ldi r27,lo8(70)
 3956 0612 00C0      		rjmp .L339
 3957               	.L331:
 995:main.c        **** 	else if(freq<24890)
 3959               	.LM522:
 3960 0614 6091 0000 		lds r22,freq
 3961 0618 7091 0000 		lds r23,freq+1
 3962 061c 8091 0000 		lds r24,freq+2
 3963 0620 9091 0000 		lds r25,freq+3
 3964 0624 20E0      		ldi r18,0
 3965 0626 34E7      		ldi r19,lo8(116)
 3966 0628 42EC      		ldi r20,lo8(-62)
 3967 062a 56E4      		ldi r21,lo8(70)
 3968 062c 0E94 0000 		call __ltsf2
 3969 0630 87FF      		sbrs r24,7
 3970 0632 00C0      		rjmp .L332
 996:main.c        **** 	  freq = 24900;
 3972               	.LM523:
 3973 0634 80E0      		ldi r24,0
 3974 0636 98E8      		ldi r25,lo8(-120)
 3975 0638 A2EC      		ldi r26,lo8(-62)
 3976 063a B6E4      		ldi r27,lo8(70)
 3977 063c 00C0      		rjmp .L339
 3978               	.L332:
 997:main.c        **** 	else if(freq<28000)
 3980               	.LM524:
 3981 063e 6091 0000 		lds r22,freq
 3982 0642 7091 0000 		lds r23,freq+1
 3983 0646 8091 0000 		lds r24,freq+2
 3984 064a 9091 0000 		lds r25,freq+3
 3985 064e 20E0      		ldi r18,0
 3986 0650 30EC      		ldi r19,lo8(-64)
 3987 0652 4AED      		ldi r20,lo8(-38)
 3988 0654 56E4      		ldi r21,lo8(70)
 3989 0656 0E94 0000 		call __ltsf2
 3990 065a 87FF      		sbrs r24,7
 3991 065c 00C0      		rjmp .L333
 998:main.c        **** 	  freq = 28010;
 3993               	.LM525:
 3994 065e 80E0      		ldi r24,0
 3995 0660 94ED      		ldi r25,lo8(-44)
 3996 0662 AAED      		ldi r26,lo8(-38)
 3997 0664 B6E4      		ldi r27,lo8(70)
 3998 0666 00C0      		rjmp .L339
 3999               	.L333:
 999:main.c        **** 	else if(freq<28500)
 4001               	.LM526:
 4002 0668 6091 0000 		lds r22,freq
 4003 066c 7091 0000 		lds r23,freq+1
 4004 0670 8091 0000 		lds r24,freq+2
 4005 0674 9091 0000 		lds r25,freq+3
 4006 0678 20E0      		ldi r18,0
 4007 067a 38EA      		ldi r19,lo8(-88)
 4008 067c 4EED      		ldi r20,lo8(-34)
 4009 067e 56E4      		ldi r21,lo8(70)
 4010 0680 0E94 0000 		call __ltsf2
 4011 0684 87FF      		sbrs r24,7
 4012 0686 00C0      		rjmp .L334
1000:main.c        **** 	  freq = 28600;
 4014               	.LM527:
 4015 0688 80E0      		ldi r24,0
 4016 068a 90E7      		ldi r25,lo8(112)
 4017 068c AFED      		ldi r26,lo8(-33)
 4018 068e B6E4      		ldi r27,lo8(70)
 4019 0690 00C0      		rjmp .L339
 4020               	.L334:
1001:main.c        **** 	else
1002:main.c        **** 	  freq = 1810;
 4022               	.LM528:
 4023 0692 80E0      		ldi r24,0
 4024 0694 90E4      		ldi r25,lo8(64)
 4025 0696 A2EE      		ldi r26,lo8(-30)
 4026 0698 B4E4      		ldi r27,lo8(68)
 4027               	.L339:
 4028 069a 8093 0000 		sts freq,r24
 4029 069e 9093 0000 		sts freq+1,r25
 4030 06a2 A093 0000 		sts freq+2,r26
 4031 06a6 B093 0000 		sts freq+3,r27
 4032               	.L205:
1003:main.c        **** #endif
1004:main.c        **** #ifdef TWOMETER
1005:main.c        ****       if(freq<144150)
1006:main.c        **** 	freq = 144300;
1007:main.c        ****       else if(freq<144400)
1008:main.c        **** 	freq = 144450;
1009:main.c        ****       else if(freq<145000)
1010:main.c        **** 	freq = 145500;
1011:main.c        ****       else if(freq<150000)
1012:main.c        **** 	freq = 144050;
1013:main.c        **** #endif
1014:main.c        **** #ifdef TWOMETER_TRANSV
1015:main.c        ****       if(freq<144700)
1016:main.c        **** 	freq = 144800;
1017:main.c        ****       else if(freq<150000)
1018:main.c        **** 	freq = 144200;
1019:main.c        **** #endif
1020:main.c        ****       }
1021:main.c        **** 
1022:main.c        ****       lcd_freq();
 4034               	.LM529:
 4035 06aa 0E94 0000 		call lcd_freq
1023:main.c        ****       err = updateFreq(1);
 4037               	.LM530:
 4038 06ae 81E0      		ldi r24,lo8(1)
 4039 06b0 0E94 0000 		call updateFreq
1024:main.c        ****       if (err) {
 4041               	.LM531:
 4042 06b4 8823      		tst r24
 4043 06b6 01F0      		breq .L224
1025:main.c        **** 	sprintf(buffer,"Err freq %x         ",err);
 4045               	.LM532:
 4046 06b8 1F92      		push __zero_reg__
 4047 06ba 8F93      		push r24
 4048 06bc 80E0      		ldi r24,lo8(.LC19)
 4049 06be 90E0      		ldi r25,hi8(.LC19)
 4050 06c0 9F93      		push r25
 4051 06c2 8F93      		push r24
 4052 06c4 1F93      		push r17
 4053 06c6 0F93      		push r16
 4054 06c8 0E94 0000 		call sprintf
1026:main.c        **** 	lcd_goto(0x40);
 4056               	.LM533:
 4057 06cc 80E4      		ldi r24,lo8(64)
 4058 06ce 0E94 0000 		call lcd_goto
1027:main.c        **** 	lcd_puts(buffer);	
 4060               	.LM534:
 4061 06d2 C801      		movw r24,r16
 4062 06d4 0E94 0000 		call lcd_puts
 4063 06d8 0F90      		pop __tmp_reg__
 4064 06da 0F90      		pop __tmp_reg__
 4065 06dc 0F90      		pop __tmp_reg__
 4066 06de 0F90      		pop __tmp_reg__
 4067 06e0 0F90      		pop __tmp_reg__
 4068 06e2 0F90      		pop __tmp_reg__
 4069               	.L224:
1028:main.c        ****       }      
1029:main.c        ****       err = updateSettings();
 4071               	.LM535:
 4072 06e4 0E94 0000 		call updateSettings
1030:main.c        ****       if (err) {
 4074               	.LM536:
 4075 06e8 8823      		tst r24
 4076 06ea 01F0      		breq .L225
1031:main.c        **** 	sprintf(buffer,"Err sett %x         ",err);
 4078               	.LM537:
 4079 06ec 1F92      		push __zero_reg__
 4080 06ee 8F93      		push r24
 4081 06f0 80E0      		ldi r24,lo8(.LC20)
 4082 06f2 90E0      		ldi r25,hi8(.LC20)
 4083 06f4 9F93      		push r25
 4084 06f6 8F93      		push r24
 4085 06f8 1F93      		push r17
 4086 06fa 0F93      		push r16
 4087 06fc 0E94 0000 		call sprintf
1032:main.c        **** 	lcd_goto(0x40);
 4089               	.LM538:
 4090 0700 80E4      		ldi r24,lo8(64)
 4091 0702 0E94 0000 		call lcd_goto
1033:main.c        **** 	lcd_puts(buffer);	
 4093               	.LM539:
 4094 0706 C801      		movw r24,r16
 4095 0708 0E94 0000 		call lcd_puts
 4096 070c 0F90      		pop __tmp_reg__
 4097 070e 0F90      		pop __tmp_reg__
 4098 0710 0F90      		pop __tmp_reg__
 4099 0712 0F90      		pop __tmp_reg__
 4100 0714 0F90      		pop __tmp_reg__
 4101 0716 0F90      		pop __tmp_reg__
 4102               	.L225:
 4103               	.LBB493:
 4104               	.LBB494:
 4106               	.Ltext46:
 163:/usr/lib/avr/include/util/delay.h **** 
 4108               	.LM540:
 4109 0718 AFE4      		ldi r26,lo8(-15537)
 4110 071a B3EC      		ldi r27,hi8(-15537)
 4111 071c 1197      	1:	sbiw r26,1
 4112 071e 01F4      		brne 1b
 4113 0720 00C0      		rjmp .
 4114 0722 0000      		nop
 4115               	.LBE494:
 4116               	.LBE493:
 4118               	.Ltext47:
1034:main.c        ****       }      
1035:main.c        ****       _delay_ms(200);
1036:main.c        ****       band_flag = 0x00;
 4120               	.LM541:
 4121 0724 1092 0000 		sts band_flag,__zero_reg__
 4122 0728 00C0      		rjmp .L161
 4123               	.L204:
1037:main.c        ****     }
1038:main.c        ****     else if (rot_flag) {
 4125               	.LM542:
 4126 072a 8091 0000 		lds r24,rot_flag
 4127 072e 8823      		tst r24
 4128 0730 01F4      		brne .+2
 4129 0732 00C0      		rjmp .L227
1039:main.c        ****       if (rot_flag != last_dir) {
 4131               	.LM543:
 4132 0734 8091 0000 		lds r24,rot_flag
 4133 0738 BFAD      		ldd r27,Y+63
 4134 073a 8B17      		cp r24,r27
 4135 073c 01F0      		breq .L228
1040:main.c        **** 	steps = 0;
1041:main.c        **** 	step_timer = 0;
 4137               	.LM544:
 4138 073e 1092 0000 		sts step_timer+1,__zero_reg__
 4139 0742 1092 0000 		sts step_timer,__zero_reg__
1042:main.c        **** 	last_dir = rot_flag;
 4141               	.LM545:
 4142 0746 8091 0000 		lds r24,rot_flag
1040:main.c        **** 	steps = 0;
 4144               	.LM546:
 4145 074a C12C      		mov r12,__zero_reg__
 4146 074c D12C      		mov r13,__zero_reg__
 4147 074e 00C0      		rjmp .L229
 4148               	.L228:
1043:main.c        ****       }
1044:main.c        ****       else if (rot_flag == 0x01) {
 4150               	.LM547:
 4151 0750 9091 0000 		lds r25,rot_flag
 4152 0754 9130      		cpi r25,lo8(1)
 4153 0756 01F0      		breq .+2
 4154 0758 00C0      		rjmp .L230
1045:main.c        **** 	if (step_timer < 30) {
 4156               	.LM548:
 4157 075a 8091 0000 		lds r24,step_timer
 4158 075e 9091 0000 		lds r25,step_timer+1
1046:main.c        **** 	  step_timer = 0;
 4160               	.LM549:
 4161 0762 1092 0000 		sts step_timer+1,__zero_reg__
 4162 0766 1092 0000 		sts step_timer,__zero_reg__
1045:main.c        **** 	if (step_timer < 30) {
 4164               	.LM550:
 4165 076a 4E97      		sbiw r24,30
 4166 076c 00F4      		brsh .L231
1047:main.c        **** 	  steps ++;
 4168               	.LM551:
 4169 076e 2FEF      		ldi r18,-1
 4170 0770 C21A      		sub r12,r18
 4171 0772 D20A      		sbc r13,r18
1048:main.c        **** 	}
1049:main.c        **** 	else {
1050:main.c        **** 	  step_timer = 0;
1051:main.c        **** 	  steps = 1;
1052:main.c        **** 	}
1053:main.c        **** 	
1054:main.c        **** 	if (steps > 500) {
 4173               	.LM552:
 4174 0774 85EF      		ldi r24,-11
 4175 0776 C816      		cp r12,r24
 4176 0778 81E0      		ldi r24,1
 4177 077a D806      		cpc r13,r24
 4178 077c 00F4      		brsh .L232
 4179 077e 00C0      		rjmp .L350
 4180               	.L231:
1051:main.c        **** 	}
 4182               	.LM553:
 4183 0780 CC24      		clr r12
 4184 0782 C394      		inc r12
 4185 0784 D12C      		mov r13,__zero_reg__
 4186 0786 00C0      		rjmp .L234
 4187               	.L232:
1055:main.c        **** 	  if (mode == AM)
 4189               	.LM554:
 4190 0788 8091 0000 		lds r24,mode
 4191 078c 8830      		cpi r24,lo8(8)
 4192 078e 01F4      		brne .L235
1056:main.c        **** 	    freq += 20;
 4194               	.LM555:
 4195 0790 6091 0000 		lds r22,freq
 4196 0794 7091 0000 		lds r23,freq+1
 4197 0798 8091 0000 		lds r24,freq+2
 4198 079c 9091 0000 		lds r25,freq+3
 4199 07a0 20E0      		ldi r18,0
 4200 07a2 30E0      		ldi r19,0
 4201 07a4 40EA      		ldi r20,lo8(-96)
 4202 07a6 51E4      		ldi r21,lo8(65)
 4203 07a8 00C0      		rjmp .L340
 4204               	.L235:
1057:main.c        **** 	  else if (mode == FM)
 4206               	.LM556:
 4207 07aa 8091 0000 		lds r24,mode
 4208 07ae 8A30      		cpi r24,lo8(10)
 4209 07b0 01F0      		breq .+2
 4210 07b2 00C0      		rjmp .L347
1058:main.c        **** 	    freq += 50;
 4212               	.LM557:
 4213 07b4 6091 0000 		lds r22,freq
 4214 07b8 7091 0000 		lds r23,freq+1
 4215 07bc 8091 0000 		lds r24,freq+2
 4216 07c0 9091 0000 		lds r25,freq+3
 4217 07c4 20E0      		ldi r18,0
 4218 07c6 30E0      		ldi r19,0
 4219 07c8 48E4      		ldi r20,lo8(72)
 4220 07ca 52E4      		ldi r21,lo8(66)
 4221 07cc 00C0      		rjmp .L340
 4222               	.L350:
1059:main.c        **** 	  else
1060:main.c        **** 	    freq += 1;
1061:main.c        **** 	}
1062:main.c        **** 	else if (steps > 150) {
 4224               	.LM558:
 4225 07ce 97E9      		ldi r25,-105
 4226 07d0 C916      		cp r12,r25
 4227 07d2 D104      		cpc r13,__zero_reg__
 4228 07d4 00F0      		brlo .L234
1063:main.c        **** 	  if (mode == AM)
 4230               	.LM559:
 4231 07d6 8091 0000 		lds r24,mode
 4232 07da 8830      		cpi r24,lo8(8)
 4233 07dc 01F4      		brne .L237
1064:main.c        **** 	    freq += 5;
 4235               	.LM560:
 4236 07de 6091 0000 		lds r22,freq
 4237 07e2 7091 0000 		lds r23,freq+1
 4238 07e6 8091 0000 		lds r24,freq+2
 4239 07ea 9091 0000 		lds r25,freq+3
 4240 07ee 20E0      		ldi r18,0
 4241 07f0 30E0      		ldi r19,0
 4242 07f2 40EA      		ldi r20,lo8(-96)
 4243 07f4 50E4      		ldi r21,lo8(64)
 4244 07f6 00C0      		rjmp .L340
 4245               	.L237:
1065:main.c        **** 	  else if (mode == FM)
 4247               	.LM561:
 4248 07f8 8091 0000 		lds r24,mode
 4249 07fc 8A30      		cpi r24,lo8(10)
 4250 07fe 01F4      		brne .L238
1066:main.c        **** 	    freq += 25;
 4252               	.LM562:
 4253 0800 6091 0000 		lds r22,freq
 4254 0804 7091 0000 		lds r23,freq+1
 4255 0808 8091 0000 		lds r24,freq+2
 4256 080c 9091 0000 		lds r25,freq+3
 4257 0810 20E0      		ldi r18,0
 4258 0812 30E0      		ldi r19,0
 4259 0814 48EC      		ldi r20,lo8(-56)
 4260 0816 51E4      		ldi r21,lo8(65)
 4261 0818 00C0      		rjmp .L340
 4262               	.L238:
1067:main.c        **** 	  else
1068:main.c        **** 	    freq += 0.5;
 4264               	.LM563:
 4265 081a 6091 0000 		lds r22,freq
 4266 081e 7091 0000 		lds r23,freq+1
 4267 0822 8091 0000 		lds r24,freq+2
 4268 0826 9091 0000 		lds r25,freq+3
 4269 082a 20E0      		ldi r18,0
 4270 082c 30E0      		ldi r19,0
 4271 082e 40E0      		ldi r20,0
 4272 0830 5FE3      		ldi r21,lo8(63)
 4273 0832 00C0      		rjmp .L340
 4274               	.L234:
1069:main.c        **** 	}
1070:main.c        **** 	else {
1071:main.c        **** 	  if (mode == AM) {
 4276               	.LM564:
 4277 0834 8091 0000 		lds r24,mode
 4278 0838 8830      		cpi r24,lo8(8)
 4279 083a 01F4      		brne .L239
1072:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4281               	.LM565:
 4282 083c 0B9B      		sbis 0x1,3
 4283 083e 00C0      		rjmp .L240
 4284               	.L347:
1073:main.c        **** 		freq += 1;
 4286               	.LM566:
 4287 0840 6091 0000 		lds r22,freq
 4288 0844 7091 0000 		lds r23,freq+1
 4289 0848 8091 0000 		lds r24,freq+2
 4290 084c 9091 0000 		lds r25,freq+3
 4291 0850 20E0      		ldi r18,0
 4292 0852 30E0      		ldi r19,0
 4293 0854 40E8      		ldi r20,lo8(-128)
 4294 0856 5FE3      		ldi r21,lo8(63)
 4295 0858 00C0      		rjmp .L340
 4296               	.L240:
1074:main.c        **** 	    else
1075:main.c        **** 	      freq += 10;
 4298               	.LM567:
 4299 085a 6091 0000 		lds r22,freq
 4300 085e 7091 0000 		lds r23,freq+1
 4301 0862 8091 0000 		lds r24,freq+2
 4302 0866 9091 0000 		lds r25,freq+3
 4303 086a 20E0      		ldi r18,0
 4304 086c 30E0      		ldi r19,0
 4305 086e 40E2      		ldi r20,lo8(32)
 4306 0870 51E4      		ldi r21,lo8(65)
 4307 0872 00C0      		rjmp .L340
 4308               	.L239:
1076:main.c        **** 	  }
1077:main.c        **** 	  else if (mode == FM)
 4310               	.LM568:
 4311 0874 8091 0000 		lds r24,mode
 4312 0878 8A30      		cpi r24,lo8(10)
 4313 087a 01F4      		brne .L241
1078:main.c        **** 	    freq += 2.5;
 4315               	.LM569:
 4316 087c 6091 0000 		lds r22,freq
 4317 0880 7091 0000 		lds r23,freq+1
 4318 0884 8091 0000 		lds r24,freq+2
 4319 0888 9091 0000 		lds r25,freq+3
 4320 088c 20E0      		ldi r18,0
 4321 088e 30E0      		ldi r19,0
 4322 0890 40E2      		ldi r20,lo8(32)
 4323 0892 50E4      		ldi r21,lo8(64)
 4324 0894 00C0      		rjmp .L340
 4325               	.L241:
1079:main.c        **** 	  else {
1080:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4327               	.LM570:
 4328 0896 0B9B      		sbis 0x1,3
 4329 0898 00C0      		rjmp .L242
1081:main.c        **** 		freq += 0.05;
 4331               	.LM571:
 4332 089a 6091 0000 		lds r22,freq
 4333 089e 7091 0000 		lds r23,freq+1
 4334 08a2 8091 0000 		lds r24,freq+2
 4335 08a6 9091 0000 		lds r25,freq+3
 4336 08aa 2DEC      		ldi r18,lo8(-51)
 4337 08ac 3CEC      		ldi r19,lo8(-52)
 4338 08ae 4CE4      		ldi r20,lo8(76)
 4339 08b0 5DE3      		ldi r21,lo8(61)
 4340 08b2 00C0      		rjmp .L340
 4341               	.L242:
1082:main.c        **** 	    else
1083:main.c        **** 	      freq += 2;
 4343               	.LM572:
 4344 08b4 6091 0000 		lds r22,freq
 4345 08b8 7091 0000 		lds r23,freq+1
 4346 08bc 8091 0000 		lds r24,freq+2
 4347 08c0 9091 0000 		lds r25,freq+3
 4348 08c4 20E0      		ldi r18,0
 4349 08c6 30E0      		ldi r19,0
 4350 08c8 40E0      		ldi r20,0
 4351 08ca 50E4      		ldi r21,lo8(64)
 4352               	.L340:
 4353 08cc 0E94 0000 		call __addsf3
 4354 08d0 6093 0000 		sts freq,r22
 4355 08d4 7093 0000 		sts freq+1,r23
 4356 08d8 8093 0000 		sts freq+2,r24
 4357 08dc 9093 0000 		sts freq+3,r25
1084:main.c        **** 	  }
1085:main.c        **** 	}
1086:main.c        **** 	last_dir = 0x01;
 4359               	.LM573:
 4360 08e0 81E0      		ldi r24,lo8(1)
 4361 08e2 00C0      		rjmp .L229
 4362               	.L230:
1087:main.c        ****       }
1088:main.c        ****       else if (rot_flag == 0x02) {
 4364               	.LM574:
 4365 08e4 9091 0000 		lds r25,rot_flag
 4366 08e8 9230      		cpi r25,lo8(2)
 4367 08ea 01F0      		breq .+2
 4368 08ec 00C0      		rjmp .L229
1089:main.c        **** 	if ((step_timer < 30) && (last_dir == rot_flag)) {
 4370               	.LM575:
 4371 08ee 8091 0000 		lds r24,step_timer
 4372 08f2 9091 0000 		lds r25,step_timer+1
 4373 08f6 4E97      		sbiw r24,30
 4374 08f8 00F4      		brsh .L243
 4376               	.LM576:
 4377 08fa 8091 0000 		lds r24,rot_flag
 4378 08fe AFAD      		ldd r26,Y+63
 4379 0900 A813      		cpse r26,r24
 4380 0902 00C0      		rjmp .L243
1090:main.c        **** 	  step_timer = 0;
 4382               	.LM577:
 4383 0904 1092 0000 		sts step_timer+1,__zero_reg__
 4384 0908 1092 0000 		sts step_timer,__zero_reg__
1091:main.c        **** 	  steps ++;
 4386               	.LM578:
 4387 090c BFEF      		ldi r27,-1
 4388 090e CB1A      		sub r12,r27
 4389 0910 DB0A      		sbc r13,r27
1092:main.c        **** 	}
1093:main.c        **** 	else {
1094:main.c        **** 	  step_timer = 0;
1095:main.c        **** 	  steps = 1;
1096:main.c        **** 	}
1097:main.c        **** 	
1098:main.c        **** 	if (steps > 500) {
 4391               	.LM579:
 4392 0912 25EF      		ldi r18,-11
 4393 0914 C216      		cp r12,r18
 4394 0916 21E0      		ldi r18,1
 4395 0918 D206      		cpc r13,r18
 4396 091a 00F4      		brsh .L244
 4397 091c 00C0      		rjmp .L351
 4398               	.L243:
1094:main.c        **** 	  steps = 1;
 4400               	.LM580:
 4401 091e 1092 0000 		sts step_timer+1,__zero_reg__
 4402 0922 1092 0000 		sts step_timer,__zero_reg__
1095:main.c        **** 	}
 4404               	.LM581:
 4405 0926 CC24      		clr r12
 4406 0928 C394      		inc r12
 4407 092a D12C      		mov r13,__zero_reg__
 4408 092c 00C0      		rjmp .L246
 4409               	.L244:
1099:main.c        **** 	  if (mode == AM)
 4411               	.LM582:
 4412 092e 8091 0000 		lds r24,mode
 4413 0932 8830      		cpi r24,lo8(8)
 4414 0934 01F4      		brne .L247
1100:main.c        **** 	    freq -= 20;
 4416               	.LM583:
 4417 0936 6091 0000 		lds r22,freq
 4418 093a 7091 0000 		lds r23,freq+1
 4419 093e 8091 0000 		lds r24,freq+2
 4420 0942 9091 0000 		lds r25,freq+3
 4421 0946 20E0      		ldi r18,0
 4422 0948 30E0      		ldi r19,0
 4423 094a 40EA      		ldi r20,lo8(-96)
 4424 094c 51E4      		ldi r21,lo8(65)
 4425 094e 00C0      		rjmp .L341
 4426               	.L247:
1101:main.c        **** 	  else if (mode == FM)
 4428               	.LM584:
 4429 0950 8091 0000 		lds r24,mode
 4430 0954 8A30      		cpi r24,lo8(10)
 4431 0956 01F0      		breq .+2
 4432 0958 00C0      		rjmp .L348
1102:main.c        **** 	    freq -= 50;
 4434               	.LM585:
 4435 095a 6091 0000 		lds r22,freq
 4436 095e 7091 0000 		lds r23,freq+1
 4437 0962 8091 0000 		lds r24,freq+2
 4438 0966 9091 0000 		lds r25,freq+3
 4439 096a 20E0      		ldi r18,0
 4440 096c 30E0      		ldi r19,0
 4441 096e 48E4      		ldi r20,lo8(72)
 4442 0970 52E4      		ldi r21,lo8(66)
 4443 0972 00C0      		rjmp .L341
 4444               	.L351:
1103:main.c        **** 	  else
1104:main.c        **** 	    freq -= 1;
1105:main.c        **** 	}
1106:main.c        **** 	else if (steps > 150) {
 4446               	.LM586:
 4447 0974 87E9      		ldi r24,-105
 4448 0976 C816      		cp r12,r24
 4449 0978 D104      		cpc r13,__zero_reg__
 4450 097a 00F0      		brlo .L246
1107:main.c        **** 	  if (mode == AM)
 4452               	.LM587:
 4453 097c 8091 0000 		lds r24,mode
 4454 0980 8830      		cpi r24,lo8(8)
 4455 0982 01F4      		brne .L249
1108:main.c        **** 	    freq -= 5;
 4457               	.LM588:
 4458 0984 6091 0000 		lds r22,freq
 4459 0988 7091 0000 		lds r23,freq+1
 4460 098c 8091 0000 		lds r24,freq+2
 4461 0990 9091 0000 		lds r25,freq+3
 4462 0994 20E0      		ldi r18,0
 4463 0996 30E0      		ldi r19,0
 4464 0998 40EA      		ldi r20,lo8(-96)
 4465 099a 50E4      		ldi r21,lo8(64)
 4466 099c 00C0      		rjmp .L341
 4467               	.L249:
1109:main.c        **** 	  else if (mode == FM)
 4469               	.LM589:
 4470 099e 8091 0000 		lds r24,mode
 4471 09a2 8A30      		cpi r24,lo8(10)
 4472 09a4 01F4      		brne .L250
1110:main.c        **** 	    freq -= 25;
 4474               	.LM590:
 4475 09a6 6091 0000 		lds r22,freq
 4476 09aa 7091 0000 		lds r23,freq+1
 4477 09ae 8091 0000 		lds r24,freq+2
 4478 09b2 9091 0000 		lds r25,freq+3
 4479 09b6 20E0      		ldi r18,0
 4480 09b8 30E0      		ldi r19,0
 4481 09ba 48EC      		ldi r20,lo8(-56)
 4482 09bc 51E4      		ldi r21,lo8(65)
 4483 09be 00C0      		rjmp .L341
 4484               	.L250:
1111:main.c        **** 	  else
1112:main.c        **** 	    freq -= 0.5;
 4486               	.LM591:
 4487 09c0 6091 0000 		lds r22,freq
 4488 09c4 7091 0000 		lds r23,freq+1
 4489 09c8 8091 0000 		lds r24,freq+2
 4490 09cc 9091 0000 		lds r25,freq+3
 4491 09d0 20E0      		ldi r18,0
 4492 09d2 30E0      		ldi r19,0
 4493 09d4 40E0      		ldi r20,0
 4494 09d6 5FE3      		ldi r21,lo8(63)
 4495 09d8 00C0      		rjmp .L341
 4496               	.L246:
1113:main.c        **** 	}
1114:main.c        **** 	else {
1115:main.c        **** 	  if (mode == AM) {
 4498               	.LM592:
 4499 09da 8091 0000 		lds r24,mode
 4500 09de 8830      		cpi r24,lo8(8)
 4501 09e0 01F4      		brne .L251
1116:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4503               	.LM593:
 4504 09e2 0B9B      		sbis 0x1,3
 4505 09e4 00C0      		rjmp .L252
 4506               	.L348:
1117:main.c        **** 		freq -= 1;
 4508               	.LM594:
 4509 09e6 6091 0000 		lds r22,freq
 4510 09ea 7091 0000 		lds r23,freq+1
 4511 09ee 8091 0000 		lds r24,freq+2
 4512 09f2 9091 0000 		lds r25,freq+3
 4513 09f6 20E0      		ldi r18,0
 4514 09f8 30E0      		ldi r19,0
 4515 09fa 40E8      		ldi r20,lo8(-128)
 4516 09fc 5FE3      		ldi r21,lo8(63)
 4517 09fe 00C0      		rjmp .L341
 4518               	.L252:
1118:main.c        **** 	    else
1119:main.c        **** 	      freq -= 10;
 4520               	.LM595:
 4521 0a00 6091 0000 		lds r22,freq
 4522 0a04 7091 0000 		lds r23,freq+1
 4523 0a08 8091 0000 		lds r24,freq+2
 4524 0a0c 9091 0000 		lds r25,freq+3
 4525 0a10 20E0      		ldi r18,0
 4526 0a12 30E0      		ldi r19,0
 4527 0a14 40E2      		ldi r20,lo8(32)
 4528 0a16 51E4      		ldi r21,lo8(65)
 4529 0a18 00C0      		rjmp .L341
 4530               	.L251:
1120:main.c        **** 	  }
1121:main.c        **** 	  else if (mode == FM)
 4532               	.LM596:
 4533 0a1a 8091 0000 		lds r24,mode
 4534 0a1e 8A30      		cpi r24,lo8(10)
 4535 0a20 01F4      		brne .L253
1122:main.c        **** 	    freq -= 2.5;
 4537               	.LM597:
 4538 0a22 6091 0000 		lds r22,freq
 4539 0a26 7091 0000 		lds r23,freq+1
 4540 0a2a 8091 0000 		lds r24,freq+2
 4541 0a2e 9091 0000 		lds r25,freq+3
 4542 0a32 20E0      		ldi r18,0
 4543 0a34 30E0      		ldi r19,0
 4544 0a36 40E2      		ldi r20,lo8(32)
 4545 0a38 50E4      		ldi r21,lo8(64)
 4546 0a3a 00C0      		rjmp .L341
 4547               	.L253:
1123:main.c        **** 	  else {
1124:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4549               	.LM598:
 4550 0a3c 0B9B      		sbis 0x1,3
 4551 0a3e 00C0      		rjmp .L254
1125:main.c        **** 		freq -= 0.05;
 4553               	.LM599:
 4554 0a40 6091 0000 		lds r22,freq
 4555 0a44 7091 0000 		lds r23,freq+1
 4556 0a48 8091 0000 		lds r24,freq+2
 4557 0a4c 9091 0000 		lds r25,freq+3
 4558 0a50 2DEC      		ldi r18,lo8(-51)
 4559 0a52 3CEC      		ldi r19,lo8(-52)
 4560 0a54 4CE4      		ldi r20,lo8(76)
 4561 0a56 5DE3      		ldi r21,lo8(61)
 4562 0a58 00C0      		rjmp .L341
 4563               	.L254:
1126:main.c        **** 	    else
1127:main.c        **** 	      freq -= 2;
 4565               	.LM600:
 4566 0a5a 6091 0000 		lds r22,freq
 4567 0a5e 7091 0000 		lds r23,freq+1
 4568 0a62 8091 0000 		lds r24,freq+2
 4569 0a66 9091 0000 		lds r25,freq+3
 4570 0a6a 20E0      		ldi r18,0
 4571 0a6c 30E0      		ldi r19,0
 4572 0a6e 40E0      		ldi r20,0
 4573 0a70 50E4      		ldi r21,lo8(64)
 4574               	.L341:
 4575 0a72 0E94 0000 		call __subsf3
 4576 0a76 6093 0000 		sts freq,r22
 4577 0a7a 7093 0000 		sts freq+1,r23
 4578 0a7e 8093 0000 		sts freq+2,r24
 4579 0a82 9093 0000 		sts freq+3,r25
1128:main.c        **** 	  }
1129:main.c        **** 	}
1130:main.c        ****       last_dir = 0x02;
 4581               	.LM601:
 4582 0a86 82E0      		ldi r24,lo8(2)
 4583               	.L229:
1131:main.c        ****       }
1132:main.c        ****       //_delay_ms(30);
1133:main.c        **** 
1134:main.c        ****       rot_flag = 0x00;
 4585               	.LM602:
 4586 0a88 1092 0000 		sts rot_flag,__zero_reg__
 4587 0a8c 8FAF      		std Y+63,r24
 4588 0a8e 00C0      		rjmp .L161
 4589               	.L227:
1135:main.c        ****     }
1136:main.c        ****     else if (vol_flag) {
 4591               	.LM603:
 4592 0a90 8091 0000 		lds r24,vol_flag
 4593 0a94 8823      		tst r24
 4594 0a96 01F4      		brne .+2
 4595 0a98 00C0      		rjmp .L161
1137:main.c        ****       if (vol_timer > 1) {
 4597               	.LM604:
 4598 0a9a 8091 0000 		lds r24,vol_timer
 4599 0a9e 8230      		cpi r24,lo8(2)
 4600 0aa0 00F4      		brsh .+2
 4601 0aa2 00C0      		rjmp .L255
1138:main.c        **** 	if (PINF & (1 << SQUELCH_BUTTON)) {
 4603               	.LM605:
 4604 0aa4 049B      		sbis 0,4
 4605 0aa6 00C0      		rjmp .L256
1139:main.c        **** 	    if (vol_flag == 0x01) {
 4607               	.LM606:
 4608 0aa8 8091 0000 		lds r24,vol_flag
 4609 0aac 8130      		cpi r24,lo8(1)
 4610 0aae 01F4      		brne .L257
1140:main.c        **** 	      if(vol<31)
 4612               	.LM607:
 4613 0ab0 9EE1      		ldi r25,lo8(30)
 4614 0ab2 9A15      		cp r25,r10
 4615 0ab4 00F0      		brlo .L260
1141:main.c        **** 		vol ++; // Higher means lower 
 4617               	.LM608:
 4618 0ab6 A394      		inc r10
 4619 0ab8 00C0      		rjmp .L260
 4620               	.L257:
1142:main.c        **** 	      sprintf(buffer,"Vol %d    ", 31-vol);
1143:main.c        **** 	      lcd_goto(0x40);
1144:main.c        **** 	      lcd_puts(buffer);
1145:main.c        **** 	    }
1146:main.c        **** 	    else if (vol_flag == 0x02) {
 4622               	.LM609:
 4623 0aba 8091 0000 		lds r24,vol_flag
 4624 0abe 8230      		cpi r24,lo8(2)
 4625 0ac0 01F4      		brne .L259
1147:main.c        **** 	      if(vol>0)
 4627               	.LM610:
 4628 0ac2 A110      		cpse r10,__zero_reg__
1148:main.c        **** 		vol --;
 4630               	.LM611:
 4631 0ac4 AA94      		dec r10
 4632               	.L260:
1149:main.c        **** 	      sprintf(buffer,"Vol %d    ", 31-vol);
 4634               	.LM612:
 4635 0ac6 8FE1      		ldi r24,lo8(31)
 4636 0ac8 90E0      		ldi r25,0
 4637 0aca 8A19      		sub r24,r10
 4638 0acc 9109      		sbc r25,__zero_reg__
 4639 0ace 9F93      		push r25
 4640 0ad0 8F93      		push r24
 4641 0ad2 80E0      		ldi r24,lo8(.LC21)
 4642 0ad4 90E0      		ldi r25,hi8(.LC21)
 4643 0ad6 9F93      		push r25
 4644 0ad8 8F93      		push r24
 4645 0ada 1F93      		push r17
 4646 0adc 0F93      		push r16
 4647 0ade 0E94 0000 		call sprintf
1150:main.c        **** 	      lcd_goto(0x40);
 4649               	.LM613:
 4650 0ae2 80E4      		ldi r24,lo8(64)
 4651 0ae4 0E94 0000 		call lcd_goto
1151:main.c        **** 	      lcd_puts(buffer);
 4653               	.LM614:
 4654 0ae8 C801      		movw r24,r16
 4655 0aea 0E94 0000 		call lcd_puts
 4656 0aee 0F90      		pop __tmp_reg__
 4657 0af0 0F90      		pop __tmp_reg__
 4658 0af2 0F90      		pop __tmp_reg__
 4659 0af4 0F90      		pop __tmp_reg__
 4660 0af6 0F90      		pop __tmp_reg__
 4661 0af8 0F90      		pop __tmp_reg__
 4662               	.L259:
1152:main.c        **** 	    }
1153:main.c        **** 	    
1154:main.c        **** 	    err = updateVolumeSquelch(vol, squelch);
 4664               	.LM615:
 4665 0afa 6B2D      		mov r22,r11
 4666 0afc 8A2D      		mov r24,r10
 4667 0afe 0E94 0000 		call updateVolumeSquelch
1155:main.c        **** 	    
1156:main.c        **** 	    if (err) {
 4669               	.LM616:
 4670 0b02 8823      		tst r24
 4671 0b04 01F4      		brne .+2
 4672 0b06 00C0      		rjmp .L261
1157:main.c        **** 	      sprintf(buffer,"Err Vol %x         ",err);
 4674               	.LM617:
 4675 0b08 1F92      		push __zero_reg__
 4676 0b0a 8F93      		push r24
 4677 0b0c 80E0      		ldi r24,lo8(.LC22)
 4678 0b0e 90E0      		ldi r25,hi8(.LC22)
 4679 0b10 00C0      		rjmp .L342
 4680               	.L256:
1158:main.c        **** 	      lcd_goto(0x40);
1159:main.c        **** 	      lcd_puts(buffer);	
1160:main.c        **** 	    }      
1161:main.c        **** 	  }
1162:main.c        **** 	  else {
1163:main.c        **** 	    if (vol_flag == 0x02) {
 4682               	.LM618:
 4683 0b12 8091 0000 		lds r24,vol_flag
 4684 0b16 8230      		cpi r24,lo8(2)
 4685 0b18 01F4      		brne .L262
1164:main.c        **** 	      if(squelch<31)
 4687               	.LM619:
 4688 0b1a AEE1      		ldi r26,lo8(30)
 4689 0b1c AB15      		cp r26,r11
 4690 0b1e 00F0      		brlo .L265
1165:main.c        **** 		squelch ++; 
 4692               	.LM620:
 4693 0b20 B394      		inc r11
 4694 0b22 00C0      		rjmp .L265
 4695               	.L262:
1166:main.c        **** 	      sprintf(buffer,"Sq %d    ", squelch);
1167:main.c        **** 	      lcd_goto(0x40);
1168:main.c        **** 	      lcd_puts(buffer);
1169:main.c        **** 	    }
1170:main.c        **** 	    else if (vol_flag == 0x01) {
 4697               	.LM621:
 4698 0b24 8091 0000 		lds r24,vol_flag
 4699 0b28 8130      		cpi r24,lo8(1)
 4700 0b2a 01F4      		brne .L264
1171:main.c        **** 	      if(squelch>0)
 4702               	.LM622:
 4703 0b2c B110      		cpse r11,__zero_reg__
1172:main.c        **** 		squelch --;
 4705               	.LM623:
 4706 0b2e BA94      		dec r11
 4707               	.L265:
1173:main.c        **** 	      sprintf(buffer,"Sq %d    ", squelch);
 4709               	.LM624:
 4710 0b30 1F92      		push __zero_reg__
 4711 0b32 BF92      		push r11
 4712 0b34 80E0      		ldi r24,lo8(.LC23)
 4713 0b36 90E0      		ldi r25,hi8(.LC23)
 4714 0b38 9F93      		push r25
 4715 0b3a 8F93      		push r24
 4716 0b3c 1F93      		push r17
 4717 0b3e 0F93      		push r16
 4718 0b40 0E94 0000 		call sprintf
1174:main.c        **** 	      lcd_goto(0x40);
 4720               	.LM625:
 4721 0b44 80E4      		ldi r24,lo8(64)
 4722 0b46 0E94 0000 		call lcd_goto
1175:main.c        **** 	      lcd_puts(buffer);
 4724               	.LM626:
 4725 0b4a C801      		movw r24,r16
 4726 0b4c 0E94 0000 		call lcd_puts
 4727 0b50 0F90      		pop __tmp_reg__
 4728 0b52 0F90      		pop __tmp_reg__
 4729 0b54 0F90      		pop __tmp_reg__
 4730 0b56 0F90      		pop __tmp_reg__
 4731 0b58 0F90      		pop __tmp_reg__
 4732 0b5a 0F90      		pop __tmp_reg__
 4733               	.L264:
1176:main.c        **** 	    }
1177:main.c        **** 	    
1178:main.c        **** 	    err = updateVolumeSquelch(vol, squelch);
 4735               	.LM627:
 4736 0b5c 6B2D      		mov r22,r11
 4737 0b5e 8A2D      		mov r24,r10
 4738 0b60 0E94 0000 		call updateVolumeSquelch
1179:main.c        **** 	    
1180:main.c        **** 	    if (err) {
 4740               	.LM628:
 4741 0b64 8823      		tst r24
 4742 0b66 01F0      		breq .L261
1181:main.c        **** 	      sprintf(buffer,"Err Sq %x         ",err);
 4744               	.LM629:
 4745 0b68 1F92      		push __zero_reg__
 4746 0b6a 8F93      		push r24
 4747 0b6c 80E0      		ldi r24,lo8(.LC24)
 4748 0b6e 90E0      		ldi r25,hi8(.LC24)
 4749               	.L342:
 4750 0b70 9F93      		push r25
 4751 0b72 8F93      		push r24
 4752 0b74 1F93      		push r17
 4753 0b76 0F93      		push r16
 4754 0b78 0E94 0000 		call sprintf
1182:main.c        **** 	      lcd_goto(0x40);
 4756               	.LM630:
 4757 0b7c 80E4      		ldi r24,lo8(64)
 4758 0b7e 0E94 0000 		call lcd_goto
1183:main.c        **** 	      lcd_puts(buffer);	
 4760               	.LM631:
 4761 0b82 C801      		movw r24,r16
 4762 0b84 0E94 0000 		call lcd_puts
 4763 0b88 0F90      		pop __tmp_reg__
 4764 0b8a 0F90      		pop __tmp_reg__
 4765 0b8c 0F90      		pop __tmp_reg__
 4766 0b8e 0F90      		pop __tmp_reg__
 4767 0b90 0F90      		pop __tmp_reg__
 4768 0b92 0F90      		pop __tmp_reg__
 4769               	.L261:
1184:main.c        **** 	    }      
1185:main.c        **** 	  }
1186:main.c        **** 	vol_timer = 0;
 4771               	.LM632:
 4772 0b94 1092 0000 		sts vol_timer,__zero_reg__
 4773               	.L255:
1187:main.c        ****       }
1188:main.c        ****       vol_flag = 0x00;
 4775               	.LM633:
 4776 0b98 1092 0000 		sts vol_flag,__zero_reg__
 4777 0b9c 00C0      		rjmp .L161
 4792               	.Lscope31:
 4793               		.section	.progmem.data,"a",@progbits
 4796               	string_intro_row2.2454:
 4797 0000 5374 6172 		.string	"Starting radio"
 4797      7469 6E67 
 4797      2072 6164 
 4797      696F 00
 4800               	string_intro_row1.2453:
 4801 000f 2A2A 2A20 		.string	"*** SM6VFZ"
 4801      534D 3656 
 4801      465A 00
 4802               		.local	ftw_botbot.2410
 4803               		.comm	ftw_botbot.2410,4,1
 4804               		.local	ftw_bottop.2409
 4805               		.comm	ftw_bottop.2409,4,1
 4806               		.local	ftw_topbot.2408
 4807               		.comm	ftw_topbot.2408,4,1
 4808               		.local	ftw_toptop.2407
 4809               		.comm	ftw_toptop.2407,4,1
 4810               	.global	freq_offset
 4811               		.section .bss
 4814               	freq_offset:
 4815 0000 0000      		.zero	2
 4816               	.global	clar
 4819               	clar:
 4820 0002 00        		.zero	1
 4821               		.comm	freq,4,1
 4822               		.comm	rffe_rx_att,1,1
 4823               		.comm	rx_att,1,1
 4824               	.global	pll_n
 4827               	pll_n:
 4828 0003 0000      		.zero	2
 4829               		.comm	tx,2,1
 4830               		.comm	bandf,2,1
 4831               	.global	vol_timer
 4832               		.data
 4835               	vol_timer:
 4836 0000 FF        		.byte	-1
 4837               	.global	band_timer
 4840               	band_timer:
 4841 0001 FF        		.byte	-1
 4842               		.comm	tx_att,1,1
 4843               		.comm	band,1,1
 4844               		.comm	mode,1,1
 4845               		.comm	step_timer,2,1
 4846               		.comm	vol_flag,1,1
 4847               		.comm	timer_flag,1,1
 4848               		.comm	band_flag,1,1
 4849               		.comm	mode_flag,1,1
 4850               		.comm	rot_flag,1,1
 4870               		.text
 4872               	.Letext0:
 4873               		.ident	"GCC: (GNU) 4.9.2"
 4874               	.global __do_copy_data
 4875               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc1eZk18.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc1eZk18.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc1eZk18.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc1eZk18.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc1eZk18.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc1eZk18.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc1eZk18.s:125    .text:0000000000000000 __vector_15
                            *COM*:0000000000000002 step_timer
     /tmp/cc1eZk18.s:172    .text:0000000000000040 __vector_12
                            *COM*:0000000000000001 timer_flag
     /tmp/cc1eZk18.s:204    .text:000000000000005e __vector_3
                            *COM*:0000000000000001 rot_flag
     /tmp/cc1eZk18.s:295    .text:00000000000000a4 __vector_4
     /tmp/cc1eZk18.s:386    .text:00000000000000ea __vector_5
     /tmp/cc1eZk18.s:483    .text:000000000000013c __vector_6
     /tmp/cc1eZk18.s:580    .text:000000000000018e __vector_7
                            *COM*:0000000000000001 vol_flag
     /tmp/cc1eZk18.s:677    .text:00000000000001e0 __vector_8
     /tmp/cc1eZk18.s:774    .text:0000000000000232 TWIinit
     /tmp/cc1eZk18.s:796    .text:0000000000000240 TWIStart
     /tmp/cc1eZk18.s:823    .text:0000000000000250 TWIStop
     /tmp/cc1eZk18.s:842    .text:0000000000000258 TWIWrite
     /tmp/cc1eZk18.s:872    .text:000000000000026c TWIReadACK
     /tmp/cc1eZk18.s:901    .text:0000000000000280 TWIReadNACK
     /tmp/cc1eZk18.s:930    .text:0000000000000294 TWIGetStatus
     /tmp/cc1eZk18.s:952    .text:000000000000029c TWI_write_byte
     /tmp/cc1eZk18.s:1082   .text:000000000000030c TWI_read_byte
     /tmp/cc1eZk18.s:1192   .text:0000000000000370 TWI_write_word
     /tmp/cc1eZk18.s:1360   .text:0000000000000400 TWI_write_3bytes
     /tmp/cc1eZk18.s:1545   .text:00000000000004a6 TWI_write_4bytes
     /tmp/cc1eZk18.s:1749   .text:0000000000000560 TWI_write_5bytes
     /tmp/cc1eZk18.s:1983   .text:000000000000062e lcd_freq
                            *COM*:0000000000000001 mode
                            *COM*:0000000000000004 freq
     /tmp/cc1eZk18.s:4814   .bss:0000000000000000 freq_offset
     /tmp/cc1eZk18.s:4819   .bss:0000000000000002 clar
     /tmp/cc1eZk18.s:2177   .text:000000000000078e updateVolumeSquelch
     /tmp/cc1eZk18.s:2207   .text:00000000000007a8 readClar
     /tmp/cc1eZk18.s:2227   .text:00000000000007ae updateRFFE
                            *COM*:0000000000000001 rx_att
     /tmp/cc1eZk18.s:4827   .bss:0000000000000003 pll_n
                            *COM*:0000000000000002 tx
                            *COM*:0000000000000002 bandf
     /tmp/cc1eZk18.s:2306   .text:0000000000000810 updateFreq
     /tmp/cc1eZk18.s:4807   .bss:0000000000000011 ftw_toptop.2407
     /tmp/cc1eZk18.s:4805   .bss:000000000000000d ftw_topbot.2408
     /tmp/cc1eZk18.s:4803   .bss:0000000000000009 ftw_bottop.2409
                             .bss:0000000000000005 ftw_botbot.2410
     /tmp/cc1eZk18.s:2556   .text:00000000000009f4 updateSettings
                            *COM*:0000000000000001 tx_att
     /tmp/cc1eZk18.s:2704   .text:0000000000000abe adcInit
     /tmp/cc1eZk18.s:2729   .text:0000000000000aca Timer0Init
     /tmp/cc1eZk18.s:2756   .text:0000000000000ada Timer1Init
     /tmp/cc1eZk18.s:2834   .text.startup:0000000000000000 main
     /tmp/cc1eZk18.s:4800   .progmem.data:000000000000000f string_intro_row1.2453
     /tmp/cc1eZk18.s:4796   .progmem.data:0000000000000000 string_intro_row2.2454
                            *COM*:0000000000000001 mode_flag
                            *COM*:0000000000000001 band_flag
                            *COM*:0000000000000001 band
                            *COM*:0000000000000001 rffe_rx_att
     /tmp/cc1eZk18.s:4835   .data:0000000000000000 vol_timer
     /tmp/cc1eZk18.s:4840   .data:0000000000000001 band_timer

UNDEFINED SYMBOLS
__divsf3
__floatsisf
__addsf3
__fixsfsi
round
lcd_goto
fmod
floor
sprintf
lcd_puts
strcpy
__subsf3
__mulsf3
__fixunssfsi
__nesf2
__ltsf2
lcd_init
lcd_clrscr
strcpy_P
__do_copy_data
__do_clear_bss
