   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 123               	.global	__vector_15
 125               	__vector_15:
   1:main.c        **** #define F_CPU 1000000UL
   2:main.c        **** 
   3:main.c        **** #include <avr/io.h>
   4:main.c        **** #include <avr/wdt.h>
   5:main.c        **** #include <avr/sleep.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #include <util/delay.h>
   8:main.c        **** #include <math.h>
   9:main.c        **** #include <string.h>
  10:main.c        **** #include <stdio.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <stdbool.h>
  14:main.c        **** #include <avr/pgmspace.h>
  15:main.c        **** #include "hd44780.h"
  16:main.c        **** #include "build_settings.h"
  17:main.c        **** 
  18:main.c        **** #define fpga_addr 0x23
  19:main.c        **** #define pll_addr 0x22
  20:main.c        **** 
  21:main.c        **** #define ROT1_A PE4
  22:main.c        **** #define ROT1_B PE5
  23:main.c        **** #define ROT2_A PD2
  24:main.c        **** #define ROT2_B PD3
  25:main.c        **** #define ROT_BUTTON PE3
  26:main.c        **** #define SQUELCH_BUTTON PF4
  27:main.c        **** #define MENU_BUTTON PF2
  28:main.c        **** #define MODE_BUTTON PF1
  29:main.c        **** #define BAND_BUTTON PF0
  30:main.c        **** #define VOLROT_A PE6
  31:main.c        **** #define VOLROT_B PE7
  32:main.c        **** #define VOL_BUTTON PF4
  33:main.c        **** #define FREQ_BUTTON PE3
  34:main.c        **** #define CLAR_POT PF3
  35:main.c        **** #define MUTE PE0
  36:main.c        **** 
  37:main.c        **** #define LED_RED PD6
  38:main.c        **** #define LED_GREEN PD5
  39:main.c        **** 
  40:main.c        **** #define LSB 0x01
  41:main.c        **** #define LSBN 0x02
  42:main.c        **** #define USB 0x03
  43:main.c        **** #define USBN 0x04
  44:main.c        **** #define CW 0x05
  45:main.c        **** #define CWN 0x06
  46:main.c        **** #define CWNN 0x07
  47:main.c        **** #define AM 0x08
  48:main.c        **** #define AMN 0x09
  49:main.c        **** #define FM 0x0A
  50:main.c        **** 
  51:main.c        **** 
  52:main.c        **** volatile uint8_t rot_flag, mode_flag, band_flag, timer_flag, vol_flag;
  53:main.c        **** volatile uint16_t step_timer;
  54:main.c        **** volatile uint8_t mode;
  55:main.c        **** volatile uint8_t band;
  56:main.c        **** volatile uint8_t tx_att;
  57:main.c        **** volatile uint8_t band_timer = 255, vol_timer = 255;
  58:main.c        **** volatile uint16_t bandf, tx, pll_n = 0;
  59:main.c        **** volatile uint8_t rx_att;
  60:main.c        **** volatile bool rffe_rx_att;
  61:main.c        **** volatile double freq;
  62:main.c        **** volatile uint8_t clar = 0;
  63:main.c        **** volatile int freq_offset = 0; // offset in MHz for display
  64:main.c        **** 
  65:main.c        **** 
  66:main.c        **** ISR(TIMER0_COMP_vect) {
 127               	.LM0:
 128               	.LFBB1:
 129 0000 1F92      		push r1
 130 0002 0F92      		push r0
 131 0004 0FB6      		in r0,__SREG__
 132 0006 0F92      		push r0
 133 0008 1124      		clr __zero_reg__
 134 000a 2F93      		push r18
 135 000c 8F93      		push r24
 136 000e 9F93      		push r25
 137               	/* prologue: Signal */
 138               	/* frame size = 0 */
 139               	/* stack size = 6 */
 140               	.L__stack_usage = 6
  67:main.c        ****   if (step_timer < 500)
 142               	.LM1:
 143 0010 8091 0000 		lds r24,step_timer
 144 0014 9091 0000 		lds r25,step_timer+1
 145 0018 843F      		cpi r24,-12
 146 001a 9140      		sbci r25,1
 147 001c 00F4      		brsh .L1
  68:main.c        ****     step_timer ++;
 149               	.LM2:
 150 001e 8091 0000 		lds r24,step_timer
 151 0022 9091 0000 		lds r25,step_timer+1
 152 0026 0196      		adiw r24,1
 153 0028 9093 0000 		sts step_timer+1,r25
 154 002c 8093 0000 		sts step_timer,r24
 155               	.L1:
 156               	/* epilogue start */
  69:main.c        **** }
 158               	.LM3:
 159 0030 9F91      		pop r25
 160 0032 8F91      		pop r24
 161 0034 2F91      		pop r18
 162 0036 0F90      		pop r0
 163 0038 0FBE      		out __SREG__,r0
 164 003a 0F90      		pop r0
 165 003c 1F90      		pop r1
 166 003e 1895      		reti
 168               	.Lscope1:
 170               	.global	__vector_12
 172               	__vector_12:
  70:main.c        **** 
  71:main.c        **** ISR(TIMER1_COMPA_vect) {
 174               	.LM4:
 175               	.LFBB2:
 176 0040 1F92      		push r1
 177 0042 0F92      		push r0
 178 0044 0FB6      		in r0,__SREG__
 179 0046 0F92      		push r0
 180 0048 1124      		clr __zero_reg__
 181 004a 8F93      		push r24
 182               	/* prologue: Signal */
 183               	/* frame size = 0 */
 184               	/* stack size = 4 */
 185               	.L__stack_usage = 4
  72:main.c        ****   timer_flag = 1;
 187               	.LM5:
 188 004c 81E0      		ldi r24,lo8(1)
 189 004e 8093 0000 		sts timer_flag,r24
 190               	/* epilogue start */
  73:main.c        ****   
  74:main.c        **** }
 192               	.LM6:
 193 0052 8F91      		pop r24
 194 0054 0F90      		pop r0
 195 0056 0FBE      		out __SREG__,r0
 196 0058 0F90      		pop r0
 197 005a 1F90      		pop r1
 198 005c 1895      		reti
 200               	.Lscope2:
 202               	.global	__vector_3
 204               	__vector_3:
  75:main.c        **** 
  76:main.c        **** 
  77:main.c        **** ISR(INT2_vect) {  // falling level on INT2
 206               	.LM7:
 207               	.LFBB3:
 208 005e 1F92      		push r1
 209 0060 0F92      		push r0
 210 0062 0FB6      		in r0,__SREG__
 211 0064 0F92      		push r0
 212 0066 1124      		clr __zero_reg__
 213 0068 8F93      		push r24
 214               	/* prologue: Signal */
 215               	/* frame size = 0 */
 216               	/* stack size = 4 */
 217               	.L__stack_usage = 4
  78:main.c        ****   if(!(PIND & (1 << ROT2_A))) {
 219               	.LM8:
 220 006a 8299      		sbic 0x10,2
 221 006c 00C0      		rjmp .L5
 222               	.LBB231:
 223               	.LBB232:
 225               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 227               	.LM9:
 228 006e 86E0      		ldi r24,lo8(6)
 229 0070 8A95      	1:	dec r24
 230 0072 01F4      		brne 1b
 231 0074 00C0      		rjmp .
 232               	.LBE232:
 233               	.LBE231:
 235               	.Ltext2:
  79:main.c        ****     _delay_us(20);
  80:main.c        ****     if ((PIND & (1 << ROT2_B))) {
 237               	.LM10:
 238 0076 839B      		sbis 0x10,3
 239 0078 00C0      		rjmp .L5
 240               	.LBB233:
 241               	.LBB234:
 243               	.Ltext3:
 245               	.LM11:
 246 007a 86E0      		ldi r24,lo8(6)
 247 007c 8A95      	1:	dec r24
 248 007e 01F4      		brne 1b
 249 0080 00C0      		rjmp .
 250               	.LBE234:
 251               	.LBE233:
 253               	.Ltext4:
  81:main.c        ****       _delay_us(20);
  82:main.c        ****       if (!(PIND & (1 << ROT2_A)) && (PIND & (1 << ROT2_B))) {
 255               	.LM12:
 256 0082 8299      		sbic 0x10,2
 257 0084 00C0      		rjmp .L5
 259               	.LM13:
 260 0086 839B      		sbis 0x10,3
 261 0088 00C0      		rjmp .L5
 262               	.LBB235:
 263               	.LBB236:
 265               	.Ltext5:
 267               	.LM14:
 268 008a 81E2      		ldi r24,lo8(33)
 269 008c 8A95      	1:	dec r24
 270 008e 01F4      		brne 1b
 271 0090 0000      		nop
 272               	.LBE236:
 273               	.LBE235:
 275               	.Ltext6:
  83:main.c        **** 	_delay_us(100);
  84:main.c        **** 	rot_flag = 0x01;
 277               	.LM15:
 278 0092 81E0      		ldi r24,lo8(1)
 279 0094 8093 0000 		sts rot_flag,r24
 280               	.L5:
 281               	/* epilogue start */
  85:main.c        ****       }
  86:main.c        ****     }
  87:main.c        ****   }
  88:main.c        **** }
 283               	.LM16:
 284 0098 8F91      		pop r24
 285 009a 0F90      		pop r0
 286 009c 0FBE      		out __SREG__,r0
 287 009e 0F90      		pop r0
 288 00a0 1F90      		pop r1
 289 00a2 1895      		reti
 291               	.Lscope3:
 293               	.global	__vector_4
 295               	__vector_4:
  89:main.c        **** 
  90:main.c        **** ISR(INT3_vect) {  // falling level on INT3
 297               	.LM17:
 298               	.LFBB4:
 299 00a4 1F92      		push r1
 300 00a6 0F92      		push r0
 301 00a8 0FB6      		in r0,__SREG__
 302 00aa 0F92      		push r0
 303 00ac 1124      		clr __zero_reg__
 304 00ae 8F93      		push r24
 305               	/* prologue: Signal */
 306               	/* frame size = 0 */
 307               	/* stack size = 4 */
 308               	.L__stack_usage = 4
  91:main.c        ****   if (!(PIND & (1 << ROT2_B))) {
 310               	.LM18:
 311 00b0 8399      		sbic 0x10,3
 312 00b2 00C0      		rjmp .L15
 313               	.LBB237:
 314               	.LBB238:
 316               	.Ltext7:
 318               	.LM19:
 319 00b4 86E0      		ldi r24,lo8(6)
 320 00b6 8A95      	1:	dec r24
 321 00b8 01F4      		brne 1b
 322 00ba 00C0      		rjmp .
 323               	.LBE238:
 324               	.LBE237:
 326               	.Ltext8:
  92:main.c        ****    _delay_us(20);
  93:main.c        ****     if ((PIND & (1 << ROT2_A))) {
 328               	.LM20:
 329 00bc 829B      		sbis 0x10,2
 330 00be 00C0      		rjmp .L15
 331               	.LBB239:
 332               	.LBB240:
 334               	.Ltext9:
 336               	.LM21:
 337 00c0 86E0      		ldi r24,lo8(6)
 338 00c2 8A95      	1:	dec r24
 339 00c4 01F4      		brne 1b
 340 00c6 00C0      		rjmp .
 341               	.LBE240:
 342               	.LBE239:
 344               	.Ltext10:
  94:main.c        ****       _delay_us(20);
  95:main.c        ****       if ((PIND & (1 << ROT2_A)) && !(PIND & (1 << ROT2_B))) {
 346               	.LM22:
 347 00c8 829B      		sbis 0x10,2
 348 00ca 00C0      		rjmp .L15
 350               	.LM23:
 351 00cc 8399      		sbic 0x10,3
 352 00ce 00C0      		rjmp .L15
 353               	.LBB241:
 354               	.LBB242:
 356               	.Ltext11:
 358               	.LM24:
 359 00d0 81E2      		ldi r24,lo8(33)
 360 00d2 8A95      	1:	dec r24
 361 00d4 01F4      		brne 1b
 362 00d6 0000      		nop
 363               	.LBE242:
 364               	.LBE241:
 366               	.Ltext12:
  96:main.c        **** 	_delay_us(100);
  97:main.c        **** 	rot_flag = 0x02;
 368               	.LM25:
 369 00d8 82E0      		ldi r24,lo8(2)
 370 00da 8093 0000 		sts rot_flag,r24
 371               	.L15:
 372               	/* epilogue start */
  98:main.c        ****       }
  99:main.c        ****     }
 100:main.c        ****   }
 101:main.c        **** }
 374               	.LM26:
 375 00de 8F91      		pop r24
 376 00e0 0F90      		pop r0
 377 00e2 0FBE      		out __SREG__,r0
 378 00e4 0F90      		pop r0
 379 00e6 1F90      		pop r1
 380 00e8 1895      		reti
 382               	.Lscope4:
 384               	.global	__vector_5
 386               	__vector_5:
 102:main.c        **** 
 103:main.c        **** ISR(INT4_vect) {  // falling level on INT4
 388               	.LM27:
 389               	.LFBB5:
 390 00ea 1F92      		push r1
 391 00ec 0F92      		push r0
 392 00ee 0FB6      		in r0,__SREG__
 393 00f0 0F92      		push r0
 394 00f2 1124      		clr __zero_reg__
 395 00f4 8F93      		push r24
 396 00f6 9F93      		push r25
 397               	/* prologue: Signal */
 398               	/* frame size = 0 */
 399               	/* stack size = 5 */
 400               	.L__stack_usage = 5
 104:main.c        ****   if(!(PINE & (1 << ROT1_A))) {
 402               	.LM28:
 403 00f8 0C99      		sbic 0x1,4
 404 00fa 00C0      		rjmp .L25
 405               	.LBB243:
 406               	.LBB244:
 408               	.Ltext13:
 410               	.LM29:
 411 00fc 83EF      		ldi r24,lo8(499)
 412 00fe 91E0      		ldi r25,hi8(499)
 413 0100 0197      	1:	sbiw r24,1
 414 0102 01F4      		brne 1b
 415 0104 00C0      		rjmp .
 416 0106 0000      		nop
 417               	.LBE244:
 418               	.LBE243:
 420               	.Ltext14:
 105:main.c        ****     _delay_us(2000);
 106:main.c        ****     if ((PINE & (1 << ROT1_B))) {
 422               	.LM30:
 423 0108 0D9B      		sbis 0x1,5
 424 010a 00C0      		rjmp .L25
 425               	.LBB245:
 426               	.LBB246:
 428               	.Ltext15:
 430               	.LM31:
 431 010c 83EF      		ldi r24,lo8(499)
 432 010e 91E0      		ldi r25,hi8(499)
 433 0110 0197      	1:	sbiw r24,1
 434 0112 01F4      		brne 1b
 435 0114 00C0      		rjmp .
 436 0116 0000      		nop
 437               	.LBE246:
 438               	.LBE245:
 440               	.Ltext16:
 107:main.c        ****       _delay_us(2000);
 108:main.c        ****       if (!(PINE & (1 << ROT1_A)) && (PINE & (1 << ROT1_B))) {
 442               	.LM32:
 443 0118 0C99      		sbic 0x1,4
 444 011a 00C0      		rjmp .L25
 446               	.LM33:
 447 011c 0D9B      		sbis 0x1,5
 448 011e 00C0      		rjmp .L25
 449               	.LBB247:
 450               	.LBB248:
 452               	.Ltext17:
 454               	.LM34:
 455 0120 91E2      		ldi r25,lo8(33)
 456 0122 9A95      	1:	dec r25
 457 0124 01F4      		brne 1b
 458 0126 0000      		nop
 459               	.LBE248:
 460               	.LBE247:
 462               	.Ltext18:
 109:main.c        **** 	_delay_us(100);
 110:main.c        **** 	rot_flag = 0x01;
 464               	.LM35:
 465 0128 81E0      		ldi r24,lo8(1)
 466 012a 8093 0000 		sts rot_flag,r24
 467               	.L25:
 468               	/* epilogue start */
 111:main.c        ****       }
 112:main.c        ****     }
 113:main.c        ****   }
 114:main.c        **** }
 470               	.LM36:
 471 012e 9F91      		pop r25
 472 0130 8F91      		pop r24
 473 0132 0F90      		pop r0
 474 0134 0FBE      		out __SREG__,r0
 475 0136 0F90      		pop r0
 476 0138 1F90      		pop r1
 477 013a 1895      		reti
 479               	.Lscope5:
 481               	.global	__vector_6
 483               	__vector_6:
 115:main.c        **** 
 116:main.c        **** ISR(INT5_vect) {  // falling level on INT5
 485               	.LM37:
 486               	.LFBB6:
 487 013c 1F92      		push r1
 488 013e 0F92      		push r0
 489 0140 0FB6      		in r0,__SREG__
 490 0142 0F92      		push r0
 491 0144 1124      		clr __zero_reg__
 492 0146 8F93      		push r24
 493 0148 9F93      		push r25
 494               	/* prologue: Signal */
 495               	/* frame size = 0 */
 496               	/* stack size = 5 */
 497               	.L__stack_usage = 5
 117:main.c        ****   if (!(PINE & (1 << ROT1_B))) {
 499               	.LM38:
 500 014a 0D99      		sbic 0x1,5
 501 014c 00C0      		rjmp .L35
 502               	.LBB249:
 503               	.LBB250:
 505               	.Ltext19:
 507               	.LM39:
 508 014e 83EF      		ldi r24,lo8(499)
 509 0150 91E0      		ldi r25,hi8(499)
 510 0152 0197      	1:	sbiw r24,1
 511 0154 01F4      		brne 1b
 512 0156 00C0      		rjmp .
 513 0158 0000      		nop
 514               	.LBE250:
 515               	.LBE249:
 517               	.Ltext20:
 118:main.c        ****    _delay_us(2000);
 119:main.c        ****     if ((PINE & (1 << ROT1_A))) {
 519               	.LM40:
 520 015a 0C9B      		sbis 0x1,4
 521 015c 00C0      		rjmp .L35
 522               	.LBB251:
 523               	.LBB252:
 525               	.Ltext21:
 527               	.LM41:
 528 015e 83EF      		ldi r24,lo8(499)
 529 0160 91E0      		ldi r25,hi8(499)
 530 0162 0197      	1:	sbiw r24,1
 531 0164 01F4      		brne 1b
 532 0166 00C0      		rjmp .
 533 0168 0000      		nop
 534               	.LBE252:
 535               	.LBE251:
 537               	.Ltext22:
 120:main.c        ****       _delay_us(2000);
 121:main.c        ****       if ((PINE & (1 << ROT1_A)) && !(PINE & (1 << ROT1_B))) {
 539               	.LM42:
 540 016a 0C9B      		sbis 0x1,4
 541 016c 00C0      		rjmp .L35
 543               	.LM43:
 544 016e 0D99      		sbic 0x1,5
 545 0170 00C0      		rjmp .L35
 546               	.LBB253:
 547               	.LBB254:
 549               	.Ltext23:
 551               	.LM44:
 552 0172 91E2      		ldi r25,lo8(33)
 553 0174 9A95      	1:	dec r25
 554 0176 01F4      		brne 1b
 555 0178 0000      		nop
 556               	.LBE254:
 557               	.LBE253:
 559               	.Ltext24:
 122:main.c        **** 	_delay_us(100);
 123:main.c        **** 	rot_flag = 0x02;
 561               	.LM45:
 562 017a 82E0      		ldi r24,lo8(2)
 563 017c 8093 0000 		sts rot_flag,r24
 564               	.L35:
 565               	/* epilogue start */
 124:main.c        ****       }
 125:main.c        ****     }
 126:main.c        ****   }
 127:main.c        **** }
 567               	.LM46:
 568 0180 9F91      		pop r25
 569 0182 8F91      		pop r24
 570 0184 0F90      		pop r0
 571 0186 0FBE      		out __SREG__,r0
 572 0188 0F90      		pop r0
 573 018a 1F90      		pop r1
 574 018c 1895      		reti
 576               	.Lscope6:
 578               	.global	__vector_7
 580               	__vector_7:
 128:main.c        **** 
 129:main.c        **** ISR(INT6_vect) {  // falling level on INT6
 582               	.LM47:
 583               	.LFBB7:
 584 018e 1F92      		push r1
 585 0190 0F92      		push r0
 586 0192 0FB6      		in r0,__SREG__
 587 0194 0F92      		push r0
 588 0196 1124      		clr __zero_reg__
 589 0198 8F93      		push r24
 590 019a 9F93      		push r25
 591               	/* prologue: Signal */
 592               	/* frame size = 0 */
 593               	/* stack size = 5 */
 594               	.L__stack_usage = 5
 130:main.c        ****   if(!(PINE & (1 << VOLROT_A))) {
 596               	.LM48:
 597 019c 0E99      		sbic 0x1,6
 598 019e 00C0      		rjmp .L45
 599               	.LBB255:
 600               	.LBB256:
 602               	.Ltext25:
 604               	.LM49:
 605 01a0 83EF      		ldi r24,lo8(499)
 606 01a2 91E0      		ldi r25,hi8(499)
 607 01a4 0197      	1:	sbiw r24,1
 608 01a6 01F4      		brne 1b
 609 01a8 00C0      		rjmp .
 610 01aa 0000      		nop
 611               	.LBE256:
 612               	.LBE255:
 614               	.Ltext26:
 131:main.c        ****     _delay_us(2000);
 132:main.c        ****     if ((PINE & (1 << VOLROT_B))) {
 616               	.LM50:
 617 01ac 0F9B      		sbis 0x1,7
 618 01ae 00C0      		rjmp .L45
 619               	.LBB257:
 620               	.LBB258:
 622               	.Ltext27:
 624               	.LM51:
 625 01b0 83EF      		ldi r24,lo8(499)
 626 01b2 91E0      		ldi r25,hi8(499)
 627 01b4 0197      	1:	sbiw r24,1
 628 01b6 01F4      		brne 1b
 629 01b8 00C0      		rjmp .
 630 01ba 0000      		nop
 631               	.LBE258:
 632               	.LBE257:
 634               	.Ltext28:
 133:main.c        ****       _delay_us(2000);
 134:main.c        ****       if (!(PINE & (1 << VOLROT_A)) && (PINE & (1 << VOLROT_B))) {
 636               	.LM52:
 637 01bc 0E99      		sbic 0x1,6
 638 01be 00C0      		rjmp .L45
 640               	.LM53:
 641 01c0 0F9B      		sbis 0x1,7
 642 01c2 00C0      		rjmp .L45
 643               	.LBB259:
 644               	.LBB260:
 646               	.Ltext29:
 648               	.LM54:
 649 01c4 91E2      		ldi r25,lo8(33)
 650 01c6 9A95      	1:	dec r25
 651 01c8 01F4      		brne 1b
 652 01ca 0000      		nop
 653               	.LBE260:
 654               	.LBE259:
 656               	.Ltext30:
 135:main.c        **** 	_delay_us(100);
 136:main.c        **** 	vol_flag = 0x02;
 658               	.LM55:
 659 01cc 82E0      		ldi r24,lo8(2)
 660 01ce 8093 0000 		sts vol_flag,r24
 661               	.L45:
 662               	/* epilogue start */
 137:main.c        ****       }
 138:main.c        ****     }
 139:main.c        ****   }
 140:main.c        **** }
 664               	.LM56:
 665 01d2 9F91      		pop r25
 666 01d4 8F91      		pop r24
 667 01d6 0F90      		pop r0
 668 01d8 0FBE      		out __SREG__,r0
 669 01da 0F90      		pop r0
 670 01dc 1F90      		pop r1
 671 01de 1895      		reti
 673               	.Lscope7:
 675               	.global	__vector_8
 677               	__vector_8:
 141:main.c        **** 
 142:main.c        **** ISR(INT7_vect) {  // falling level on INT7
 679               	.LM57:
 680               	.LFBB8:
 681 01e0 1F92      		push r1
 682 01e2 0F92      		push r0
 683 01e4 0FB6      		in r0,__SREG__
 684 01e6 0F92      		push r0
 685 01e8 1124      		clr __zero_reg__
 686 01ea 8F93      		push r24
 687 01ec 9F93      		push r25
 688               	/* prologue: Signal */
 689               	/* frame size = 0 */
 690               	/* stack size = 5 */
 691               	.L__stack_usage = 5
 143:main.c        ****   if (!(PINE & (1 << VOLROT_B))) {
 693               	.LM58:
 694 01ee 0F99      		sbic 0x1,7
 695 01f0 00C0      		rjmp .L49
 696               	.LBB261:
 697               	.LBB262:
 699               	.Ltext31:
 701               	.LM59:
 702 01f2 83EF      		ldi r24,lo8(499)
 703 01f4 91E0      		ldi r25,hi8(499)
 704 01f6 0197      	1:	sbiw r24,1
 705 01f8 01F4      		brne 1b
 706 01fa 00C0      		rjmp .
 707 01fc 0000      		nop
 708               	.LBE262:
 709               	.LBE261:
 711               	.Ltext32:
 144:main.c        ****     _delay_us(2000);
 145:main.c        ****     if ((PINE & (1 << VOLROT_A))) {
 713               	.LM60:
 714 01fe 0E9B      		sbis 0x1,6
 715 0200 00C0      		rjmp .L49
 716               	.LBB263:
 717               	.LBB264:
 719               	.Ltext33:
 721               	.LM61:
 722 0202 83EF      		ldi r24,lo8(499)
 723 0204 91E0      		ldi r25,hi8(499)
 724 0206 0197      	1:	sbiw r24,1
 725 0208 01F4      		brne 1b
 726 020a 00C0      		rjmp .
 727 020c 0000      		nop
 728               	.LBE264:
 729               	.LBE263:
 731               	.Ltext34:
 146:main.c        ****       _delay_us(2000);
 147:main.c        ****       if ((PINE & (1 << VOLROT_A)) && !(PINE & (1 << VOLROT_B))) {
 733               	.LM62:
 734 020e 0E9B      		sbis 0x1,6
 735 0210 00C0      		rjmp .L49
 737               	.LM63:
 738 0212 0F99      		sbic 0x1,7
 739 0214 00C0      		rjmp .L49
 740               	.LBB265:
 741               	.LBB266:
 743               	.Ltext35:
 745               	.LM64:
 746 0216 91E2      		ldi r25,lo8(33)
 747 0218 9A95      	1:	dec r25
 748 021a 01F4      		brne 1b
 749 021c 0000      		nop
 750               	.LBE266:
 751               	.LBE265:
 753               	.Ltext36:
 148:main.c        **** 	_delay_us(100);
 149:main.c        **** 	vol_flag = 0x01;
 755               	.LM65:
 756 021e 81E0      		ldi r24,lo8(1)
 757 0220 8093 0000 		sts vol_flag,r24
 758               	.L49:
 759               	/* epilogue start */
 150:main.c        ****       }
 151:main.c        ****     }
 152:main.c        ****   }
 153:main.c        **** }
 761               	.LM66:
 762 0224 9F91      		pop r25
 763 0226 8F91      		pop r24
 764 0228 0F90      		pop r0
 765 022a 0FBE      		out __SREG__,r0
 766 022c 0F90      		pop r0
 767 022e 1F90      		pop r1
 768 0230 1895      		reti
 770               	.Lscope8:
 772               	.global	TWIinit
 774               	TWIinit:
 154:main.c        **** 
 155:main.c        **** void TWIinit(void) {
 776               	.LM67:
 777               	.LFBB9:
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 0 */
 781               	.L__stack_usage = 0
 156:main.c        ****   TWBR = 0x45;
 783               	.LM68:
 784 0232 85E4      		ldi r24,lo8(69)
 785 0234 8093 7000 		sts 112,r24
 157:main.c        ****   TWCR = (1 << TWEN);
 787               	.LM69:
 788 0238 84E0      		ldi r24,lo8(4)
 789 023a 8093 7400 		sts 116,r24
 790 023e 0895      		ret
 792               	.Lscope9:
 794               	.global	TWIStart
 796               	TWIStart:
 158:main.c        **** }
 159:main.c        **** 
 160:main.c        **** void TWIStart(void) {
 798               	.LM70:
 799               	.LFBB10:
 800               	/* prologue: function */
 801               	/* frame size = 0 */
 802               	/* stack size = 0 */
 803               	.L__stack_usage = 0
 161:main.c        ****   TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 805               	.LM71:
 806 0240 84EA      		ldi r24,lo8(-92)
 807 0242 8093 7400 		sts 116,r24
 808               	.L61:
 162:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 810               	.LM72:
 811 0246 8091 7400 		lds r24,116
 812 024a 87FF      		sbrs r24,7
 813 024c 00C0      		rjmp .L61
 814               	/* epilogue start */
 163:main.c        **** }
 816               	.LM73:
 817 024e 0895      		ret
 819               	.Lscope10:
 821               	.global	TWIStop
 823               	TWIStop:
 164:main.c        **** 
 165:main.c        **** void TWIStop(void) {
 825               	.LM74:
 826               	.LFBB11:
 827               	/* prologue: function */
 828               	/* frame size = 0 */
 829               	/* stack size = 0 */
 830               	.L__stack_usage = 0
 166:main.c        ****   TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
 832               	.LM75:
 833 0250 84E9      		ldi r24,lo8(-108)
 834 0252 8093 7400 		sts 116,r24
 835 0256 0895      		ret
 837               	.Lscope11:
 840               	.global	TWIWrite
 842               	TWIWrite:
 167:main.c        **** }
 168:main.c        **** 
 169:main.c        **** void TWIWrite(uint8_t u8data) {
 844               	.LM76:
 845               	.LFBB12:
 846               	/* prologue: function */
 847               	/* frame size = 0 */
 848               	/* stack size = 0 */
 849               	.L__stack_usage = 0
 170:main.c        ****   TWDR = u8data;
 851               	.LM77:
 852 0258 8093 7300 		sts 115,r24
 171:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN);
 854               	.LM78:
 855 025c 84E8      		ldi r24,lo8(-124)
 856 025e 8093 7400 		sts 116,r24
 857               	.L65:
 172:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 859               	.LM79:
 860 0262 8091 7400 		lds r24,116
 861 0266 87FF      		sbrs r24,7
 862 0268 00C0      		rjmp .L65
 863               	/* epilogue start */
 173:main.c        **** }
 865               	.LM80:
 866 026a 0895      		ret
 868               	.Lscope12:
 870               	.global	TWIReadACK
 872               	TWIReadACK:
 174:main.c        **** 
 175:main.c        **** uint8_t TWIReadACK(void) {
 874               	.LM81:
 875               	.LFBB13:
 876               	/* prologue: function */
 877               	/* frame size = 0 */
 878               	/* stack size = 0 */
 879               	.L__stack_usage = 0
 176:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 881               	.LM82:
 882 026c 84EC      		ldi r24,lo8(-60)
 883 026e 8093 7400 		sts 116,r24
 884               	.L68:
 177:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 886               	.LM83:
 887 0272 8091 7400 		lds r24,116
 888 0276 87FF      		sbrs r24,7
 889 0278 00C0      		rjmp .L68
 178:main.c        ****   return TWDR;
 891               	.LM84:
 892 027a 8091 7300 		lds r24,115
 179:main.c        **** }
 894               	.LM85:
 895 027e 0895      		ret
 897               	.Lscope13:
 899               	.global	TWIReadNACK
 901               	TWIReadNACK:
 180:main.c        **** 
 181:main.c        **** //read byte with NACK
 182:main.c        **** uint8_t TWIReadNACK(void) {
 903               	.LM86:
 904               	.LFBB14:
 905               	/* prologue: function */
 906               	/* frame size = 0 */
 907               	/* stack size = 0 */
 908               	.L__stack_usage = 0
 183:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN);
 910               	.LM87:
 911 0280 84E8      		ldi r24,lo8(-124)
 912 0282 8093 7400 		sts 116,r24
 913               	.L71:
 184:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 915               	.LM88:
 916 0286 8091 7400 		lds r24,116
 917 028a 87FF      		sbrs r24,7
 918 028c 00C0      		rjmp .L71
 185:main.c        ****   return TWDR;
 920               	.LM89:
 921 028e 8091 7300 		lds r24,115
 186:main.c        **** }
 923               	.LM90:
 924 0292 0895      		ret
 926               	.Lscope14:
 928               	.global	TWIGetStatus
 930               	TWIGetStatus:
 187:main.c        **** 
 188:main.c        **** uint8_t TWIGetStatus(void) {
 932               	.LM91:
 933               	.LFBB15:
 934               	/* prologue: function */
 935               	/* frame size = 0 */
 936               	/* stack size = 0 */
 937               	.L__stack_usage = 0
 189:main.c        ****   uint8_t status;
 190:main.c        ****   //mask status
 191:main.c        ****   status = TWSR & 0xF8;
 939               	.LM92:
 940 0294 8091 7100 		lds r24,113
 192:main.c        ****   return status;
 193:main.c        **** }
 942               	.LM93:
 943 0298 887F      		andi r24,lo8(-8)
 944 029a 0895      		ret
 946               	.Lscope15:
 950               	.global	TWI_write_byte
 952               	TWI_write_byte:
 194:main.c        **** 
 195:main.c        **** uint8_t TWI_write_byte(uint8_t addr, uint8_t data) {
 954               	.LM94:
 955               	.LFBB16:
 956 029c 1F93      		push r17
 957 029e CF93      		push r28
 958 02a0 DF93      		push r29
 959 02a2 1F92      		push __zero_reg__
 960 02a4 CDB7      		in r28,__SP_L__
 961 02a6 DEB7      		in r29,__SP_H__
 962               	/* prologue: function */
 963               	/* frame size = 1 */
 964               	/* stack size = 4 */
 965               	.L__stack_usage = 4
 966 02a8 162F      		mov r17,r22
 196:main.c        **** 
 197:main.c        ****   TWIStart();
 968               	.LM95:
 969 02aa 8983      		std Y+1,r24
 970 02ac 0E94 0000 		call TWIStart
 971               	.LBB267:
 972               	.LBB268:
 191:main.c        ****   return status;
 974               	.LM96:
 975 02b0 9091 7100 		lds r25,113
 976 02b4 987F      		andi r25,lo8(-8)
 977               	.LBE268:
 978               	.LBE267:
 198:main.c        ****   if (TWIGetStatus() != 0x08) {
 980               	.LM97:
 981 02b6 8981      		ldd r24,Y+1
 982 02b8 9830      		cpi r25,lo8(8)
 983 02ba 01F0      		breq .L75
 984               	.LBB269:
 985               	.LBB270:
 166:main.c        **** }
 987               	.LM98:
 988 02bc 84E9      		ldi r24,lo8(-108)
 989 02be 8093 7400 		sts 116,r24
 990               	.LBE270:
 991               	.LBE269:
 199:main.c        ****     TWIStop();
 200:main.c        ****     return 0x01;
 993               	.LM99:
 994 02c2 81E0      		ldi r24,lo8(1)
 995 02c4 00C0      		rjmp .L76
 996               	.L75:
 201:main.c        ****   }
 202:main.c        ****   TWIWrite(addr << 1);
 998               	.LM100:
 999 02c6 880F      		lsl r24
 1000 02c8 0E94 0000 		call TWIWrite
 1001               	.LBB271:
 1002               	.LBB272:
 191:main.c        ****   return status;
 1004               	.LM101:
 1005 02cc 9091 7100 		lds r25,113
 1006 02d0 987F      		andi r25,lo8(-8)
 1007               	.LBE272:
 1008               	.LBE271:
 203:main.c        ****   if (TWIGetStatus() != 0x18) {
 1010               	.LM102:
 1011 02d2 9831      		cpi r25,lo8(24)
 1012 02d4 01F0      		breq .L77
 1013               	.LBB273:
 1014               	.LBB274:
 166:main.c        **** }
 1016               	.LM103:
 1017 02d6 84E9      		ldi r24,lo8(-108)
 1018 02d8 8093 7400 		sts 116,r24
 1019               	.LBE274:
 1020               	.LBE273:
 204:main.c        ****     TWIStop();
 205:main.c        ****     return 0x02;
 1022               	.LM104:
 1023 02dc 82E0      		ldi r24,lo8(2)
 1024 02de 00C0      		rjmp .L76
 1025               	.L77:
 206:main.c        ****   }  
 207:main.c        ****   TWIWrite(data);
 1027               	.LM105:
 1028 02e0 812F      		mov r24,r17
 1029 02e2 0E94 0000 		call TWIWrite
 1030               	.LBB275:
 1031               	.LBB276:
 191:main.c        ****   return status;
 1033               	.LM106:
 1034 02e6 8091 7100 		lds r24,113
 1035 02ea 887F      		andi r24,lo8(-8)
 1036               	.LBE276:
 1037               	.LBE275:
 208:main.c        ****   if (TWIGetStatus() != 0x28) {
 1039               	.LM107:
 1040 02ec 8832      		cpi r24,lo8(40)
 1041 02ee 01F0      		breq .L78
 1042               	.LBB277:
 1043               	.LBB278:
 166:main.c        **** }
 1045               	.LM108:
 1046 02f0 84E9      		ldi r24,lo8(-108)
 1047 02f2 8093 7400 		sts 116,r24
 1048               	.LBE278:
 1049               	.LBE277:
 209:main.c        ****     TWIStop();
 210:main.c        ****     return 0x03;
 1051               	.LM109:
 1052 02f6 83E0      		ldi r24,lo8(3)
 1053 02f8 00C0      		rjmp .L76
 1054               	.L78:
 1055               	.LBB279:
 1056               	.LBB280:
 166:main.c        **** }
 1058               	.LM110:
 1059 02fa 84E9      		ldi r24,lo8(-108)
 1060 02fc 8093 7400 		sts 116,r24
 1061               	.LBE280:
 1062               	.LBE279:
 211:main.c        ****   }
 212:main.c        ****   TWIStop();
 213:main.c        ****   return 0x00;
 1064               	.LM111:
 1065 0300 80E0      		ldi r24,0
 1066               	.L76:
 1067               	/* epilogue start */
 214:main.c        **** }
 1069               	.LM112:
 1070 0302 0F90      		pop __tmp_reg__
 1071 0304 DF91      		pop r29
 1072 0306 CF91      		pop r28
 1073 0308 1F91      		pop r17
 1074 030a 0895      		ret
 1076               	.Lscope16:
 1080               	.global	TWI_read_byte
 1082               	TWI_read_byte:
 215:main.c        **** 
 216:main.c        **** uint8_t TWI_read_byte(uint8_t addr, uint8_t* data) {
 1084               	.LM113:
 1085               	.LFBB17:
 1086 030c 0F93      		push r16
 1087 030e 1F93      		push r17
 1088 0310 CF93      		push r28
 1089 0312 DF93      		push r29
 1090 0314 1F92      		push __zero_reg__
 1091 0316 CDB7      		in r28,__SP_L__
 1092 0318 DEB7      		in r29,__SP_H__
 1093               	/* prologue: function */
 1094               	/* frame size = 1 */
 1095               	/* stack size = 5 */
 1096               	.L__stack_usage = 5
 1097 031a 8B01      		movw r16,r22
 217:main.c        **** 
 218:main.c        ****   TWIStart();
 1099               	.LM114:
 1100 031c 8983      		std Y+1,r24
 1101 031e 0E94 0000 		call TWIStart
 1102               	.LBB301:
 1103               	.LBB302:
 191:main.c        ****   return status;
 1105               	.LM115:
 1106 0322 9091 7100 		lds r25,113
 1107 0326 987F      		andi r25,lo8(-8)
 1108               	.LBE302:
 1109               	.LBE301:
 219:main.c        ****   if (TWIGetStatus() != 0x08) {
 1111               	.LM116:
 1112 0328 8981      		ldd r24,Y+1
 1113 032a 9830      		cpi r25,lo8(8)
 1114 032c 01F0      		breq .L80
 1115               	.LBB303:
 1116               	.LBB304:
 166:main.c        **** }
 1118               	.LM117:
 1119 032e 84E9      		ldi r24,lo8(-108)
 1120 0330 8093 7400 		sts 116,r24
 1121               	.LBE304:
 1122               	.LBE303:
 220:main.c        ****     TWIStop();
 221:main.c        ****     return 0x01;
 1124               	.LM118:
 1125 0334 81E0      		ldi r24,lo8(1)
 1126 0336 00C0      		rjmp .L81
 1127               	.L80:
 222:main.c        ****   }
 223:main.c        ****   TWIWrite((addr << 1) | 0x01);
 1129               	.LM119:
 1130 0338 880F      		lsl r24
 1131 033a 8160      		ori r24,lo8(1)
 1132 033c 0E94 0000 		call TWIWrite
 1133               	.LBB305:
 1134               	.LBB306:
 191:main.c        ****   return status;
 1136               	.LM120:
 1137 0340 8091 7100 		lds r24,113
 1138 0344 887F      		andi r24,lo8(-8)
 1139               	.LBE306:
 1140               	.LBE305:
 224:main.c        ****   if (TWIGetStatus() != 0x40) {
 1142               	.LM121:
 1143 0346 8034      		cpi r24,lo8(64)
 1144 0348 01F0      		breq .L82
 1145               	.LBB307:
 1146               	.LBB308:
 166:main.c        **** }
 1148               	.LM122:
 1149 034a 84E9      		ldi r24,lo8(-108)
 1150 034c 8093 7400 		sts 116,r24
 1151               	.LBE308:
 1152               	.LBE307:
 225:main.c        ****     TWIStop();
 226:main.c        ****     return 0x02;
 1154               	.LM123:
 1155 0350 82E0      		ldi r24,lo8(2)
 1156 0352 00C0      		rjmp .L81
 1157               	.L82:
 1158               	.LBB309:
 1159               	.LBB310:
 227:main.c        ****   }
 228:main.c        ****   *data = TWIReadNACK();
 1161               	.LM124:
 1162 0354 0E94 0000 		call TWIReadNACK
 1163 0358 F801      		movw r30,r16
 1164 035a 8083      		st Z,r24
 1165               	.LBB311:
 1166               	.LBB312:
 166:main.c        **** }
 1168               	.LM125:
 1169 035c 84E9      		ldi r24,lo8(-108)
 1170 035e 8093 7400 		sts 116,r24
 1171 0362 80E0      		ldi r24,0
 1172               	.L81:
 1173               	/* epilogue start */
 1174               	.LBE312:
 1175               	.LBE311:
 1176               	.LBE310:
 1177               	.LBE309:
 229:main.c        ****   TWIStop();
 230:main.c        ****   return 0x00;
 231:main.c        **** }
 1179               	.LM126:
 1180 0364 0F90      		pop __tmp_reg__
 1181 0366 DF91      		pop r29
 1182 0368 CF91      		pop r28
 1183 036a 1F91      		pop r17
 1184 036c 0F91      		pop r16
 1185 036e 0895      		ret
 1187               	.Lscope17:
 1190               	.global	TWI_write_word
 1192               	TWI_write_word:
 232:main.c        **** 
 233:main.c        **** uint8_t TWI_write_word(uint8_t addr, uint16_t data_word) {
 1194               	.LM127:
 1195               	.LFBB18:
 1196 0370 0F93      		push r16
 1197 0372 1F93      		push r17
 1198 0374 CF93      		push r28
 1199 0376 DF93      		push r29
 1200 0378 1F92      		push __zero_reg__
 1201 037a CDB7      		in r28,__SP_L__
 1202 037c DEB7      		in r29,__SP_H__
 1203               	/* prologue: function */
 1204               	/* frame size = 1 */
 1205               	/* stack size = 5 */
 1206               	.L__stack_usage = 5
 1207 037e 162F      		mov r17,r22
 1208 0380 072F      		mov r16,r23
 234:main.c        **** 
 235:main.c        ****   TWIStart();
 1210               	.LM128:
 1211 0382 8983      		std Y+1,r24
 1212 0384 0E94 0000 		call TWIStart
 1213               	.LBB345:
 1214               	.LBB346:
 191:main.c        ****   return status;
 1216               	.LM129:
 1217 0388 9091 7100 		lds r25,113
 1218 038c 987F      		andi r25,lo8(-8)
 1219               	.LBE346:
 1220               	.LBE345:
 236:main.c        ****   if (TWIGetStatus() != 0x08) {
 1222               	.LM130:
 1223 038e 8981      		ldd r24,Y+1
 1224 0390 9830      		cpi r25,lo8(8)
 1225 0392 01F0      		breq .L84
 1226               	.LBB347:
 1227               	.LBB348:
 166:main.c        **** }
 1229               	.LM131:
 1230 0394 84E9      		ldi r24,lo8(-108)
 1231 0396 8093 7400 		sts 116,r24
 1232               	.LBE348:
 1233               	.LBE347:
 237:main.c        ****     TWIStop();
 238:main.c        ****     return 0x01;
 1235               	.LM132:
 1236 039a 81E0      		ldi r24,lo8(1)
 1237 039c 00C0      		rjmp .L85
 1238               	.L84:
 239:main.c        ****   }
 240:main.c        ****   TWIWrite(addr << 1);
 1240               	.LM133:
 1241 039e 880F      		lsl r24
 1242 03a0 0E94 0000 		call TWIWrite
 1243               	.LBB349:
 1244               	.LBB350:
 191:main.c        ****   return status;
 1246               	.LM134:
 1247 03a4 9091 7100 		lds r25,113
 1248 03a8 987F      		andi r25,lo8(-8)
 1249               	.LBE350:
 1250               	.LBE349:
 241:main.c        ****   if (TWIGetStatus() != 0x18) {
 1252               	.LM135:
 1253 03aa 9831      		cpi r25,lo8(24)
 1254 03ac 01F0      		breq .L86
 1255               	.LBB351:
 1256               	.LBB352:
 166:main.c        **** }
 1258               	.LM136:
 1259 03ae 84E9      		ldi r24,lo8(-108)
 1260 03b0 8093 7400 		sts 116,r24
 1261               	.LBE352:
 1262               	.LBE351:
 242:main.c        ****     TWIStop();
 243:main.c        ****     return 0x02;  
 1264               	.LM137:
 1265 03b4 82E0      		ldi r24,lo8(2)
 1266 03b6 00C0      		rjmp .L85
 1267               	.L86:
 244:main.c        ****   }
 245:main.c        ****   TWIWrite((uint8_t)((data_word & 0xFF00) >> 8));
 1269               	.LM138:
 1270 03b8 802F      		mov r24,r16
 1271 03ba 0E94 0000 		call TWIWrite
 1272               	.LBB353:
 1273               	.LBB354:
 191:main.c        ****   return status;
 1275               	.LM139:
 1276 03be 9091 7100 		lds r25,113
 1277 03c2 987F      		andi r25,lo8(-8)
 1278               	.LBE354:
 1279               	.LBE353:
 246:main.c        ****   if (TWIGetStatus() != 0x28) {
 1281               	.LM140:
 1282 03c4 9832      		cpi r25,lo8(40)
 1283 03c6 01F0      		breq .L87
 1284               	.LBB355:
 1285               	.LBB356:
 166:main.c        **** }
 1287               	.LM141:
 1288 03c8 84E9      		ldi r24,lo8(-108)
 1289 03ca 8093 7400 		sts 116,r24
 1290               	.LBE356:
 1291               	.LBE355:
 247:main.c        ****     TWIStop();
 248:main.c        ****     return 0x03;
 1293               	.LM142:
 1294 03ce 83E0      		ldi r24,lo8(3)
 1295 03d0 00C0      		rjmp .L85
 1296               	.L87:
 1297               	.LBB357:
 1298               	.LBB358:
 249:main.c        ****   }
 250:main.c        ****   TWIWrite((uint8_t)(data_word & 0x00FF));
 1300               	.LM143:
 1301 03d2 812F      		mov r24,r17
 1302 03d4 0E94 0000 		call TWIWrite
 1303               	.LBB359:
 1304               	.LBB360:
 191:main.c        ****   return status;
 1306               	.LM144:
 1307 03d8 8091 7100 		lds r24,113
 1308 03dc 887F      		andi r24,lo8(-8)
 1309               	.LBE360:
 1310               	.LBE359:
 251:main.c        ****   if (TWIGetStatus() != 0x28) {
 1312               	.LM145:
 1313 03de 8832      		cpi r24,lo8(40)
 1314 03e0 01F0      		breq .L88
 1315               	.LBB361:
 1316               	.LBB362:
 166:main.c        **** }
 1318               	.LM146:
 1319 03e2 84E9      		ldi r24,lo8(-108)
 1320 03e4 8093 7400 		sts 116,r24
 1321               	.LBE362:
 1322               	.LBE361:
 252:main.c        ****     TWIStop();
 253:main.c        ****     return 0x04;
 1324               	.LM147:
 1325 03e8 84E0      		ldi r24,lo8(4)
 1326 03ea 00C0      		rjmp .L85
 1327               	.L88:
 1328               	.LBB363:
 1329               	.LBB364:
 166:main.c        **** }
 1331               	.LM148:
 1332 03ec 84E9      		ldi r24,lo8(-108)
 1333 03ee 8093 7400 		sts 116,r24
 1334               	.LBE364:
 1335               	.LBE363:
 254:main.c        ****   }
 255:main.c        ****   TWIStop();
 256:main.c        ****   return 0x00;
 1337               	.LM149:
 1338 03f2 80E0      		ldi r24,0
 1339               	.L85:
 1340               	/* epilogue start */
 1341               	.LBE358:
 1342               	.LBE357:
 257:main.c        **** }
 1344               	.LM150:
 1345 03f4 0F90      		pop __tmp_reg__
 1346 03f6 DF91      		pop r29
 1347 03f8 CF91      		pop r28
 1348 03fa 1F91      		pop r17
 1349 03fc 0F91      		pop r16
 1350 03fe 0895      		ret
 1352               	.Lscope18:
 1358               	.global	TWI_write_3bytes
 1360               	TWI_write_3bytes:
 258:main.c        **** 
 259:main.c        **** uint8_t TWI_write_3bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3) {
 1362               	.LM151:
 1363               	.LFBB19:
 1364 0400 FF92      		push r15
 1365 0402 0F93      		push r16
 1366 0404 1F93      		push r17
 1367 0406 CF93      		push r28
 1368 0408 DF93      		push r29
 1369 040a 1F92      		push __zero_reg__
 1370 040c CDB7      		in r28,__SP_L__
 1371 040e DEB7      		in r29,__SP_H__
 1372               	/* prologue: function */
 1373               	/* frame size = 1 */
 1374               	/* stack size = 6 */
 1375               	.L__stack_usage = 6
 1376 0410 162F      		mov r17,r22
 1377 0412 042F      		mov r16,r20
 1378 0414 F22E      		mov r15,r18
 260:main.c        **** 
 261:main.c        ****   TWIStart();
 1380               	.LM152:
 1381 0416 8983      		std Y+1,r24
 1382 0418 0E94 0000 		call TWIStart
 1383               	.LBB365:
 1384               	.LBB366:
 191:main.c        ****   return status;
 1386               	.LM153:
 1387 041c 9091 7100 		lds r25,113
 1388 0420 987F      		andi r25,lo8(-8)
 1389               	.LBE366:
 1390               	.LBE365:
 262:main.c        ****   if (TWIGetStatus() != 0x08) {
 1392               	.LM154:
 1393 0422 8981      		ldd r24,Y+1
 1394 0424 9830      		cpi r25,lo8(8)
 1395 0426 01F0      		breq .L90
 1396               	.LBB367:
 1397               	.LBB368:
 166:main.c        **** }
 1399               	.LM155:
 1400 0428 84E9      		ldi r24,lo8(-108)
 1401 042a 8093 7400 		sts 116,r24
 1402               	.LBE368:
 1403               	.LBE367:
 263:main.c        ****     TWIStop();
 264:main.c        ****     return 0x01;
 1405               	.LM156:
 1406 042e 81E0      		ldi r24,lo8(1)
 1407 0430 00C0      		rjmp .L91
 1408               	.L90:
 265:main.c        ****   }
 266:main.c        ****   TWIWrite(addr << 1);
 1410               	.LM157:
 1411 0432 880F      		lsl r24
 1412 0434 0E94 0000 		call TWIWrite
 1413               	.LBB369:
 1414               	.LBB370:
 191:main.c        ****   return status;
 1416               	.LM158:
 1417 0438 9091 7100 		lds r25,113
 1418 043c 987F      		andi r25,lo8(-8)
 1419               	.LBE370:
 1420               	.LBE369:
 267:main.c        ****   if (TWIGetStatus() != 0x18) {
 1422               	.LM159:
 1423 043e 9831      		cpi r25,lo8(24)
 1424 0440 01F0      		breq .L92
 1425               	.LBB371:
 1426               	.LBB372:
 166:main.c        **** }
 1428               	.LM160:
 1429 0442 84E9      		ldi r24,lo8(-108)
 1430 0444 8093 7400 		sts 116,r24
 1431               	.LBE372:
 1432               	.LBE371:
 268:main.c        ****     TWIStop();
 269:main.c        ****     return 0x02;  
 1434               	.LM161:
 1435 0448 82E0      		ldi r24,lo8(2)
 1436 044a 00C0      		rjmp .L91
 1437               	.L92:
 270:main.c        ****   }
 271:main.c        ****   TWIWrite(byte1);
 1439               	.LM162:
 1440 044c 812F      		mov r24,r17
 1441 044e 0E94 0000 		call TWIWrite
 1442               	.LBB373:
 1443               	.LBB374:
 191:main.c        ****   return status;
 1445               	.LM163:
 1446 0452 9091 7100 		lds r25,113
 1447 0456 987F      		andi r25,lo8(-8)
 1448               	.LBE374:
 1449               	.LBE373:
 272:main.c        ****   if (TWIGetStatus() != 0x28) {
 1451               	.LM164:
 1452 0458 9832      		cpi r25,lo8(40)
 1453 045a 01F0      		breq .L93
 1454               	.LBB375:
 1455               	.LBB376:
 166:main.c        **** }
 1457               	.LM165:
 1458 045c 84E9      		ldi r24,lo8(-108)
 1459 045e 8093 7400 		sts 116,r24
 1460               	.LBE376:
 1461               	.LBE375:
 273:main.c        ****     TWIStop();
 274:main.c        ****     return 0x03;
 1463               	.LM166:
 1464 0462 83E0      		ldi r24,lo8(3)
 1465 0464 00C0      		rjmp .L91
 1466               	.L93:
 275:main.c        ****   }
 276:main.c        ****   TWIWrite(byte2);
 1468               	.LM167:
 1469 0466 802F      		mov r24,r16
 1470 0468 0E94 0000 		call TWIWrite
 1471               	.LBB377:
 1472               	.LBB378:
 191:main.c        ****   return status;
 1474               	.LM168:
 1475 046c 9091 7100 		lds r25,113
 1476 0470 987F      		andi r25,lo8(-8)
 1477               	.LBE378:
 1478               	.LBE377:
 277:main.c        ****   if (TWIGetStatus() != 0x28) {
 1480               	.LM169:
 1481 0472 9832      		cpi r25,lo8(40)
 1482 0474 01F4      		brne .L96
 278:main.c        ****     TWIStop();
 279:main.c        ****     return 0x04;
 280:main.c        ****   }
 281:main.c        ****   TWIWrite(byte3);
 1484               	.LM170:
 1485 0476 8F2D      		mov r24,r15
 1486 0478 0E94 0000 		call TWIWrite
 1487               	.LBB379:
 1488               	.LBB380:
 191:main.c        ****   return status;
 1490               	.LM171:
 1491 047c 8091 7100 		lds r24,113
 1492 0480 887F      		andi r24,lo8(-8)
 1493               	.LBE380:
 1494               	.LBE379:
 282:main.c        ****   if (TWIGetStatus() != 0x28) {
 1496               	.LM172:
 1497 0482 8832      		cpi r24,lo8(40)
 1498 0484 01F0      		breq .L95
 1499               	.L96:
 1500               	.LBB381:
 1501               	.LBB382:
 166:main.c        **** }
 1503               	.LM173:
 1504 0486 84E9      		ldi r24,lo8(-108)
 1505 0488 8093 7400 		sts 116,r24
 1506               	.LBE382:
 1507               	.LBE381:
 283:main.c        ****     TWIStop();
 284:main.c        ****     return 0x04;
 1509               	.LM174:
 1510 048c 84E0      		ldi r24,lo8(4)
 1511 048e 00C0      		rjmp .L91
 1512               	.L95:
 1513               	.LBB383:
 1514               	.LBB384:
 166:main.c        **** }
 1516               	.LM175:
 1517 0490 84E9      		ldi r24,lo8(-108)
 1518 0492 8093 7400 		sts 116,r24
 1519               	.LBE384:
 1520               	.LBE383:
 285:main.c        ****   }
 286:main.c        ****   TWIStop();
 287:main.c        ****   return 0x00;
 1522               	.LM176:
 1523 0496 80E0      		ldi r24,0
 1524               	.L91:
 1525               	/* epilogue start */
 288:main.c        **** }
 1527               	.LM177:
 1528 0498 0F90      		pop __tmp_reg__
 1529 049a DF91      		pop r29
 1530 049c CF91      		pop r28
 1531 049e 1F91      		pop r17
 1532 04a0 0F91      		pop r16
 1533 04a2 FF90      		pop r15
 1534 04a4 0895      		ret
 1536               	.Lscope19:
 1543               	.global	TWI_write_4bytes
 1545               	TWI_write_4bytes:
 289:main.c        **** 
 290:main.c        **** uint8_t TWI_write_4bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3, uint8_t byte4) 
 1547               	.LM178:
 1548               	.LFBB20:
 1549 04a6 EF92      		push r14
 1550 04a8 FF92      		push r15
 1551 04aa 0F93      		push r16
 1552 04ac 1F93      		push r17
 1553 04ae CF93      		push r28
 1554 04b0 DF93      		push r29
 1555 04b2 1F92      		push __zero_reg__
 1556 04b4 CDB7      		in r28,__SP_L__
 1557 04b6 DEB7      		in r29,__SP_H__
 1558               	/* prologue: function */
 1559               	/* frame size = 1 */
 1560               	/* stack size = 7 */
 1561               	.L__stack_usage = 7
 1562 04b8 162F      		mov r17,r22
 1563 04ba F42E      		mov r15,r20
 1564 04bc E22E      		mov r14,r18
 291:main.c        **** 
 292:main.c        ****   TWIStart();
 1566               	.LM179:
 1567 04be 8983      		std Y+1,r24
 1568 04c0 0E94 0000 		call TWIStart
 1569               	.LBB385:
 1570               	.LBB386:
 191:main.c        ****   return status;
 1572               	.LM180:
 1573 04c4 9091 7100 		lds r25,113
 1574 04c8 987F      		andi r25,lo8(-8)
 1575               	.LBE386:
 1576               	.LBE385:
 293:main.c        ****   if (TWIGetStatus() != 0x08) {
 1578               	.LM181:
 1579 04ca 8981      		ldd r24,Y+1
 1580 04cc 9830      		cpi r25,lo8(8)
 1581 04ce 01F0      		breq .L98
 1582               	.LBB387:
 1583               	.LBB388:
 166:main.c        **** }
 1585               	.LM182:
 1586 04d0 84E9      		ldi r24,lo8(-108)
 1587 04d2 8093 7400 		sts 116,r24
 1588               	.LBE388:
 1589               	.LBE387:
 294:main.c        ****     TWIStop();
 295:main.c        ****     return 0x01;
 1591               	.LM183:
 1592 04d6 81E0      		ldi r24,lo8(1)
 1593 04d8 00C0      		rjmp .L99
 1594               	.L98:
 296:main.c        ****   }
 297:main.c        ****   TWIWrite(addr << 1);
 1596               	.LM184:
 1597 04da 880F      		lsl r24
 1598 04dc 0E94 0000 		call TWIWrite
 1599               	.LBB389:
 1600               	.LBB390:
 191:main.c        ****   return status;
 1602               	.LM185:
 1603 04e0 9091 7100 		lds r25,113
 1604 04e4 987F      		andi r25,lo8(-8)
 1605               	.LBE390:
 1606               	.LBE389:
 298:main.c        ****   if (TWIGetStatus() != 0x18) {
 1608               	.LM186:
 1609 04e6 9831      		cpi r25,lo8(24)
 1610 04e8 01F0      		breq .L100
 1611               	.LBB391:
 1612               	.LBB392:
 166:main.c        **** }
 1614               	.LM187:
 1615 04ea 84E9      		ldi r24,lo8(-108)
 1616 04ec 8093 7400 		sts 116,r24
 1617               	.LBE392:
 1618               	.LBE391:
 299:main.c        ****     TWIStop();
 300:main.c        ****     return 0x02;  
 1620               	.LM188:
 1621 04f0 82E0      		ldi r24,lo8(2)
 1622 04f2 00C0      		rjmp .L99
 1623               	.L100:
 301:main.c        ****   }
 302:main.c        ****   TWIWrite(byte1);
 1625               	.LM189:
 1626 04f4 812F      		mov r24,r17
 1627 04f6 0E94 0000 		call TWIWrite
 1628               	.LBB393:
 1629               	.LBB394:
 191:main.c        ****   return status;
 1631               	.LM190:
 1632 04fa 9091 7100 		lds r25,113
 1633 04fe 987F      		andi r25,lo8(-8)
 1634               	.LBE394:
 1635               	.LBE393:
 303:main.c        ****   if (TWIGetStatus() != 0x28) {
 1637               	.LM191:
 1638 0500 9832      		cpi r25,lo8(40)
 1639 0502 01F0      		breq .L101
 1640               	.LBB395:
 1641               	.LBB396:
 166:main.c        **** }
 1643               	.LM192:
 1644 0504 84E9      		ldi r24,lo8(-108)
 1645 0506 8093 7400 		sts 116,r24
 1646               	.LBE396:
 1647               	.LBE395:
 304:main.c        ****     TWIStop();
 305:main.c        ****     return 0x03;
 1649               	.LM193:
 1650 050a 83E0      		ldi r24,lo8(3)
 1651 050c 00C0      		rjmp .L99
 1652               	.L101:
 306:main.c        ****   }
 307:main.c        ****   TWIWrite(byte2);
 1654               	.LM194:
 1655 050e 8F2D      		mov r24,r15
 1656 0510 0E94 0000 		call TWIWrite
 1657               	.LBB397:
 1658               	.LBB398:
 191:main.c        ****   return status;
 1660               	.LM195:
 1661 0514 9091 7100 		lds r25,113
 1662 0518 987F      		andi r25,lo8(-8)
 1663               	.LBE398:
 1664               	.LBE397:
 308:main.c        ****   if (TWIGetStatus() != 0x28) {
 1666               	.LM196:
 1667 051a 9832      		cpi r25,lo8(40)
 1668 051c 01F4      		brne .L106
 309:main.c        ****     TWIStop();
 310:main.c        ****     return 0x04;
 311:main.c        ****   }
 312:main.c        ****   TWIWrite(byte3);
 1670               	.LM197:
 1671 051e 8E2D      		mov r24,r14
 1672 0520 0E94 0000 		call TWIWrite
 1673               	.LBB399:
 1674               	.LBB400:
 191:main.c        ****   return status;
 1676               	.LM198:
 1677 0524 9091 7100 		lds r25,113
 1678 0528 987F      		andi r25,lo8(-8)
 1679               	.LBE400:
 1680               	.LBE399:
 313:main.c        ****   if (TWIGetStatus() != 0x28) {
 1682               	.LM199:
 1683 052a 9832      		cpi r25,lo8(40)
 1684 052c 01F4      		brne .L106
 314:main.c        ****     TWIStop();
 315:main.c        ****     return 0x04;
 316:main.c        ****   }
 317:main.c        ****   TWIWrite(byte4);
 1686               	.LM200:
 1687 052e 802F      		mov r24,r16
 1688 0530 0E94 0000 		call TWIWrite
 1689               	.LBB401:
 1690               	.LBB402:
 191:main.c        ****   return status;
 1692               	.LM201:
 1693 0534 8091 7100 		lds r24,113
 1694 0538 887F      		andi r24,lo8(-8)
 1695               	.LBE402:
 1696               	.LBE401:
 318:main.c        ****   if (TWIGetStatus() != 0x28) {
 1698               	.LM202:
 1699 053a 8832      		cpi r24,lo8(40)
 1700 053c 01F0      		breq .L104
 1701               	.L106:
 1702               	.LBB403:
 1703               	.LBB404:
 166:main.c        **** }
 1705               	.LM203:
 1706 053e 84E9      		ldi r24,lo8(-108)
 1707 0540 8093 7400 		sts 116,r24
 1708               	.LBE404:
 1709               	.LBE403:
 319:main.c        ****     TWIStop();
 320:main.c        ****     return 0x04;
 1711               	.LM204:
 1712 0544 84E0      		ldi r24,lo8(4)
 1713 0546 00C0      		rjmp .L99
 1714               	.L104:
 1715               	.LBB405:
 1716               	.LBB406:
 166:main.c        **** }
 1718               	.LM205:
 1719 0548 84E9      		ldi r24,lo8(-108)
 1720 054a 8093 7400 		sts 116,r24
 1721               	.LBE406:
 1722               	.LBE405:
 321:main.c        ****   }
 322:main.c        ****   TWIStop();
 323:main.c        ****   return 0x00;
 1724               	.LM206:
 1725 054e 80E0      		ldi r24,0
 1726               	.L99:
 1727               	/* epilogue start */
 324:main.c        **** }
 1729               	.LM207:
 1730 0550 0F90      		pop __tmp_reg__
 1731 0552 DF91      		pop r29
 1732 0554 CF91      		pop r28
 1733 0556 1F91      		pop r17
 1734 0558 0F91      		pop r16
 1735 055a FF90      		pop r15
 1736 055c EF90      		pop r14
 1737 055e 0895      		ret
 1739               	.Lscope20:
 1747               	.global	TWI_write_5bytes
 1749               	TWI_write_5bytes:
 325:main.c        **** 
 326:main.c        **** uint8_t TWI_write_5bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3, uint8_t byte4, 
 1751               	.LM208:
 1752               	.LFBB21:
 1753 0560 DF92      		push r13
 1754 0562 EF92      		push r14
 1755 0564 FF92      		push r15
 1756 0566 0F93      		push r16
 1757 0568 1F93      		push r17
 1758 056a CF93      		push r28
 1759 056c DF93      		push r29
 1760 056e 1F92      		push __zero_reg__
 1761 0570 CDB7      		in r28,__SP_L__
 1762 0572 DEB7      		in r29,__SP_H__
 1763               	/* prologue: function */
 1764               	/* frame size = 1 */
 1765               	/* stack size = 8 */
 1766               	.L__stack_usage = 8
 1767 0574 162F      		mov r17,r22
 1768 0576 F42E      		mov r15,r20
 1769 0578 D22E      		mov r13,r18
 327:main.c        **** 
 328:main.c        ****   TWIStart();
 1771               	.LM209:
 1772 057a 8983      		std Y+1,r24
 1773 057c 0E94 0000 		call TWIStart
 1774               	.LBB455:
 1775               	.LBB456:
 191:main.c        ****   return status;
 1777               	.LM210:
 1778 0580 9091 7100 		lds r25,113
 1779 0584 987F      		andi r25,lo8(-8)
 1780               	.LBE456:
 1781               	.LBE455:
 329:main.c        ****   if (TWIGetStatus() != 0x08) {
 1783               	.LM211:
 1784 0586 8981      		ldd r24,Y+1
 1785 0588 9830      		cpi r25,lo8(8)
 1786 058a 01F0      		breq .L108
 1787               	.LBB457:
 1788               	.LBB458:
 166:main.c        **** }
 1790               	.LM212:
 1791 058c 84E9      		ldi r24,lo8(-108)
 1792 058e 8093 7400 		sts 116,r24
 1793               	.LBE458:
 1794               	.LBE457:
 330:main.c        ****     TWIStop();
 331:main.c        ****     return 0x01;
 1796               	.LM213:
 1797 0592 81E0      		ldi r24,lo8(1)
 1798 0594 00C0      		rjmp .L109
 1799               	.L108:
 332:main.c        ****   }
 333:main.c        ****   TWIWrite(addr << 1);
 1801               	.LM214:
 1802 0596 880F      		lsl r24
 1803 0598 0E94 0000 		call TWIWrite
 1804               	.LBB459:
 1805               	.LBB460:
 191:main.c        ****   return status;
 1807               	.LM215:
 1808 059c 9091 7100 		lds r25,113
 1809 05a0 987F      		andi r25,lo8(-8)
 1810               	.LBE460:
 1811               	.LBE459:
 334:main.c        ****   if (TWIGetStatus() != 0x18) {
 1813               	.LM216:
 1814 05a2 9831      		cpi r25,lo8(24)
 1815 05a4 01F0      		breq .L110
 1816               	.LBB461:
 1817               	.LBB462:
 166:main.c        **** }
 1819               	.LM217:
 1820 05a6 84E9      		ldi r24,lo8(-108)
 1821 05a8 8093 7400 		sts 116,r24
 1822               	.LBE462:
 1823               	.LBE461:
 335:main.c        ****     TWIStop();
 336:main.c        ****     return 0x02;  
 1825               	.LM218:
 1826 05ac 82E0      		ldi r24,lo8(2)
 1827 05ae 00C0      		rjmp .L109
 1828               	.L110:
 337:main.c        ****   }
 338:main.c        ****   TWIWrite(byte1);
 1830               	.LM219:
 1831 05b0 812F      		mov r24,r17
 1832 05b2 0E94 0000 		call TWIWrite
 1833               	.LBB463:
 1834               	.LBB464:
 191:main.c        ****   return status;
 1836               	.LM220:
 1837 05b6 9091 7100 		lds r25,113
 1838 05ba 987F      		andi r25,lo8(-8)
 1839               	.LBE464:
 1840               	.LBE463:
 339:main.c        ****   if (TWIGetStatus() != 0x28) {
 1842               	.LM221:
 1843 05bc 9832      		cpi r25,lo8(40)
 1844 05be 01F0      		breq .L111
 1845               	.LBB465:
 1846               	.LBB466:
 166:main.c        **** }
 1848               	.LM222:
 1849 05c0 84E9      		ldi r24,lo8(-108)
 1850 05c2 8093 7400 		sts 116,r24
 1851               	.LBE466:
 1852               	.LBE465:
 340:main.c        ****     TWIStop();
 341:main.c        ****     return 0x03;
 1854               	.LM223:
 1855 05c6 83E0      		ldi r24,lo8(3)
 1856 05c8 00C0      		rjmp .L109
 1857               	.L111:
 342:main.c        ****   }
 343:main.c        ****   TWIWrite(byte2);
 1859               	.LM224:
 1860 05ca 8F2D      		mov r24,r15
 1861 05cc 0E94 0000 		call TWIWrite
 1862               	.LBB467:
 1863               	.LBB468:
 191:main.c        ****   return status;
 1865               	.LM225:
 1866 05d0 9091 7100 		lds r25,113
 1867 05d4 987F      		andi r25,lo8(-8)
 1868               	.LBE468:
 1869               	.LBE467:
 344:main.c        ****   if (TWIGetStatus() != 0x28) {
 1871               	.LM226:
 1872 05d6 9832      		cpi r25,lo8(40)
 1873 05d8 01F4      		brne .L116
 1874               	.LBB469:
 1875               	.LBB470:
 345:main.c        ****     TWIStop();
 346:main.c        ****     return 0x04;
 347:main.c        ****   }
 348:main.c        ****   TWIWrite(byte3);
 1877               	.LM227:
 1878 05da 8D2D      		mov r24,r13
 1879 05dc 0E94 0000 		call TWIWrite
 1880               	.LBB471:
 1881               	.LBB472:
 191:main.c        ****   return status;
 1883               	.LM228:
 1884 05e0 9091 7100 		lds r25,113
 1885 05e4 987F      		andi r25,lo8(-8)
 1886               	.LBE472:
 1887               	.LBE471:
 349:main.c        ****   if (TWIGetStatus() != 0x28) {
 1889               	.LM229:
 1890 05e6 9832      		cpi r25,lo8(40)
 1891 05e8 01F4      		brne .L116
 350:main.c        ****     TWIStop();
 351:main.c        ****     return 0x04;
 352:main.c        ****   }
 353:main.c        ****   TWIWrite(byte4);
 1893               	.LM230:
 1894 05ea 802F      		mov r24,r16
 1895 05ec 0E94 0000 		call TWIWrite
 1896               	.LBB473:
 1897               	.LBB474:
 191:main.c        ****   return status;
 1899               	.LM231:
 1900 05f0 9091 7100 		lds r25,113
 1901 05f4 987F      		andi r25,lo8(-8)
 1902               	.LBE474:
 1903               	.LBE473:
 354:main.c        ****   if (TWIGetStatus() != 0x28) {
 1905               	.LM232:
 1906 05f6 9832      		cpi r25,lo8(40)
 1907 05f8 01F4      		brne .L116
 355:main.c        ****     TWIStop();
 356:main.c        ****     return 0x04;
 357:main.c        ****   }
 358:main.c        ****   TWIWrite(byte5);
 1909               	.LM233:
 1910 05fa 8E2D      		mov r24,r14
 1911 05fc 0E94 0000 		call TWIWrite
 1912               	.LBB475:
 1913               	.LBB476:
 191:main.c        ****   return status;
 1915               	.LM234:
 1916 0600 8091 7100 		lds r24,113
 1917 0604 887F      		andi r24,lo8(-8)
 1918               	.LBE476:
 1919               	.LBE475:
 359:main.c        ****   if (TWIGetStatus() != 0x28) {
 1921               	.LM235:
 1922 0606 8832      		cpi r24,lo8(40)
 1923 0608 01F0      		breq .L115
 1924               	.L116:
 1925               	.LBB477:
 1926               	.LBB478:
 166:main.c        **** }
 1928               	.LM236:
 1929 060a 84E9      		ldi r24,lo8(-108)
 1930 060c 8093 7400 		sts 116,r24
 1931               	.LBE478:
 1932               	.LBE477:
 360:main.c        ****     TWIStop();
 361:main.c        ****     return 0x04;
 1934               	.LM237:
 1935 0610 84E0      		ldi r24,lo8(4)
 1936 0612 00C0      		rjmp .L109
 1937               	.L115:
 1938               	.LBB479:
 1939               	.LBB480:
 166:main.c        **** }
 1941               	.LM238:
 1942 0614 84E9      		ldi r24,lo8(-108)
 1943 0616 8093 7400 		sts 116,r24
 1944               	.LBE480:
 1945               	.LBE479:
 362:main.c        ****   }
 363:main.c        ****   TWIStop();
 364:main.c        ****   return 0x00;
 1947               	.LM239:
 1948 061a 80E0      		ldi r24,0
 1949               	.L109:
 1950               	/* epilogue start */
 1951               	.LBE470:
 1952               	.LBE469:
 365:main.c        **** }
 1954               	.LM240:
 1955 061c 0F90      		pop __tmp_reg__
 1956 061e DF91      		pop r29
 1957 0620 CF91      		pop r28
 1958 0622 1F91      		pop r17
 1959 0624 0F91      		pop r16
 1960 0626 FF90      		pop r15
 1961 0628 EF90      		pop r14
 1962 062a DF90      		pop r13
 1963 062c 0895      		ret
 1965               	.Lscope21:
 1966               	.global	__divsf3
 1967               	.global	__floatsisf
 1968               	.global	__addsf3
 1969               	.global	__fixsfsi
 1970               		.section	.rodata.str1.1,"aMS",@progbits,1
 1971               	.LC0:
 1972 0000 2564 2C25 		.string	"%d,%06.2f     "
 1972      3036 2E32 
 1972      6620 2020 
 1972      2020 00
 1973               	.LC1:
 1974 000f 2B00      		.string	"+"
 1975               	.LC2:
 1976 0011 2000      		.string	" "
 1977               		.text
 1979               	.global	lcd_freq
 1981               	lcd_freq:
 366:main.c        **** 
 367:main.c        **** void lcd_freq() {
 1983               	.LM241:
 1984               	.LFBB22:
 1985 062e 8F92      		push r8
 1986 0630 9F92      		push r9
 1987 0632 AF92      		push r10
 1988 0634 BF92      		push r11
 1989 0636 CF92      		push r12
 1990 0638 DF92      		push r13
 1991 063a EF92      		push r14
 1992 063c FF92      		push r15
 1993 063e 0F93      		push r16
 1994 0640 1F93      		push r17
 1995 0642 CF93      		push r28
 1996 0644 DF93      		push r29
 1997 0646 CDB7      		in r28,__SP_L__
 1998 0648 DEB7      		in r29,__SP_H__
 1999 064a EC97      		sbiw r28,60
 2000 064c 0FB6      		in __tmp_reg__,__SREG__
 2001 064e F894      		cli
 2002 0650 DEBF      		out __SP_H__,r29
 2003 0652 0FBE      		out __SREG__,__tmp_reg__
 2004 0654 CDBF      		out __SP_L__,r28
 2005               	/* prologue: function */
 2006               	/* frame size = 60 */
 2007               	/* stack size = 72 */
 2008               	.L__stack_usage = 72
 368:main.c        ****   char buffer[60];
 369:main.c        **** 
 370:main.c        ****   if (mode == AM || mode == AMN || mode == FM) {
 2010               	.LM242:
 2011 0656 8091 0000 		lds r24,mode
 2012 065a 8830      		cpi r24,lo8(8)
 2013 065c 01F0      		breq .L118
 2015               	.LM243:
 2016 065e 8091 0000 		lds r24,mode
 2017 0662 8930      		cpi r24,lo8(9)
 2018 0664 01F0      		breq .L118
 2020               	.LM244:
 2021 0666 8091 0000 		lds r24,mode
 2022 066a 8A30      		cpi r24,lo8(10)
 2023 066c 01F4      		brne .L119
 2024               	.L118:
 371:main.c        ****     freq = round(freq);
 2026               	.LM245:
 2027 066e 6091 0000 		lds r22,freq
 2028 0672 7091 0000 		lds r23,freq+1
 2029 0676 8091 0000 		lds r24,freq+2
 2030 067a 9091 0000 		lds r25,freq+3
 2031 067e 0E94 0000 		call round
 2032 0682 6093 0000 		sts freq,r22
 2033 0686 7093 0000 		sts freq+1,r23
 2034 068a 8093 0000 		sts freq+2,r24
 2035 068e 9093 0000 		sts freq+3,r25
 2036               	.L119:
 372:main.c        ****   }
 373:main.c        ****   lcd_goto(0x04);
 2038               	.LM246:
 2039 0692 84E0      		ldi r24,lo8(4)
 2040 0694 0E94 0000 		call lcd_goto
 374:main.c        ****   sprintf(buffer,"%d,%06.2f     ",(int)floor(freq/1000+freq_offset),fmod(freq,1000));
 2042               	.LM247:
 2043 0698 6091 0000 		lds r22,freq
 2044 069c 7091 0000 		lds r23,freq+1
 2045 06a0 8091 0000 		lds r24,freq+2
 2046 06a4 9091 0000 		lds r25,freq+3
 2047 06a8 20E0      		ldi r18,0
 2048 06aa 30E0      		ldi r19,0
 2049 06ac 4AE7      		ldi r20,lo8(122)
 2050 06ae 54E4      		ldi r21,lo8(68)
 2051 06b0 0E94 0000 		call fmod
 2052 06b4 F62E      		mov r15,r22
 2053 06b6 E72E      		mov r14,r23
 2054 06b8 D82E      		mov r13,r24
 2055 06ba C92E      		mov r12,r25
 2056 06bc 6091 0000 		lds r22,freq
 2057 06c0 7091 0000 		lds r23,freq+1
 2058 06c4 8091 0000 		lds r24,freq+2
 2059 06c8 9091 0000 		lds r25,freq+3
 2060 06cc 0091 0000 		lds r16,freq_offset
 2061 06d0 1091 0000 		lds r17,freq_offset+1
 2062 06d4 20E0      		ldi r18,0
 2063 06d6 30E0      		ldi r19,0
 2064 06d8 4AE7      		ldi r20,lo8(122)
 2065 06da 54E4      		ldi r21,lo8(68)
 2066 06dc 0E94 0000 		call __divsf3
 2067 06e0 4B01      		movw r8,r22
 2068 06e2 5C01      		movw r10,r24
 2069 06e4 B801      		movw r22,r16
 2070 06e6 110F      		lsl r17
 2071 06e8 880B      		sbc r24,r24
 2072 06ea 990B      		sbc r25,r25
 2073 06ec 0E94 0000 		call __floatsisf
 2074 06f0 9B01      		movw r18,r22
 2075 06f2 AC01      		movw r20,r24
 2076 06f4 C501      		movw r24,r10
 2077 06f6 B401      		movw r22,r8
 2078 06f8 0E94 0000 		call __addsf3
 2079 06fc 0E94 0000 		call floor
 2080 0700 CF92      		push r12
 2081 0702 DF92      		push r13
 2082 0704 EF92      		push r14
 2083 0706 FF92      		push r15
 2084 0708 0E94 0000 		call __fixsfsi
 2085 070c 7F93      		push r23
 2086 070e 6F93      		push r22
 2087 0710 80E0      		ldi r24,lo8(.LC0)
 2088 0712 90E0      		ldi r25,hi8(.LC0)
 2089 0714 9F93      		push r25
 2090 0716 8F93      		push r24
 2091 0718 8E01      		movw r16,r28
 2092 071a 0F5F      		subi r16,-1
 2093 071c 1F4F      		sbci r17,-1
 2094 071e 1F93      		push r17
 2095 0720 0F93      		push r16
 2096 0722 0E94 0000 		call sprintf
 375:main.c        ****   lcd_puts(buffer);
 2098               	.LM248:
 2099 0726 C801      		movw r24,r16
 2100 0728 0E94 0000 		call lcd_puts
 376:main.c        ****   lcd_goto(0x0f);
 2102               	.LM249:
 2103 072c 8FE0      		ldi r24,lo8(15)
 2104 072e 0E94 0000 		call lcd_goto
 377:main.c        ****   if (clar > 10)
 2106               	.LM250:
 2107 0732 8091 0000 		lds r24,clar
 2108 0736 0FB6      		in __tmp_reg__,__SREG__
 2109 0738 F894      		cli
 2110 073a DEBF      		out __SP_H__,r29
 2111 073c 0FBE      		out __SREG__,__tmp_reg__
 2112 073e CDBF      		out __SP_L__,r28
 2113 0740 8B30      		cpi r24,lo8(11)
 2114 0742 00F0      		brlo .L120
 378:main.c        ****     sprintf(buffer,"+");
 2116               	.LM251:
 2117 0744 60E0      		ldi r22,lo8(.LC1)
 2118 0746 70E0      		ldi r23,hi8(.LC1)
 2119 0748 00C0      		rjmp .L128
 2120               	.L120:
 379:main.c        ****   else if (clar < -10)
 2122               	.LM252:
 2123 074a 8091 0000 		lds r24,clar
 380:main.c        ****     sprintf(buffer,"-");
 381:main.c        ****   else
 382:main.c        ****     sprintf(buffer," ");
 2125               	.LM253:
 2126 074e 60E0      		ldi r22,lo8(.LC2)
 2127 0750 70E0      		ldi r23,hi8(.LC2)
 2128               	.L128:
 2129 0752 C801      		movw r24,r16
 2130 0754 0E94 0000 		call strcpy
 383:main.c        ****   lcd_puts(buffer);
 2132               	.LM254:
 2133 0758 C801      		movw r24,r16
 2134 075a 0E94 0000 		call lcd_puts
 2135               	/* epilogue start */
 384:main.c        **** }
 2137               	.LM255:
 2138 075e EC96      		adiw r28,60
 2139 0760 0FB6      		in __tmp_reg__,__SREG__
 2140 0762 F894      		cli
 2141 0764 DEBF      		out __SP_H__,r29
 2142 0766 0FBE      		out __SREG__,__tmp_reg__
 2143 0768 CDBF      		out __SP_L__,r28
 2144 076a DF91      		pop r29
 2145 076c CF91      		pop r28
 2146 076e 1F91      		pop r17
 2147 0770 0F91      		pop r16
 2148 0772 FF90      		pop r15
 2149 0774 EF90      		pop r14
 2150 0776 DF90      		pop r13
 2151 0778 CF90      		pop r12
 2152 077a BF90      		pop r11
 2153 077c AF90      		pop r10
 2154 077e 9F90      		pop r9
 2155 0780 8F90      		pop r8
 2156 0782 0895      		ret
 2161               	.Lscope22:
 2165               	.global	updateVolumeSquelch
 2167               	updateVolumeSquelch:
 385:main.c        **** 
 386:main.c        **** uint8_t updateVolumeSquelch(uint8_t vol, uint8_t sq) {
 2169               	.LM256:
 2170               	.LFBB23:
 2171 0784 EF92      		push r14
 2172 0786 0F93      		push r16
 2173               	/* prologue: function */
 2174               	/* frame size = 0 */
 2175               	/* stack size = 2 */
 2176               	.L__stack_usage = 2
 387:main.c        ****   
 388:main.c        ****   uint8_t addr, err;
 389:main.c        **** 
 390:main.c        ****   addr = 0x80; // Address for audio conf
 391:main.c        **** 
 392:main.c        ****   err = TWI_write_5bytes(fpga_addr, addr, 0x00, 0x00, sq, vol);
 2178               	.LM257:
 2179 0788 E82E      		mov r14,r24
 2180 078a 062F      		mov r16,r22
 2181 078c 20E0      		ldi r18,0
 2182 078e 40E0      		ldi r20,0
 2183 0790 60E8      		ldi r22,lo8(-128)
 2184 0792 83E2      		ldi r24,lo8(35)
 2185 0794 0E94 0000 		call TWI_write_5bytes
 2186               	/* epilogue start */
 393:main.c        ****   if(err)
 394:main.c        ****     return err;
 395:main.c        ****   return 0x00;
 396:main.c        **** }
 2188               	.LM258:
 2189 0798 0F91      		pop r16
 2190 079a EF90      		pop r14
 2191 079c 0895      		ret
 2193               	.Lscope23:
 2195               	.global	readClar
 2197               	readClar:
 397:main.c        **** 
 398:main.c        **** uint16_t readClar(void) {
 2199               	.LM259:
 2200               	.LFBB24:
 2201               	/* prologue: function */
 2202               	/* frame size = 0 */
 2203               	/* stack size = 0 */
 2204               	.L__stack_usage = 0
 399:main.c        ****   return (ADC);
 2206               	.LM260:
 2207 079e 84B1      		in r24,0x4
 2208 07a0 95B1      		in r25,0x4+1
 400:main.c        **** }
 2210               	.LM261:
 2211 07a2 0895      		ret
 2213               	.Lscope24:
 2215               	.global	updateRFFE
 2217               	updateRFFE:
 401:main.c        **** 
 402:main.c        **** uint8_t updateRFFE(void) {
 2219               	.LM262:
 2220               	.LFBB25:
 2221               	/* prologue: function */
 2222               	/* frame size = 0 */
 2223               	/* stack size = 0 */
 2224               	.L__stack_usage = 0
 403:main.c        ****   uint8_t err;
 404:main.c        ****   uint16_t rxatt;
 405:main.c        **** 
 406:main.c        ****   if (rx_att)
 2226               	.LM263:
 2227 07a4 4091 0000 		lds r20,rx_att
 407:main.c        ****     rxatt = 0x0001;
 408:main.c        ****   else
 409:main.c        ****     rxatt = 0x0000;
 410:main.c        **** 
 411:main.c        ****   err = TWI_write_word(pll_addr,(pll_n & 0x0fff) | (tx << 15) | (bandf << 14) | (rxatt << 13));
 2229               	.LM264:
 2230 07a8 8091 0000 		lds r24,pll_n
 2231 07ac 9091 0000 		lds r25,pll_n+1
 2232 07b0 6091 0000 		lds r22,tx
 2233 07b4 7091 0000 		lds r23,tx+1
 2234 07b8 2091 0000 		lds r18,bandf
 2235 07bc 3091 0000 		lds r19,bandf+1
 2236 07c0 7727      		clr r23
 2237 07c2 6695      		lsr r22
 2238 07c4 7795      		ror r23
 2239 07c6 6627      		clr r22
 2240 07c8 9F70      		andi r25,15
 2241 07ca 682B      		or r22,r24
 2242 07cc 792B      		or r23,r25
 2243 07ce 30E4      		ldi r19,0x40
 2244 07d0 239F      		mul r18,r19
 2245 07d2 302D      		mov r19,r0
 2246 07d4 2227      		clr r18
 2247 07d6 1124      		clr __zero_reg__
 2248 07d8 622B      		or r22,r18
 2249 07da 732B      		or r23,r19
 406:main.c        ****     rxatt = 0x0001;
 2251               	.LM265:
 2252 07dc 21E0      		ldi r18,lo8(1)
 2253 07de 4111      		cpse r20,__zero_reg__
 2254 07e0 00C0      		rjmp .L132
 2255 07e2 20E0      		ldi r18,0
 2256               	.L132:
 2258               	.LM266:
 2259 07e4 80E0      		ldi r24,0
 2260 07e6 90E0      		ldi r25,0
 2261 07e8 922F      		mov r25,r18
 2262 07ea 9295      		swap r25
 2263 07ec 990F      		lsl r25
 2264 07ee 907E      		andi r25,lo8(-32)
 2265 07f0 682B      		or r22,r24
 2266 07f2 792B      		or r23,r25
 2267 07f4 82E2      		ldi r24,lo8(34)
 2268 07f6 0E94 0000 		call TWI_write_word
 412:main.c        ****   if (err)
 2270               	.LM267:
 2271 07fa 8823      		tst r24
 2272 07fc 01F0      		breq .L134
 413:main.c        ****     return err+5;
 2274               	.LM268:
 2275 07fe 8B5F      		subi r24,lo8(-(5))
 2276 0800 0895      		ret
 2277               	.L134:
 414:main.c        ****   return 0x00;
 2279               	.LM269:
 2280 0802 80E0      		ldi r24,0
 415:main.c        **** } 
 2282               	.LM270:
 2283 0804 0895      		ret
 2288               	.Lscope25:
 2289               	.global	__subsf3
 2290               	.global	__mulsf3
 2291               	.global	__fixunssfsi
 2294               	.global	updateFreq
 2296               	updateFreq:
 416:main.c        ****   
 417:main.c        **** uint8_t updateFreq(uint8_t all_update) {
 2298               	.LM271:
 2299               	.LFBB26:
 2300 0806 8F92      		push r8
 2301 0808 9F92      		push r9
 2302 080a AF92      		push r10
 2303 080c BF92      		push r11
 2304 080e CF92      		push r12
 2305 0810 DF92      		push r13
 2306 0812 EF92      		push r14
 2307 0814 FF92      		push r15
 2308 0816 0F93      		push r16
 2309 0818 1F93      		push r17
 2310 081a CF93      		push r28
 2311 081c DF93      		push r29
 2312 081e 1F92      		push __zero_reg__
 2313 0820 CDB7      		in r28,__SP_L__
 2314 0822 DEB7      		in r29,__SP_H__
 2315               	/* prologue: function */
 2316               	/* frame size = 1 */
 2317               	/* stack size = 13 */
 2318               	.L__stack_usage = 13
 418:main.c        ****   //   char buffer[60];
 419:main.c        ****   uint8_t byte1, byte2, byte3, byte4, byte5, err;
 420:main.c        ****   uint16_t pll_n_ = pll_n;
 2320               	.LM272:
 2321 0824 2091 0000 		lds r18,pll_n
 2322 0828 3091 0000 		lds r19,pll_n+1
 421:main.c        ****   double freq_lo, if_freq, ref_freq, ftw;
 422:main.c        ****   static double ftw_toptop, ftw_topbot, ftw_bottop, ftw_botbot;
 423:main.c        **** 
 424:main.c        ****   /*  if (band < 200) { 
 425:main.c        ****     freq_lo = (double)(freq_MHz*1000 + 45000 + freq_kHz);
 426:main.c        ****     bandf = 0;
 427:main.c        ****   }
 428:main.c        ****   else {
 429:main.c        ****     if (freq < 200*1e6) 
 430:main.c        ****       freq_lo = (double)(freq_MHz*1000 + 21400 + freq_kHz);
 431:main.c        ****     else
 432:main.c        ****       freq_lo = (double)((freq_MHz - 1152)*1000 + 21400 + freq_kHz);
 433:main.c        ****     bandf = 1;
 434:main.c        ****     }*/
 435:main.c        **** 
 436:main.c        ****   if (all_update) {
 2324               	.LM273:
 2325 082c 8823      		tst r24
 2326 082e 01F4      		brne .+2
 2327 0830 00C0      		rjmp .L136
 437:main.c        **** #if F_IF == 21
 438:main.c        ****     if_freq=21400;
 439:main.c        **** #elif F_IF == 45
 440:main.c        ****     if_freq=45000;
 441:main.c        **** #endif
 442:main.c        **** #ifdef LO_FREQ_PLUS_IF
 443:main.c        ****     freq_lo = freq + if_freq;
 444:main.c        **** #endif
 445:main.c        **** #ifdef LO_FREQ_MINUS_IF
 446:main.c        ****     freq_lo = freq - if_freq;
 447:main.c        **** #endif
 448:main.c        **** #ifdef LO_IF_PLUS_FREQ
 449:main.c        ****     freq_lo = if_freq + freq;
 450:main.c        **** #endif
 451:main.c        **** #ifdef LO_IF_MINUS_FREQ
 452:main.c        ****     freq_lo = if_freq - freq;
 2329               	.LM274:
 2330 0832 2091 0000 		lds r18,freq
 2331 0836 3091 0000 		lds r19,freq+1
 2332 083a 4091 0000 		lds r20,freq+2
 2333 083e 5091 0000 		lds r21,freq+3
 2334 0842 60E0      		ldi r22,0
 2335 0844 78EC      		ldi r23,lo8(-56)
 2336 0846 8FE2      		ldi r24,lo8(47)
 2337 0848 97E4      		ldi r25,lo8(71)
 2338 084a 0E94 0000 		call __subsf3
 453:main.c        **** #endif
 454:main.c        **** 
 455:main.c        ****     bandf = 1;
 2340               	.LM275:
 2341 084e 21E0      		ldi r18,lo8(1)
 2342 0850 30E0      		ldi r19,0
 2343 0852 3093 0000 		sts bandf+1,r19
 2344 0856 2093 0000 		sts bandf,r18
 456:main.c        **** 
 457:main.c        ****     if (mode == USB) {
 2346               	.LM276:
 2347 085a 2091 0000 		lds r18,mode
 2348 085e 2330      		cpi r18,lo8(3)
 2349 0860 01F4      		brne .L137
 458:main.c        ****       freq_lo -= (double)1.8;
 2351               	.LM277:
 2352 0862 26E6      		ldi r18,lo8(102)
 2353 0864 36E6      		ldi r19,lo8(102)
 2354 0866 46EE      		ldi r20,lo8(-26)
 2355 0868 5FE3      		ldi r21,lo8(63)
 2356 086a 0E94 0000 		call __subsf3
 2357 086e 00C0      		rjmp .L138
 2358               	.L137:
 459:main.c        ****     }
 460:main.c        ****     else if (mode == CW) {
 2360               	.LM278:
 2361 0870 2091 0000 		lds r18,mode
 2362 0874 2530      		cpi r18,lo8(5)
 2363 0876 01F4      		brne .L139
 461:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 462:main.c        ****       freq_lo -= (double)0.9;  // CW = USB
 463:main.c        **** #else
 464:main.c        ****       freq_lo += (double)0.9;  // CW = LSB
 2365               	.LM279:
 2366 0878 26E6      		ldi r18,lo8(102)
 2367 087a 36E6      		ldi r19,lo8(102)
 2368 087c 46E6      		ldi r20,lo8(102)
 2369 087e 5FE3      		ldi r21,lo8(63)
 2370 0880 00C0      		rjmp .L146
 2371               	.L139:
 465:main.c        **** #endif
 466:main.c        **** 
 467:main.c        ****     }
 468:main.c        ****     else if (mode == CWN) {
 2373               	.LM280:
 2374 0882 2091 0000 		lds r18,mode
 2375 0886 2630      		cpi r18,lo8(6)
 2376 0888 01F0      		breq .L138
 469:main.c        ****       //freq_lo += (double)0.9;
 470:main.c        ****     }
 471:main.c        ****     else if (mode == LSB ) {
 2378               	.LM281:
 2379 088a 2091 0000 		lds r18,mode
 2380 088e 2130      		cpi r18,lo8(1)
 2381 0890 01F4      		brne .L138
 472:main.c        ****       freq_lo += (double)1.8;
 2383               	.LM282:
 2384 0892 26E6      		ldi r18,lo8(102)
 2385 0894 36E6      		ldi r19,lo8(102)
 2386 0896 46EE      		ldi r20,lo8(-26)
 2387 0898 5FE3      		ldi r21,lo8(63)
 2388               	.L146:
 2389 089a 0E94 0000 		call __addsf3
 2390               	.L138:
 473:main.c        ****     }
 474:main.c        **** 
 475:main.c        **** #ifdef INDIRECT_FREQ
 476:main.c        ****     pll_n_ = (uint16_t)lround(freq_lo/(double)100);  // 100 kHz step
 477:main.c        ****     ref_freq = 170*freq_lo/pll_n_;  // 170 ref divider value
 478:main.c        ****     ftw = ref_freq*(double)279.62026666667; // 20MHz,25bit: 279.620266667 19.2MHz,22bit: 36.4088889
 479:main.c        ****     ftw_toptop = floor(ftw/(double)16777216);
 480:main.c        ****     ftw_topbot = floor((ftw-ftw_toptop*(double)16777216)/(double)65536);
 481:main.c        ****     ftw_bottop = floor((ftw-ftw_toptop*(double)16777216-ftw_topbot*(double)65536)/(double)256);
 482:main.c        ****     ftw_botbot = fmod(ftw,256);
 483:main.c        **** #endif
 484:main.c        **** #ifdef DIRECT_FREQ
 485:main.c        ****     ftw = freq_lo*(double)279.62026666667; // 20MHz,25bit: 279.620266667 19.2MHz,22bit: 36.4088889
 2392               	.LM283:
 2393 089e 25E6      		ldi r18,lo8(101)
 2394 08a0 3FEC      		ldi r19,lo8(-49)
 2395 08a2 4BE8      		ldi r20,lo8(-117)
 2396 08a4 53E4      		ldi r21,lo8(67)
 2397 08a6 0E94 0000 		call __mulsf3
 2398 08aa 6B01      		movw r12,r22
 2399 08ac 7C01      		movw r14,r24
 486:main.c        ****     ftw_toptop = floor(ftw/(double)16777216);
 2401               	.LM284:
 2402 08ae 20E0      		ldi r18,0
 2403 08b0 30E0      		ldi r19,0
 2404 08b2 40E8      		ldi r20,lo8(-128)
 2405 08b4 53E3      		ldi r21,lo8(51)
 2406 08b6 0E94 0000 		call __mulsf3
 2407 08ba 0E94 0000 		call floor
 2408 08be 6093 0000 		sts ftw_toptop.2407,r22
 2409 08c2 7093 0000 		sts ftw_toptop.2407+1,r23
 2410 08c6 8093 0000 		sts ftw_toptop.2407+2,r24
 2411 08ca 9093 0000 		sts ftw_toptop.2407+3,r25
 487:main.c        ****     ftw_topbot = floor((ftw-ftw_toptop*(double)16777216)/(double)65536);
 2413               	.LM285:
 2414 08ce 20E0      		ldi r18,0
 2415 08d0 30E0      		ldi r19,0
 2416 08d2 40E8      		ldi r20,lo8(-128)
 2417 08d4 5BE4      		ldi r21,lo8(75)
 2418 08d6 0E94 0000 		call __mulsf3
 2419 08da 9B01      		movw r18,r22
 2420 08dc AC01      		movw r20,r24
 2421 08de C701      		movw r24,r14
 2422 08e0 B601      		movw r22,r12
 2423 08e2 0E94 0000 		call __subsf3
 2424 08e6 4B01      		movw r8,r22
 2425 08e8 5C01      		movw r10,r24
 2426 08ea 20E0      		ldi r18,0
 2427 08ec 30E0      		ldi r19,0
 2428 08ee 40E8      		ldi r20,lo8(-128)
 2429 08f0 57E3      		ldi r21,lo8(55)
 2430 08f2 0E94 0000 		call __mulsf3
 2431 08f6 0E94 0000 		call floor
 2432 08fa 6093 0000 		sts ftw_topbot.2408,r22
 2433 08fe 7093 0000 		sts ftw_topbot.2408+1,r23
 2434 0902 8093 0000 		sts ftw_topbot.2408+2,r24
 2435 0906 9093 0000 		sts ftw_topbot.2408+3,r25
 488:main.c        ****     ftw_bottop = floor((ftw-ftw_toptop*(double)16777216-ftw_topbot*(double)65536)/(double)256);
 2437               	.LM286:
 2438 090a 20E0      		ldi r18,0
 2439 090c 30E0      		ldi r19,0
 2440 090e 40E8      		ldi r20,lo8(-128)
 2441 0910 57E4      		ldi r21,lo8(71)
 2442 0912 0E94 0000 		call __mulsf3
 2443 0916 9B01      		movw r18,r22
 2444 0918 AC01      		movw r20,r24
 2445 091a C501      		movw r24,r10
 2446 091c B401      		movw r22,r8
 2447 091e 0E94 0000 		call __subsf3
 2448 0922 20E0      		ldi r18,0
 2449 0924 30E0      		ldi r19,0
 2450 0926 40E8      		ldi r20,lo8(-128)
 2451 0928 5BE3      		ldi r21,lo8(59)
 2452 092a 0E94 0000 		call __mulsf3
 2453 092e 0E94 0000 		call floor
 2454 0932 6093 0000 		sts ftw_bottop.2409,r22
 2455 0936 7093 0000 		sts ftw_bottop.2409+1,r23
 2456 093a 8093 0000 		sts ftw_bottop.2409+2,r24
 2457 093e 9093 0000 		sts ftw_bottop.2409+3,r25
 489:main.c        ****     ftw_botbot = fmod(ftw,256);
 2459               	.LM287:
 2460 0942 20E0      		ldi r18,0
 2461 0944 30E0      		ldi r19,0
 2462 0946 40E8      		ldi r20,lo8(-128)
 2463 0948 53E4      		ldi r21,lo8(67)
 2464 094a C701      		movw r24,r14
 2465 094c B601      		movw r22,r12
 2466 094e 0E94 0000 		call fmod
 2467 0952 6093 0000 		sts ftw_botbot.2410,r22
 2468 0956 7093 0000 		sts ftw_botbot.2410+1,r23
 2469 095a 8093 0000 		sts ftw_botbot.2410+2,r24
 2470 095e 9093 0000 		sts ftw_botbot.2410+3,r25
 2471               	.L136:
 490:main.c        **** #endif    
 491:main.c        ****   }
 492:main.c        **** 
 493:main.c        **** #if defined(LO_FREQ_PLUS_IF) || defined(LO_IF_PLUS_FREQ)
 494:main.c        ****   clar = -(clar+1);  // For arch with LO above RF freq
 495:main.c        **** #endif
 496:main.c        ****   byte1 = 0xc0;
 497:main.c        ****   byte2 = (uint8_t)(ftw_toptop) | (clar & 0xfe);
 2473               	.LM288:
 2474 0962 1091 0000 		lds r17,clar
 498:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 499:main.c        ****   byte4 = (uint8_t)ftw_bottop;
 500:main.c        ****   byte5 = (uint8_t)ftw_botbot;
 2476               	.LM289:
 2477 0966 6091 0000 		lds r22,ftw_botbot.2410
 2478 096a 7091 0000 		lds r23,ftw_botbot.2410+1
 2479 096e 8091 0000 		lds r24,ftw_botbot.2410+2
 2480 0972 9091 0000 		lds r25,ftw_botbot.2410+3
 2481 0976 0E94 0000 		call __fixunssfsi
 2482 097a E62E      		mov r14,r22
 499:main.c        ****   byte5 = (uint8_t)ftw_botbot;
 2484               	.LM290:
 2485 097c 6091 0000 		lds r22,ftw_bottop.2409
 2486 0980 7091 0000 		lds r23,ftw_bottop.2409+1
 2487 0984 8091 0000 		lds r24,ftw_bottop.2409+2
 2488 0988 9091 0000 		lds r25,ftw_bottop.2409+3
 2489 098c 0E94 0000 		call __fixunssfsi
 2490 0990 062F      		mov r16,r22
 498:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 2492               	.LM291:
 2493 0992 6091 0000 		lds r22,ftw_topbot.2408
 2494 0996 7091 0000 		lds r23,ftw_topbot.2408+1
 2495 099a 8091 0000 		lds r24,ftw_topbot.2408+2
 2496 099e 9091 0000 		lds r25,ftw_topbot.2408+3
 2497 09a2 0E94 0000 		call __fixunssfsi
 2498 09a6 262F      		mov r18,r22
 497:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 2500               	.LM292:
 2501 09a8 1E7F      		andi r17,lo8(-2)
 2502 09aa 6091 0000 		lds r22,ftw_toptop.2407
 2503 09ae 7091 0000 		lds r23,ftw_toptop.2407+1
 2504 09b2 8091 0000 		lds r24,ftw_toptop.2407+2
 2505 09b6 9091 0000 		lds r25,ftw_toptop.2407+3
 2506 09ba 2983      		std Y+1,r18
 2507 09bc 0E94 0000 		call __fixunssfsi
 2508 09c0 412F      		mov r20,r17
 2509 09c2 462B      		or r20,r22
 501:main.c        **** 
 502:main.c        ****   err = TWI_write_5bytes(fpga_addr, byte1, byte2, byte3, byte4, byte5);
 2511               	.LM293:
 2512 09c4 2981      		ldd r18,Y+1
 2513 09c6 60EC      		ldi r22,lo8(-64)
 2514 09c8 83E2      		ldi r24,lo8(35)
 2515 09ca 0E94 0000 		call TWI_write_5bytes
 2516               	/* epilogue start */
 503:main.c        ****   if(err)
 504:main.c        ****     return err;
 505:main.c        ****  
 506:main.c        **** #ifdef INDIRECT_FREQ
 507:main.c        ****   _delay_us(50);
 508:main.c        ****   if (pll_n != pll_n_) {
 509:main.c        ****     pll_n = pll_n_;
 510:main.c        ****     err = updateRFFE();
 511:main.c        ****     if (err)
 512:main.c        ****       return err+5;
 513:main.c        ****   }
 514:main.c        **** #endif
 515:main.c        ****   return 0x00;
 516:main.c        **** }
 2518               	.LM294:
 2519 09ce 0F90      		pop __tmp_reg__
 2520 09d0 DF91      		pop r29
 2521 09d2 CF91      		pop r28
 2522 09d4 1F91      		pop r17
 2523 09d6 0F91      		pop r16
 2524 09d8 FF90      		pop r15
 2525 09da EF90      		pop r14
 2526 09dc DF90      		pop r13
 2527 09de CF90      		pop r12
 2528 09e0 BF90      		pop r11
 2529 09e2 AF90      		pop r10
 2530 09e4 9F90      		pop r9
 2531 09e6 8F90      		pop r8
 2532 09e8 0895      		ret
 2542               	.Lscope26:
 2544               	.global	updateSettings
 2546               	updateSettings:
 517:main.c        **** 
 518:main.c        **** uint8_t updateSettings (void) {
 2548               	.LM295:
 2549               	.LFBB27:
 2550 09ea EF92      		push r14
 2551 09ec 0F93      		push r16
 2552               	/* prologue: function */
 2553               	/* frame size = 0 */
 2554               	/* stack size = 2 */
 2555               	.L__stack_usage = 2
 519:main.c        **** 
 520:main.c        ****   uint8_t err;
 521:main.c        ****   uint8_t byte0, byte1, byte2, byte3, byte4;
 522:main.c        **** 
 523:main.c        ****   switch (mode) {  
 2557               	.LM296:
 2558 09ee 9091 0000 		lds r25,mode
 2559 09f2 9530      		cpi r25,lo8(5)
 2560 09f4 01F0      		breq .L149
 2561 09f6 00F4      		brsh .L150
 2562 09f8 9130      		cpi r25,lo8(1)
 2563 09fa 01F0      		breq .L149
 2564 09fc 9330      		cpi r25,lo8(3)
 2565 09fe 01F0      		breq .+2
 2566 0a00 00C0      		rjmp .L148
 524:main.c        ****   case LSB:
 525:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 526:main.c        ****     byte0 = 0b01111000; // Set USB
 527:main.c        **** #else
 528:main.c        ****     byte0 = 0b01110000; // Set LSB
 529:main.c        **** #endif
 530:main.c        **** #if F_IF == 21
 531:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 532:main.c        ****     byte2 = 0x08;
 533:main.c        **** #elif F_IF == 45
 534:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 535:main.c        ****     byte2 = 0x88;
 536:main.c        **** #endif
 537:main.c        ****     byte3 = 0x00;
 538:main.c        ****     byte4 = 0x00;
 539:main.c        ****     break;
 540:main.c        **** 
 541:main.c        ****   case USB:
 542:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 543:main.c        ****     byte0 = 0b01110000; // Set LSB
 544:main.c        **** #else
 545:main.c        ****     byte0 = 0b01111000; // Set USB
 546:main.c        **** #endif
 547:main.c        **** #if F_IF == 21
 548:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 549:main.c        ****     byte2 = 0x08;
 550:main.c        **** #elif F_IF == 45
 551:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2568               	.LM297:
 2569 0a02 9091 0000 		lds r25,tx_att
 2570 0a06 8091 0000 		lds r24,rx_att
 2571 0a0a 28E0      		ldi r18,lo8(8)
 2572 0a0c 829F      		mul r24,r18
 2573 0a0e A001      		movw r20,r0
 2574 0a10 1124      		clr __zero_reg__
 2575 0a12 20E4      		ldi r18,lo8(64)
 2576 0a14 929F      		mul r25,r18
 2577 0a16 C001      		movw r24,r0
 2578 0a18 1124      		clr __zero_reg__
 2579 0a1a 482B      		or r20,r24
 545:main.c        **** #endif
 2581               	.LM298:
 2582 0a1c 68E7      		ldi r22,lo8(120)
 552:main.c        ****     byte2 = 0x88;
 553:main.c        **** #endif
 554:main.c        ****     byte3 = 0x00;
 555:main.c        ****     byte4 = 0x00;
 556:main.c        ****     break;
 2584               	.LM299:
 2585 0a1e 00C0      		rjmp .L148
 2586               	.L150:
 523:main.c        ****   case LSB:
 2588               	.LM300:
 2589 0a20 9830      		cpi r25,lo8(8)
 2590 0a22 01F0      		breq .L153
 2591 0a24 9A30      		cpi r25,lo8(10)
 2592 0a26 01F0      		breq .L154
 2593 0a28 9630      		cpi r25,lo8(6)
 2594 0a2a 01F4      		brne .L148
 557:main.c        **** 
 558:main.c        ****   case CW:
 559:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 560:main.c        ****     byte0 = 0b01111000; // Set USB
 561:main.c        **** #else
 562:main.c        ****     byte0 = 0b01110000; // Set LSB
 563:main.c        **** #endif
 564:main.c        **** #if F_IF == 21
 565:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 566:main.c        ****     byte2 = 0x08;
 567:main.c        **** #elif F_IF == 45
 568:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 569:main.c        ****     byte2 = 0x88;
 570:main.c        **** #endif
 571:main.c        ****     byte3 = 0x00;
 572:main.c        ****     byte4 = 0x00;
 573:main.c        ****     break;
 574:main.c        **** 
 575:main.c        ****   case CWN:
 576:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 577:main.c        ****     byte0 = 0b01101000; // Set narrow USB
 578:main.c        **** #else
 579:main.c        ****     byte0 = 0b01100000; // Set narrow LSB
 580:main.c        **** #endif
 581:main.c        **** #if F_IF == 21
 582:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 583:main.c        ****     byte2 = 0x08;
 584:main.c        **** #elif F_IF == 45
 585:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2596               	.LM301:
 2597 0a2c 9091 0000 		lds r25,tx_att
 2598 0a30 8091 0000 		lds r24,rx_att
 2599 0a34 28E0      		ldi r18,lo8(8)
 2600 0a36 829F      		mul r24,r18
 2601 0a38 A001      		movw r20,r0
 2602 0a3a 1124      		clr __zero_reg__
 2603 0a3c 20E4      		ldi r18,lo8(64)
 2604 0a3e 929F      		mul r25,r18
 2605 0a40 C001      		movw r24,r0
 2606 0a42 1124      		clr __zero_reg__
 2607 0a44 482B      		or r20,r24
 579:main.c        **** #endif
 2609               	.LM302:
 2610 0a46 60E6      		ldi r22,lo8(96)
 586:main.c        ****     byte2 = 0x88;
 587:main.c        **** #endif
 588:main.c        ****     byte3 = 0x00;
 589:main.c        ****     byte4 = 0x00;
 590:main.c        ****     break;
 2612               	.LM303:
 2613 0a48 00C0      		rjmp .L148
 2614               	.L149:
 568:main.c        ****     byte2 = 0x88;
 2616               	.LM304:
 2617 0a4a 9091 0000 		lds r25,tx_att
 2618 0a4e 8091 0000 		lds r24,rx_att
 2619 0a52 28E0      		ldi r18,lo8(8)
 2620 0a54 829F      		mul r24,r18
 2621 0a56 A001      		movw r20,r0
 2622 0a58 1124      		clr __zero_reg__
 2623 0a5a 20E4      		ldi r18,lo8(64)
 2624 0a5c 929F      		mul r25,r18
 2625 0a5e C001      		movw r24,r0
 2626 0a60 1124      		clr __zero_reg__
 2627 0a62 482B      		or r20,r24
 562:main.c        **** #endif
 2629               	.LM305:
 2630 0a64 60E7      		ldi r22,lo8(112)
 573:main.c        **** 
 2632               	.LM306:
 2633 0a66 00C0      		rjmp .L148
 2634               	.L153:
 591:main.c        **** 
 592:main.c        ****   case AM:
 593:main.c        ****     byte0 = 0b01000000;
 594:main.c        **** #if F_IF == 21
 595:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 596:main.c        ****     byte2 = 0x08;
 597:main.c        **** #elif F_IF == 45
 598:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2636               	.LM307:
 2637 0a68 9091 0000 		lds r25,tx_att
 2638 0a6c 8091 0000 		lds r24,rx_att
 2639 0a70 28E0      		ldi r18,lo8(8)
 2640 0a72 829F      		mul r24,r18
 2641 0a74 A001      		movw r20,r0
 2642 0a76 1124      		clr __zero_reg__
 2643 0a78 20E4      		ldi r18,lo8(64)
 2644 0a7a 929F      		mul r25,r18
 2645 0a7c C001      		movw r24,r0
 2646 0a7e 1124      		clr __zero_reg__
 2647 0a80 482B      		or r20,r24
 593:main.c        **** #if F_IF == 21
 2649               	.LM308:
 2650 0a82 60E4      		ldi r22,lo8(64)
 599:main.c        ****     byte2 = 0x88;
 600:main.c        **** #endif
 601:main.c        ****     byte3 = 0x00;
 602:main.c        ****     byte4 = 0x00;
 603:main.c        ****     break;
 2652               	.LM309:
 2653 0a84 00C0      		rjmp .L148
 2654               	.L154:
 604:main.c        **** 
 605:main.c        ****   case FM:
 606:main.c        ****     byte0 = 0b01000001;
 607:main.c        **** #if F_IF == 21
 608:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 609:main.c        ****     byte2 = 0x08;
 610:main.c        **** #elif F_IF == 45
 611:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2656               	.LM310:
 2657 0a86 9091 0000 		lds r25,tx_att
 2658 0a8a 8091 0000 		lds r24,rx_att
 2659 0a8e 28E0      		ldi r18,lo8(8)
 2660 0a90 829F      		mul r24,r18
 2661 0a92 A001      		movw r20,r0
 2662 0a94 1124      		clr __zero_reg__
 2663 0a96 20E4      		ldi r18,lo8(64)
 2664 0a98 929F      		mul r25,r18
 2665 0a9a C001      		movw r24,r0
 2666 0a9c 1124      		clr __zero_reg__
 2667 0a9e 482B      		or r20,r24
 606:main.c        **** #if F_IF == 21
 2669               	.LM311:
 2670 0aa0 61E4      		ldi r22,lo8(65)
 2671               	.L148:
 612:main.c        ****     byte2 = 0x88;
 613:main.c        **** #endif
 614:main.c        ****     byte3 = 0x00;
 615:main.c        ****     byte4 = 0x00;
 616:main.c        ****   }
 617:main.c        ****   
 618:main.c        ****   err = TWI_write_5bytes(fpga_addr, byte0, byte1, byte2, byte3, byte4);
 2673               	.LM312:
 2674 0aa2 E12C      		mov r14,__zero_reg__
 2675 0aa4 00E0      		ldi r16,0
 2676 0aa6 28E8      		ldi r18,lo8(-120)
 2677 0aa8 83E2      		ldi r24,lo8(35)
 2678 0aaa 0E94 0000 		call TWI_write_5bytes
 2679               	/* epilogue start */
 619:main.c        ****   if (err)
 620:main.c        ****     return err;
 621:main.c        **** 
 622:main.c        ****   return 0x00;
 623:main.c        **** 
 624:main.c        **** }
 2681               	.LM313:
 2682 0aae 0F91      		pop r16
 2683 0ab0 EF90      		pop r14
 2684 0ab2 0895      		ret
 2690               	.Lscope27:
 2692               	.global	adcInit
 2694               	adcInit:
 625:main.c        **** 
 626:main.c        **** void adcInit(void) {
 2696               	.LM314:
 2697               	.LFBB28:
 2698               	/* prologue: function */
 2699               	/* frame size = 0 */
 2700               	/* stack size = 0 */
 2701               	.L__stack_usage = 0
 627:main.c        ****   ADCSRA = (1 << ADEN) | (1 << ADFR) | (1 << ADPS2) | (1 << ADPS1); // Free run, /64 -> 77 kHz
 2703               	.LM315:
 2704 0ab4 86EA      		ldi r24,lo8(-90)
 2705 0ab6 86B9      		out 0x6,r24
 628:main.c        ****   ADMUX = 0x43; // ADC3, AVCC ref
 2707               	.LM316:
 2708 0ab8 83E4      		ldi r24,lo8(67)
 2709 0aba 87B9      		out 0x7,r24
 629:main.c        ****   ADCSRA |= (1 << ADSC); // Start conversion
 2711               	.LM317:
 2712 0abc 369A      		sbi 0x6,6
 2713 0abe 0895      		ret
 2715               	.Lscope28:
 2717               	.global	Timer0Init
 2719               	Timer0Init:
 630:main.c        **** 
 631:main.c        **** }
 632:main.c        **** 
 633:main.c        **** void Timer0Init(void) {
 2721               	.LM318:
 2722               	.LFBB29:
 2723               	/* prologue: function */
 2724               	/* frame size = 0 */
 2725               	/* stack size = 0 */
 2726               	.L__stack_usage = 0
 634:main.c        **** 
 635:main.c        ****   TCCR0 = 0x0f; // CTC mode, 1024 prescaler
 2728               	.LM319:
 2729 0ac0 8FE0      		ldi r24,lo8(15)
 2730 0ac2 83BF      		out 0x33,r24
 636:main.c        ****   OCR0 = (uint8_t)10; // 1000000/(1024*10) = 100 Hz, 10ms
 2732               	.LM320:
 2733 0ac4 8AE0      		ldi r24,lo8(10)
 2734 0ac6 81BF      		out 0x31,r24
 637:main.c        ****   TIMSK |= (1 << OCIE0); // Interrupt at compare match
 2736               	.LM321:
 2737 0ac8 87B7      		in r24,0x37
 2738 0aca 8260      		ori r24,lo8(2)
 2739 0acc 87BF      		out 0x37,r24
 2740 0ace 0895      		ret
 2742               	.Lscope29:
 2744               	.global	Timer1Init
 2746               	Timer1Init:
 638:main.c        **** }
 639:main.c        **** 
 640:main.c        **** void Timer1Init(void) {
 2748               	.LM322:
 2749               	.LFBB30:
 2750               	/* prologue: function */
 2751               	/* frame size = 0 */
 2752               	/* stack size = 0 */
 2753               	.L__stack_usage = 0
 641:main.c        **** 
 642:main.c        ****   TCCR1A = 0x00;  
 2755               	.LM323:
 2756 0ad0 1FBC      		out 0x2f,__zero_reg__
 643:main.c        ****   TCCR1B = 0x0b; // CTC mode, 64 prescaler
 2758               	.LM324:
 2759 0ad2 8BE0      		ldi r24,lo8(11)
 2760 0ad4 8EBD      		out 0x2e,r24
 644:main.c        ****   OCR1A = (uint16_t)1563; // 1000000/(64*1563) = 10 Hz, 100ms
 2762               	.LM325:
 2763 0ad6 8BE1      		ldi r24,lo8(27)
 2764 0ad8 96E0      		ldi r25,lo8(6)
 2765 0ada 9BBD      		out 0x2a+1,r25
 2766 0adc 8ABD      		out 0x2a,r24
 645:main.c        ****   TIMSK |= (1 << OCIE1A); // Interrupt at compare match
 2768               	.LM326:
 2769 0ade 87B7      		in r24,0x37
 2770 0ae0 8061      		ori r24,lo8(16)
 2771 0ae2 87BF      		out 0x37,r24
 2772 0ae4 0895      		ret
 2774               	.Lscope30:
 2775               		.section	.rodata.str1.1
 2776               	.LC3:
 2777 0013 4572 7220 		.string	"Err %x         "
 2777      2578 2020 
 2777      2020 2020 
 2777      2020 2000 
 2778               	.global	__nesf2
 2779               	.LC4:
 2780 0023 532D 2D2D 		.string	"S---9+++   "
 2780      392B 2B2B 
 2780      2020 2000 
 2781               	.LC5:
 2782 002f 5325 6420 		.string	"S%d         "
 2782      2020 2020 
 2782      2020 2020 
 2782      00
 2783               	.LC6:
 2784 003c 532D 2564 		.string	"S-%d        "
 2784      2020 2020 
 2784      2020 2020 
 2784      00
 2785               	.LC7:
 2786 0049 532D 2D25 		.string	"S--%d       "
 2786      6420 2020 
 2786      2020 2020 
 2786      00
 2787               	.LC8:
 2788 0056 532D 2D2D 		.string	"S---%d      "
 2788      2564 2020 
 2788      2020 2020 
 2788      00
 2789               	.LC9:
 2790 0063 532D 2D2D 		.string	"S----%d     "
 2790      2D25 6420 
 2790      2020 2020 
 2790      00
 2791               	.LC10:
 2792 0070 532D 2D2D 		.string	"S----9+    "
 2792      2D39 2B20 
 2792      2020 2000 
 2793               	.LC11:
 2794 007c 532D 2D2D 		.string	"S----9++   "
 2794      2D39 2B2B 
 2794      2020 2000 
 2795               	.LC12:
 2796 0088 5553 4220 		.string	"USB "
 2796      00
 2797               	.LC13:
 2798 008d 4357 2020 		.string	"CW  "
 2798      00
 2799               	.LC14:
 2800 0092 4357 4E20 		.string	"CWN "
 2800      00
 2801               	.LC15:
 2802 0097 414D 2020 		.string	"AM  "
 2802      00
 2803               	.LC16:
 2804 009c 464D 2020 		.string	"FM  "
 2804      00
 2805               	.LC17:
 2806 00a1 4C53 4220 		.string	"LSB "
 2806      00
 2807               	.global	__ltsf2
 2808               	.LC18:
 2809 00a6 4572 7220 		.string	"Err freq %x         "
 2809      6672 6571 
 2809      2025 7820 
 2809      2020 2020 
 2809      2020 2020 
 2810               	.LC19:
 2811 00bb 4572 7220 		.string	"Err sett %x         "
 2811      7365 7474 
 2811      2025 7820 
 2811      2020 2020 
 2811      2020 2020 
 2812               	.LC20:
 2813 00d0 566F 6C20 		.string	"Vol %d    "
 2813      2564 2020 
 2813      2020 00
 2814               	.LC21:
 2815 00db 4572 7220 		.string	"Err Vol %x         "
 2815      566F 6C20 
 2815      2578 2020 
 2815      2020 2020 
 2815      2020 2000 
 2816               	.LC22:
 2817 00ef 5371 2025 		.string	"Sq %d    "
 2817      6420 2020 
 2817      2000 
 2818               	.LC23:
 2819 00f9 4572 7220 		.string	"Err Sq %x         "
 2819      5371 2025 
 2819      7820 2020 
 2819      2020 2020 
 2819      2020 00
 2820               		.section	.text.startup,"ax",@progbits
 2822               	.global	main
 2824               	main:
 646:main.c        **** }
 647:main.c        **** 
 648:main.c        **** int main(void)
 649:main.c        **** {
 2826               	.LM327:
 2827               	.LFBB31:
 2828 0000 CF93      		push r28
 2829 0002 DF93      		push r29
 2830 0004 CDB7      		in r28,__SP_L__
 2831 0006 DEB7      		in r29,__SP_H__
 2832 0008 C354      		subi r28,67
 2833 000a D109      		sbc r29,__zero_reg__
 2834 000c 0FB6      		in __tmp_reg__,__SREG__
 2835 000e F894      		cli
 2836 0010 DEBF      		out __SP_H__,r29
 2837 0012 0FBE      		out __SREG__,__tmp_reg__
 2838 0014 CDBF      		out __SP_L__,r28
 2839               	/* prologue: function */
 2840               	/* frame size = 67 */
 2841               	/* stack size = 69 */
 2842               	.L__stack_usage = 69
 650:main.c        ****   char buffer[60];
 651:main.c        ****   double freq_last;
 652:main.c        ****   int16_t clarval, clarval_last;
 653:main.c        ****   uint8_t err, data;
 654:main.c        ****   uint8_t rssi, rssi_max=0, rssi_count=0;
 655:main.c        ****   uint8_t last_dir;
 656:main.c        ****   uint8_t squelch = 0;
 657:main.c        ****   uint8_t tx_last = 255;
 658:main.c        ****   uint8_t vol = 0x18;
 659:main.c        ****   uint16_t steps;
 660:main.c        ****   
 661:main.c        ****   static const char string_intro_row1[] PROGMEM = "*** SM6VFZ";
 662:main.c        ****   static const char string_intro_row2[] PROGMEM = "Starting radio";
 663:main.c        **** 
 664:main.c        ****   DDRA = 0xFF;
 2844               	.LM328:
 2845 0016 8FEF      		ldi r24,lo8(-1)
 2846 0018 8ABB      		out 0x1a,r24
 665:main.c        ****   DDRB = 0xFF;
 2848               	.LM329:
 2849 001a 87BB      		out 0x17,r24
 666:main.c        ****   DDRC = 0xFF;
 2851               	.LM330:
 2852 001c 84BB      		out 0x14,r24
 667:main.c        ****   DDRD = ~(uint8_t)((1 << ROT2_A)|(1 << ROT2_B));
 2854               	.LM331:
 2855 001e 93EF      		ldi r25,lo8(-13)
 2856 0020 91BB      		out 0x11,r25
 668:main.c        ****   DDRE = ~(uint8_t)((1 << ROT1_A)|(1 << ROT1_B)|(1 << VOLROT_A)|(1 << VOLROT_B)|(1 << FREQ_BUTTON))
 2858               	.LM332:
 2859 0022 97E0      		ldi r25,lo8(7)
 2860 0024 92B9      		out 0x2,r25
 669:main.c        ****   DDRF = ~(uint8_t)((1 << VOL_BUTTON)|(1 << MODE_BUTTON)|(1 << BAND_BUTTON)|(1 << CLAR_POT)|(1 << M
 2862               	.LM333:
 2863 0026 90EE      		ldi r25,lo8(-32)
 2864 0028 9093 6100 		sts 97,r25
 670:main.c        ****   DDRG = 0xFF;  
 2866               	.LM334:
 2867 002c 8093 6400 		sts 100,r24
 671:main.c        **** 	
 672:main.c        ****   PORTA = 0x00;
 2869               	.LM335:
 2870 0030 1BBA      		out 0x1b,__zero_reg__
 673:main.c        ****   PORTB = 0x00;
 2872               	.LM336:
 2873 0032 18BA      		out 0x18,__zero_reg__
 674:main.c        ****   PORTC = 0x00;
 2875               	.LM337:
 2876 0034 15BA      		out 0x15,__zero_reg__
 675:main.c        ****   PORTD = (uint8_t)((1 << ROT2_A)|(1 << ROT2_B));
 2878               	.LM338:
 2879 0036 8CE0      		ldi r24,lo8(12)
 2880 0038 82BB      		out 0x12,r24
 676:main.c        ****   PORTE = (uint8_t)((1 << ROT1_A)|(1 << ROT1_B)|(1 << VOLROT_A)|(1 << VOLROT_B)|(1 << FREQ_BUTTON)|
 2882               	.LM339:
 2883 003a 88EF      		ldi r24,lo8(-8)
 2884 003c 83B9      		out 0x3,r24
 677:main.c        ****   PORTF = (uint8_t)((1 << VOL_BUTTON)|(1 << MODE_BUTTON)|(1 << BAND_BUTTON)|(1 << MODE_BUTTON)|(1 <
 2886               	.LM340:
 2887 003e 83E1      		ldi r24,lo8(19)
 2888 0040 8093 6200 		sts 98,r24
 678:main.c        ****   PORTG = 0x00;
 2890               	.LM341:
 2891 0044 1092 6500 		sts 101,__zero_reg__
 679:main.c        **** 	
 680:main.c        ****   // turn off the analog comparator
 681:main.c        ****   ACSR = 0x40U;
 2893               	.LM342:
 2894 0048 80E4      		ldi r24,lo8(64)
 2895 004a 88B9      		out 0x8,r24
 682:main.c        **** 	
 683:main.c        ****   // turn off SPI, TWI and USART0
 684:main.c        ****   //PRR  = 0x86U;
 685:main.c        **** 	
 686:main.c        ****   EICRA = (1<<ISC21)|(1<<ISC31);
 2897               	.LM343:
 2898 004c 80EA      		ldi r24,lo8(-96)
 2899 004e 8093 6A00 		sts 106,r24
 687:main.c        ****   EICRB = (1<<ISC41)|(1<<ISC51)|(1<<ISC61)|(1<<ISC71);
 2901               	.LM344:
 2902 0052 8AEA      		ldi r24,lo8(-86)
 2903 0054 8ABF      		out 0x3a,r24
 688:main.c        **** 
 689:main.c        ****   EIMSK = (1 << INTF2)|(1 << INTF3)|(1 << INTF4)|(1 << INTF5)|(1 << INTF6)|(1 << INTF7);
 2905               	.LM345:
 2906 0056 8CEF      		ldi r24,lo8(-4)
 2907 0058 89BF      		out 0x39,r24
 2908               	.LBB481:
 2909               	.LBB482:
 2911               	.Ltext37:
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** 
 102:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 103:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** #else
 105:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 106:/usr/lib/avr/include/avr/wdt.h **** #endif
 107:/usr/lib/avr/include/avr/wdt.h **** 
 108:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 109:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 110:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 111:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 112:/usr/lib/avr/include/avr/wdt.h **** #else
 113:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 114:/usr/lib/avr/include/avr/wdt.h **** #endif
 115:/usr/lib/avr/include/avr/wdt.h **** 
 116:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 117:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 118:/usr/lib/avr/include/avr/wdt.h **** #else
 119:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 120:/usr/lib/avr/include/avr/wdt.h **** #endif
 121:/usr/lib/avr/include/avr/wdt.h **** 
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** /**
 124:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 125:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 126:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 127:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 128:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 129:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 130:/usr/lib/avr/include/avr/wdt.h **** 
 131:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 132:/usr/lib/avr/include/avr/wdt.h **** */
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h **** 
 135:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** /*
 138:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 139:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 140:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 141:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 142:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 143:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 144:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 145:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 146:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 147:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 148:/usr/lib/avr/include/avr/wdt.h **** */
 149:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 150:/usr/lib/avr/include/avr/wdt.h **** do { \
 151:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 152:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 153:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 155:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 156:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 157:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 158:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 159:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 160:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 161:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 162:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 163:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 164:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 165:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 166:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 167:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 168:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 169:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 170:/usr/lib/avr/include/avr/wdt.h **** ); \
 171:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 172:/usr/lib/avr/include/avr/wdt.h **** 
 173:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 174:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 175:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 176:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 177:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 178:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 179:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 180:/usr/lib/avr/include/avr/wdt.h ****     : \
 181:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 182:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 183:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 184:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 185:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 186:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 187:/usr/lib/avr/include/avr/wdt.h **** );
 188:/usr/lib/avr/include/avr/wdt.h **** 
 189:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 190:/usr/lib/avr/include/avr/wdt.h **** 
 191:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 192:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 193:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 194:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 195:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 196:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 197:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 198:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 199:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 200:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 201:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 202:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 203:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 204:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 205:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 206:/usr/lib/avr/include/avr/wdt.h **** )
 207:/usr/lib/avr/include/avr/wdt.h **** 
 208:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 209:/usr/lib/avr/include/avr/wdt.h **** do { \
 210:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 211:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 212:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 213:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 214:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 215:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 216:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 217:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 218:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 219:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 220:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 221:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 222:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 223:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 224:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 225:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 226:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 227:/usr/lib/avr/include/avr/wdt.h **** ); \
 228:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 229:/usr/lib/avr/include/avr/wdt.h **** 
 230:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 231:/usr/lib/avr/include/avr/wdt.h **** 
 232:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 233:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 234:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 235:/usr/lib/avr/include/avr/wdt.h **** {
 236:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 237:/usr/lib/avr/include/avr/wdt.h **** 	{
 238:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 239:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 240:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 241:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 242:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 243:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 244:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 245:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 246:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 247:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 248:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 249:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 250:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 251:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 252:/usr/lib/avr/include/avr/wdt.h **** 			);
 253:/usr/lib/avr/include/avr/wdt.h **** 	}
 254:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 255:/usr/lib/avr/include/avr/wdt.h **** 	{
 256:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 257:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 258:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 259:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 260:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 261:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 262:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 263:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 264:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 265:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 266:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 267:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 268:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 269:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 270:/usr/lib/avr/include/avr/wdt.h **** 			);
 271:/usr/lib/avr/include/avr/wdt.h **** 	}
 272:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 273:/usr/lib/avr/include/avr/wdt.h **** 	{
 274:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 275:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 276:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 277:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 278:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 279:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 280:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 281:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 282:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 283:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 284:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 285:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 286:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 287:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 288:/usr/lib/avr/include/avr/wdt.h **** 			);
 289:/usr/lib/avr/include/avr/wdt.h **** 	}
 290:/usr/lib/avr/include/avr/wdt.h **** 	else
 291:/usr/lib/avr/include/avr/wdt.h ****  	{
 292:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 293:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 294:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 295:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 296:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 297:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 298:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 299:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 300:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 301:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 302:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 303:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 304:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 305:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 306:/usr/lib/avr/include/avr/wdt.h **** 			);
 307:/usr/lib/avr/include/avr/wdt.h **** 	}
 308:/usr/lib/avr/include/avr/wdt.h **** }
 309:/usr/lib/avr/include/avr/wdt.h **** 
 310:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 311:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 312:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 313:/usr/lib/avr/include/avr/wdt.h **** {
 314:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 315:/usr/lib/avr/include/avr/wdt.h **** 	{
 316:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 317:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 318:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 319:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 320:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 321:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 322:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 323:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 327:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 328:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 329:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 330:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 331:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 332:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 333:/usr/lib/avr/include/avr/wdt.h **** 				);
 334:/usr/lib/avr/include/avr/wdt.h **** 	}
 335:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 336:/usr/lib/avr/include/avr/wdt.h **** 	{
 337:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 338:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 339:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 340:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 341:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 348:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 352:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 353:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 				);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 357:/usr/lib/avr/include/avr/wdt.h **** 	{
 358:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 359:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 360:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 361:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 362:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 363:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 364:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 365:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 366:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 369:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 370:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 371:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 372:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 373:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 374:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 375:/usr/lib/avr/include/avr/wdt.h **** 				);
 376:/usr/lib/avr/include/avr/wdt.h **** 	}
 377:/usr/lib/avr/include/avr/wdt.h **** 	else
 378:/usr/lib/avr/include/avr/wdt.h **** 	{
 379:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 380:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 381:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 382:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 383:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 384:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 385:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 386:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 387:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 390:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 391:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 392:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 393:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 394:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 395:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 396:/usr/lib/avr/include/avr/wdt.h **** 				);
 397:/usr/lib/avr/include/avr/wdt.h **** 	}
 398:/usr/lib/avr/include/avr/wdt.h **** }
 399:/usr/lib/avr/include/avr/wdt.h **** 
 400:/usr/lib/avr/include/avr/wdt.h **** #else
 401:/usr/lib/avr/include/avr/wdt.h **** 
 402:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 403:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 404:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 405:/usr/lib/avr/include/avr/wdt.h **** {
 406:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 407:/usr/lib/avr/include/avr/wdt.h **** 	{
 408:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 409:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 416:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 417:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 418:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 419:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 420:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 421:/usr/lib/avr/include/avr/wdt.h **** 		);
 422:/usr/lib/avr/include/avr/wdt.h **** 	}
 423:/usr/lib/avr/include/avr/wdt.h **** 	else
 424:/usr/lib/avr/include/avr/wdt.h **** 	{
 425:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 426:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 427:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 428:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 429:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 433:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 434:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 435:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 436:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 437:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 438:/usr/lib/avr/include/avr/wdt.h **** 		);
 439:/usr/lib/avr/include/avr/wdt.h **** 	}
 440:/usr/lib/avr/include/avr/wdt.h **** }
 441:/usr/lib/avr/include/avr/wdt.h **** 
 442:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 443:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 444:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 445:/usr/lib/avr/include/avr/wdt.h **** {
 446:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 447:/usr/lib/avr/include/avr/wdt.h **** 	{
 448:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 449:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2913               	.LM346:
 2914               	/* #APP */
 2915               	 ;  449 "/usr/lib/avr/include/avr/wdt.h" 1
 2916 005a 0FB6      		in __tmp_reg__,__SREG__
 2917 005c F894      		cli
 2918 005e A895      		wdr
 2919 0060 81B5      		in  r24,33
 2920 0062 8861      		ori r24,24
 2921 0064 81BD      		out 33,r24
 2922 0066 11BC      		out 33,__zero_reg__
 2923 0068 0FBE      		out __SREG__,__tmp_reg__
 2924               		
 2925               	 ;  0 "" 2
 2926               	/* #NOAPP */
 2927               	.LBE482:
 2928               	.LBE481:
 2929               	.LBB483:
 2930               	.LBB484:
 2932               	.Ltext38:
 163:/usr/lib/avr/include/util/delay.h **** 
 2934               	.LM347:
 2935 006a 2FE9      		ldi r18,lo8(99999)
 2936 006c 86E8      		ldi r24,hi8(99999)
 2937 006e 91E0      		ldi r25,hlo8(99999)
 2938 0070 2150      	1:	subi r18,1
 2939 0072 8040      		sbci r24,0
 2940 0074 9040      		sbci r25,0
 2941 0076 01F4      		brne 1b
 2942 0078 00C0      		rjmp .
 2943 007a 0000      		nop
 2944               	.LBE484:
 2945               	.LBE483:
 2947               	.Ltext39:
 690:main.c        **** 
 691:main.c        ****   wdt_disable();
 692:main.c        **** 
 693:main.c        ****   _delay_ms(500);
 694:main.c        **** 
 695:main.c        ****   PORTD |= (1 << LED_RED) | (1 << LED_GREEN);
 2949               	.LM348:
 2950 007c 82B3      		in r24,0x12
 2951 007e 8066      		ori r24,lo8(96)
 2952 0080 82BB      		out 0x12,r24
 696:main.c        **** 
 697:main.c        ****   TIMSK = 0;
 2954               	.LM349:
 2955 0082 17BE      		out 0x37,__zero_reg__
 698:main.c        ****   Timer0Init();
 2957               	.LM350:
 2958 0084 0E94 0000 		call Timer0Init
 699:main.c        ****   Timer1Init();
 2960               	.LM351:
 2961 0088 0E94 0000 		call Timer1Init
 700:main.c        ****   TWIinit();
 2963               	.LM352:
 2964 008c 0E94 0000 		call TWIinit
 701:main.c        ****   lcd_init();
 2966               	.LM353:
 2967 0090 0E94 0000 		call lcd_init
 702:main.c        ****   lcd_clrscr();
 2969               	.LM354:
 2970 0094 0E94 0000 		call lcd_clrscr
 703:main.c        ****   adcInit();
 2972               	.LM355:
 2973 0098 0E94 0000 		call adcInit
 2974               	.LBB485:
 2975               	.LBB486:
 2977               	.Ltext40:
 163:/usr/lib/avr/include/util/delay.h **** 
 2979               	.LM356:
 2980 009c AFE4      		ldi r26,lo8(-15537)
 2981 009e B3EC      		ldi r27,hi8(-15537)
 2982 00a0 1197      	1:	sbiw r26,1
 2983 00a2 01F4      		brne 1b
 2984 00a4 00C0      		rjmp .
 2985 00a6 0000      		nop
 2986               	.LBE486:
 2987               	.LBE485:
 2989               	.Ltext41:
 704:main.c        **** 
 705:main.c        ****   _delay_ms(200);
 706:main.c        **** 
 707:main.c        ****   PORTD &= ~((1 << LED_RED) | (1 << LED_GREEN));
 2991               	.LM357:
 2992 00a8 82B3      		in r24,0x12
 2993 00aa 8F79      		andi r24,lo8(-97)
 2994 00ac 82BB      		out 0x12,r24
 708:main.c        **** 
 709:main.c        ****   strcpy_P(buffer, string_intro_row1);
 2996               	.LM358:
 2997 00ae 60E0      		ldi r22,lo8(string_intro_row1.2453)
 2998 00b0 70E0      		ldi r23,hi8(string_intro_row1.2453)
 2999 00b2 8E01      		movw r16,r28
 3000 00b4 0F5F      		subi r16,-1
 3001 00b6 1F4F      		sbci r17,-1
 3002 00b8 C801      		movw r24,r16
 3003 00ba 0E94 0000 		call strcpy_P
 710:main.c        ****   lcd_puts(buffer);
 3005               	.LM359:
 3006 00be C801      		movw r24,r16
 3007 00c0 0E94 0000 		call lcd_puts
 711:main.c        ****   lcd_goto(0x40);
 3009               	.LM360:
 3010 00c4 80E4      		ldi r24,lo8(64)
 3011 00c6 0E94 0000 		call lcd_goto
 712:main.c        ****   strcpy_P(buffer, string_intro_row2);
 3013               	.LM361:
 3014 00ca 60E0      		ldi r22,lo8(string_intro_row2.2454)
 3015 00cc 70E0      		ldi r23,hi8(string_intro_row2.2454)
 3016 00ce C801      		movw r24,r16
 3017 00d0 0E94 0000 		call strcpy_P
 713:main.c        ****   lcd_puts(buffer);
 3019               	.LM362:
 3020 00d4 C801      		movw r24,r16
 3021 00d6 0E94 0000 		call lcd_puts
 714:main.c        **** 
 715:main.c        ****   rot_flag = 0x01;
 3023               	.LM363:
 3024 00da 81E0      		ldi r24,lo8(1)
 3025 00dc 8093 0000 		sts rot_flag,r24
 716:main.c        ****   mode_flag = 0x01;
 3027               	.LM364:
 3028 00e0 8093 0000 		sts mode_flag,r24
 717:main.c        ****   band_flag = 0x02;
 3030               	.LM365:
 3031 00e4 82E0      		ldi r24,lo8(2)
 3032 00e6 8093 0000 		sts band_flag,r24
 718:main.c        ****   timer_flag = 0x00;
 3034               	.LM366:
 3035 00ea 1092 0000 		sts timer_flag,__zero_reg__
 719:main.c        **** 
 720:main.c        ****   band = 10;
 3037               	.LM367:
 3038 00ee 8AE0      		ldi r24,lo8(10)
 3039 00f0 8093 0000 		sts band,r24
 721:main.c        ****   freq = 7010;
 3041               	.LM368:
 3042 00f4 80E0      		ldi r24,0
 3043 00f6 90E1      		ldi r25,lo8(16)
 3044 00f8 ABED      		ldi r26,lo8(-37)
 3045 00fa B5E4      		ldi r27,lo8(69)
 3046 00fc 8093 0000 		sts freq,r24
 3047 0100 9093 0000 		sts freq+1,r25
 3048 0104 A093 0000 		sts freq+2,r26
 3049 0108 B093 0000 		sts freq+3,r27
 722:main.c        ****   step_timer = 255;
 3051               	.LM369:
 3052 010c 8FEF      		ldi r24,lo8(-1)
 3053 010e 90E0      		ldi r25,0
 3054 0110 9093 0000 		sts step_timer+1,r25
 3055 0114 8093 0000 		sts step_timer,r24
 723:main.c        ****   steps = 0;
 724:main.c        ****   last_dir = 0x00;
 725:main.c        ****   mode = 0x00;
 3057               	.LM370:
 3058 0118 1092 0000 		sts mode,__zero_reg__
 726:main.c        ****   tx = 0x0000;
 3060               	.LM371:
 3061 011c 1092 0000 		sts tx+1,__zero_reg__
 3062 0120 1092 0000 		sts tx,__zero_reg__
 727:main.c        ****   rx_att = 0x00;
 3064               	.LM372:
 3065 0124 1092 0000 		sts rx_att,__zero_reg__
 728:main.c        ****   tx_att = 0x00;
 3067               	.LM373:
 3068 0128 1092 0000 		sts tx_att,__zero_reg__
 729:main.c        ****   rffe_rx_att = false;
 3070               	.LM374:
 3071 012c 1092 0000 		sts rffe_rx_att,__zero_reg__
 730:main.c        **** 
 731:main.c        ****   err = updateVolumeSquelch(vol, squelch);
 3073               	.LM375:
 3074 0130 60E0      		ldi r22,0
 3075 0132 88E1      		ldi r24,lo8(24)
 3076 0134 0E94 0000 		call updateVolumeSquelch
 3077               	.LBB487:
 3078               	.LBB488:
 3080               	.Ltext42:
 163:/usr/lib/avr/include/util/delay.h **** 
 3082               	.LM376:
 3083 0138 BFE7      		ldi r27,lo8(399999)
 3084 013a 2AE1      		ldi r18,hi8(399999)
 3085 013c 86E0      		ldi r24,hlo8(399999)
 3086 013e B150      	1:	subi r27,1
 3087 0140 2040      		sbci r18,0
 3088 0142 8040      		sbci r24,0
 3089 0144 01F4      		brne 1b
 3090 0146 00C0      		rjmp .
 3091 0148 0000      		nop
 3092               	.LBE488:
 3093               	.LBE487:
 3095               	.Ltext43:
 732:main.c        ****   
 733:main.c        ****   _delay_ms(2000);
 734:main.c        **** 
 735:main.c        ****   lcd_clrscr();
 3097               	.LM377:
 3098 014a 0E94 0000 		call lcd_clrscr
 736:main.c        ****   
 737:main.c        ****   sei();
 3100               	.LM378:
 3101               	/* #APP */
 3102               	 ;  737 "main.c" 1
 3103 014e 7894      		sei
 3104               	 ;  0 "" 2
 723:main.c        ****   last_dir = 0x00;
 3106               	.LM379:
 3107               	/* #NOAPP */
 3108 0150 C12C      		mov r12,__zero_reg__
 3109 0152 D12C      		mov r13,__zero_reg__
 658:main.c        ****   uint16_t steps;
 3111               	.LM380:
 3112 0154 38E1      		ldi r19,lo8(24)
 3113 0156 A32E      		mov r10,r19
 657:main.c        ****   uint8_t vol = 0x18;
 3115               	.LM381:
 3116 0158 9FEF      		ldi r25,lo8(-1)
 3117 015a 9EAF      		std Y+62,r25
 656:main.c        ****   uint8_t tx_last = 255;
 3119               	.LM382:
 3120 015c B12C      		mov r11,__zero_reg__
 724:main.c        ****   mode = 0x00;
 3122               	.LM383:
 3123 015e 1FAE      		std Y+63,__zero_reg__
 654:main.c        ****   uint8_t last_dir;
 3125               	.LM384:
 3126 0160 E12C      		mov r14,__zero_reg__
 3127 0162 F12C      		mov r15,__zero_reg__
 738:main.c        **** 
 739:main.c        ****   while (1) {
 740:main.c        ****     if (timer_flag) {
 741:main.c        **** 
 742:main.c        **** #ifdef CLARPOT
 743:main.c        ****       clarval = readClar();
 744:main.c        **** #endif
 745:main.c        **** #ifndef CLARPOT
 746:main.c        ****       clarval = 0;
 747:main.c        **** #endif
 748:main.c        **** 
 749:main.c        ****       if ((clarval < clarval_last - 10) || (clarval > clarval_last + 10)) {
 750:main.c        **** 	clar = (int8_t)((clarval - 512) >> 2);
 751:main.c        **** 	err = updateFreq(0);
 752:main.c        **** 	if (err) {
 753:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 754:main.c        **** 	  lcd_goto(0x40);
 755:main.c        **** 	  lcd_puts(buffer);	
 756:main.c        **** 	}
 757:main.c        **** 	else {
 758:main.c        **** 	  lcd_freq();
 759:main.c        **** 	}
 760:main.c        **** 	clarval_last = clarval;
 761:main.c        ****       }
 762:main.c        **** 
 763:main.c        ****       if (vol_timer < 255)
 764:main.c        **** 	vol_timer ++;
 765:main.c        **** 
 766:main.c        ****       // Band button
 767:main.c        **** 
 768:main.c        ****       if (band_timer < 9) { // Recently pressed ?
 769:main.c        **** 	band_timer ++;
 770:main.c        **** 	if ((band_timer < 9) && (PINF & (1 << BAND_BUTTON))) {
 771:main.c        **** 	  band_flag = 0x01; // short press
 772:main.c        **** 	  band_timer = 255;
 773:main.c        **** 	}
 774:main.c        **** 	if ((band_timer == 9) && (!(PINF & (1 << BAND_BUTTON)))) 
 775:main.c        **** 	  band_flag = 0x02; // long press
 776:main.c        ****       }
 777:main.c        ****       else if (!(PINF & (1 << BAND_BUTTON))) {  // New press
 778:main.c        **** 	band_timer = 0;
 779:main.c        ****       }
 780:main.c        **** 
 781:main.c        ****       // Mode button
 782:main.c        **** 
 783:main.c        ****       if (!(PINF & (1 << MODE_BUTTON))) {
 784:main.c        **** 	mode_flag = 0x01;
 785:main.c        ****       }
 786:main.c        ****       
 787:main.c        ****       // Update frequency if necessary:
 788:main.c        ****       if (freq != freq_last) {
 789:main.c        **** 	lcd_freq();
 790:main.c        **** 	err = updateFreq(1);
 791:main.c        **** 	if (err) {
 792:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 793:main.c        **** 	  lcd_goto(0x40);
 794:main.c        **** 	  lcd_puts(buffer);	
 795:main.c        **** 	}
 796:main.c        **** 	freq_last = freq;
 797:main.c        ****       }
 798:main.c        **** 
 799:main.c        ****       // Read RSSI and status:
 800:main.c        ****       err = TWI_read_byte(fpga_addr, &data);
 801:main.c        ****       if (!err) {
 802:main.c        **** 	if ((data & 0x80) && (tx_last != 1)) { // Shift to TX ?
 803:main.c        **** 	  tx = 0x0001;
 804:main.c        **** 	  updateRFFE();
 805:main.c        **** 	  PORTD |= (1 << LED_RED);
 806:main.c        **** 	  PORTD &= ~(1 << LED_GREEN);
 807:main.c        **** 	  tx_last = 1;
 808:main.c        **** 	}
 809:main.c        **** 	else if (!(data & 0x80) && (tx_last != 0)) { // Shift to RX ?
 810:main.c        **** 	  tx = 0x0000;
 811:main.c        **** 	  updateRFFE();
 812:main.c        **** 	  PORTD |= (1 << LED_GREEN);
 813:main.c        **** 	  PORTD &= ~(1 << LED_RED);
 814:main.c        **** 	  tx_last = 0;
 815:main.c        **** 	}
 816:main.c        ****       }
 817:main.c        ****       else { // error
 818:main.c        **** 	PORTD &= ~((1 << LED_RED)|(1 << LED_GREEN));
 819:main.c        ****       }
 820:main.c        **** 
 821:main.c        ****       rssi = (0x3f & data); 
 822:main.c        ****       if (rssi_max < rssi) 
 823:main.c        **** 	rssi_max = rssi;
 824:main.c        ****       rssi_count ++;
 825:main.c        ****       if ((!rffe_rx_att && rssi_count > 2) || (rffe_rx_att && rssi_count > 2)) {
 826:main.c        **** 	rssi_count = 0;
 827:main.c        **** 	if (rssi_max < 4)
 828:main.c        **** 	  rssi = 0;
 829:main.c        **** 	else 
 830:main.c        **** 	  rssi = rssi_max - 4;
 831:main.c        **** 	rssi_max = 0;
 832:main.c        **** 
 833:main.c        **** 	if (vol_timer < 10); // Don't print if vol info
 834:main.c        **** 	else if (rffe_rx_att && (rssi>9)) {
 835:main.c        **** 	  sprintf(buffer,"S---9+++   ");
 836:main.c        **** 	  lcd_goto(0x40);
 837:main.c        **** 	  lcd_puts(buffer);
 838:main.c        **** 	}
 839:main.c        **** 	else if (rffe_rx_att && (rssi < 10)) {
 840:main.c        **** 	  rffe_rx_att = false;
 841:main.c        **** 	  err = updateRFFE();
 842:main.c        **** 	}
 843:main.c        **** 	else if (rssi < 2) { 
 844:main.c        **** 	  sprintf(buffer,"S%d         ",rssi);
 845:main.c        **** 	  lcd_goto(0x40);
 846:main.c        **** 	  lcd_puts(buffer);
 847:main.c        **** 	}
 848:main.c        **** 	else if (rssi < 4) {
 849:main.c        **** 	  sprintf(buffer,"S-%d        ",rssi);
 850:main.c        **** 	  lcd_goto(0x40);
 851:main.c        **** 	  lcd_puts(buffer);
 852:main.c        ****  	}
 853:main.c        **** 	else if (rssi < 6) {
 854:main.c        **** 	  sprintf(buffer,"S--%d       ",rssi);
 855:main.c        **** 	  lcd_goto(0x40);
 856:main.c        **** 	  lcd_puts(buffer);
 857:main.c        **** 	}
 858:main.c        **** 	else if (rssi < 8) {
 859:main.c        **** 	  sprintf(buffer,"S---%d      ",rssi);
 860:main.c        **** 	  lcd_goto(0x40);
 861:main.c        **** 	  lcd_puts(buffer);
 862:main.c        **** 	}
 863:main.c        **** 	else if (rssi < 10) {
 864:main.c        **** 	  sprintf(buffer,"S----%d     ",rssi);
 865:main.c        **** 	  lcd_goto(0x40);
 866:main.c        **** 	  lcd_puts(buffer);
 867:main.c        **** 	}
 868:main.c        **** 	else if (rssi < 12) {
 869:main.c        **** 	  sprintf(buffer,"S----9+    ");
 870:main.c        **** 	  lcd_goto(0x40);
 871:main.c        **** 	  lcd_puts(buffer);
 872:main.c        **** 	}
 873:main.c        **** 	else if (rssi < 13 ){
 874:main.c        **** 	  sprintf(buffer,"S----9++   ");
 875:main.c        **** 	  lcd_goto(0x40);
 876:main.c        **** 	  lcd_puts(buffer);
 877:main.c        **** 	}
 878:main.c        **** 	else {
 879:main.c        **** 	  rffe_rx_att = true;
 880:main.c        **** 	  err = updateRFFE();
 881:main.c        **** 	}
 882:main.c        **** 	rssi = 0;
 883:main.c        ****       }
 884:main.c        ****       timer_flag = 0;
 885:main.c        ****     }
 886:main.c        ****     else if (mode_flag) {
 887:main.c        ****       switch (mode) {
 888:main.c        ****       case LSB:
 889:main.c        **** 	mode = USB;
 890:main.c        **** 	if (!updateSettings()) { 
 891:main.c        **** 	  lcd_goto(0x00);
 892:main.c        **** 	  sprintf(buffer,"USB ");
 893:main.c        **** 	  lcd_puts(buffer);
 894:main.c        **** 	}
 895:main.c        **** 	break;
 896:main.c        ****       case USB:
 897:main.c        **** 	mode = CW;
 898:main.c        **** 	if(!updateSettings()) {
 899:main.c        **** 	  lcd_goto(0x00);
 900:main.c        **** 	  sprintf(buffer,"CW  ");
 901:main.c        **** 	  lcd_puts(buffer);
 902:main.c        **** 	}
 903:main.c        **** 	break;
 904:main.c        ****       case CW:
 905:main.c        **** 	mode = CWN;
 906:main.c        **** 	if(!updateSettings()) {
 907:main.c        **** 	  lcd_goto(0x00);
 908:main.c        **** 	  sprintf(buffer,"CWN ");
 909:main.c        **** 	  lcd_puts(buffer);
 910:main.c        **** 	}
 911:main.c        **** 	break;
 912:main.c        ****       case CWN:
 913:main.c        **** 	if (band < 200) {
 914:main.c        **** 	  mode = AM;
 915:main.c        **** 	  if(!updateSettings()) {
 916:main.c        **** 	    lcd_goto(0x00);
 917:main.c        **** 	    sprintf(buffer,"AM  ");
 918:main.c        **** 	    lcd_puts(buffer);
 919:main.c        **** 	  }
 920:main.c        **** 	}
 921:main.c        **** 	else {
 922:main.c        **** 	  mode = FM;
 923:main.c        **** 	  if(!updateSettings()) {
 924:main.c        **** 	    lcd_goto(0x00);
 925:main.c        **** 	    sprintf(buffer,"FM  ");
 926:main.c        **** 	    lcd_puts(buffer);
 927:main.c        **** 	  }
 928:main.c        **** 	}	  
 929:main.c        **** 	break;
 930:main.c        ****       case AM:
 931:main.c        ****       case FM:
 932:main.c        ****       default:
 933:main.c        **** 	mode = LSB;
 934:main.c        **** 	if(!updateSettings()) { 
 935:main.c        **** 	  lcd_goto(0x00);
 936:main.c        **** 	  sprintf(buffer,"LSB ");
 937:main.c        **** 	  lcd_puts(buffer);
 938:main.c        **** 	}
 939:main.c        **** 	break;
 940:main.c        ****       }
 941:main.c        ****       _delay_ms(250);
 942:main.c        ****       err = updateFreq(1);  // To shift +/-
 943:main.c        ****       mode_flag = 0x00;
 944:main.c        ****     }
 945:main.c        **** 
 946:main.c        ****     if (band_flag) {
 947:main.c        ****       if (band_flag == 0x02) { // long press
 948:main.c        **** #ifdef TWOMETER_TRANSV
 949:main.c        **** 	if (band == 200) {
 950:main.c        **** 	  band = 201;
 951:main.c        **** 	  freq_offset = 1152;
 952:main.c        **** 	  freq = 144200;
 953:main.c        **** 	  tx_att = 0x01;
 954:main.c        **** 	  rx_att = 0x00;
 955:main.c        **** 	  updateSettings();
 956:main.c        **** 	}
 957:main.c        **** 	else if (band == 201) {
 958:main.c        **** 	  band = 202;
 959:main.c        **** 	  freq_offset = 5616;
 960:main.c        **** 	  freq = 144200;
 961:main.c        **** 	  tx_att = 0x01;
 962:main.c        **** 	  rx_att = 0x00;
 963:main.c        **** 	  updateSettings();
 964:main.c        **** 	}
 965:main.c        **** 	else {
 966:main.c        **** 	  band = 200;
 967:main.c        **** 	  freq_offset = 0;
 968:main.c        **** 	  freq = 144300;
 969:main.c        **** 	  tx_att = 0x00;
 970:main.c        **** 	  rx_att = 0x00;
 971:main.c        **** 	  updateSettings();
 972:main.c        **** 	  /*
 973:main.c        **** 	  band = 160;
 974:main.c        **** 	  freq_offset = 0;
 975:main.c        **** 	  freq = 1810;
 976:main.c        **** 	  tx_att = 0x00;
 977:main.c        **** 	  */
 978:main.c        **** 	}
 979:main.c        **** #endif
 980:main.c        ****       }
 981:main.c        ****       else {
 982:main.c        **** #ifdef HF_HAM
 983:main.c        **** 	if (freq<3500)
 984:main.c        **** 	  freq = 3510;
 3129               	.LM385:
 3130 0164 412C      		mov r4,__zero_reg__
 3131 0166 40E6      		ldi r20,lo8(96)
 3132 0168 542E      		mov r5,r20
 3133 016a 4BE5      		ldi r20,lo8(91)
 3134 016c 642E      		mov r6,r20
 3135 016e 45E4      		ldi r20,lo8(69)
 3136 0170 742E      		mov r7,r20
 3137               	.L160:
 740:main.c        **** 
 3139               	.LM386:
 3140 0172 8091 0000 		lds r24,timer_flag
 3141 0176 8823      		tst r24
 3142 0178 01F4      		brne .+2
 3143 017a 00C0      		rjmp .L161
 3144               	.LBB489:
 3145               	.LBB490:
 399:main.c        **** }
 3147               	.LM387:
 3148 017c 84B0      		in r8,0x4
 3149 017e 95B0      		in r9,0x4+1
 3150               	.LBE490:
 3151               	.LBE489:
 749:main.c        **** 	clar = (int8_t)((clarval - 512) >> 2);
 3153               	.LM388:
 3154 0180 C101      		movw r24,r2
 3155 0182 0A97      		sbiw r24,10
 3156 0184 8816      		cp r8,r24
 3157 0186 9906      		cpc r9,r25
 3158 0188 04F0      		brlt .L162
 749:main.c        **** 	clar = (int8_t)((clarval - 512) >> 2);
 3160               	.LM389:
 3161 018a 4496      		adiw r24,20
 3162 018c 8815      		cp r24,r8
 3163 018e 9905      		cpc r25,r9
 3164 0190 04F4      		brge .L163
 3165               	.L162:
 750:main.c        **** 	err = updateFreq(0);
 3167               	.LM390:
 3168 0192 C401      		movw r24,r8
 3169 0194 9250      		subi r25,2
 3170 0196 9595      		asr r25
 3171 0198 8795      		ror r24
 3172 019a 9595      		asr r25
 3173 019c 8795      		ror r24
 3174 019e 8093 0000 		sts clar,r24
 751:main.c        **** 	if (err) {
 3176               	.LM391:
 3177 01a2 80E0      		ldi r24,0
 3178 01a4 0E94 0000 		call updateFreq
 752:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 3180               	.LM392:
 3181 01a8 8823      		tst r24
 3182 01aa 01F0      		breq .L164
 753:main.c        **** 	  lcd_goto(0x40);
 3184               	.LM393:
 3185 01ac 1F92      		push __zero_reg__
 3186 01ae 8F93      		push r24
 3187 01b0 80E0      		ldi r24,lo8(.LC3)
 3188 01b2 90E0      		ldi r25,hi8(.LC3)
 3189 01b4 9F93      		push r25
 3190 01b6 8F93      		push r24
 3191 01b8 1F93      		push r17
 3192 01ba 0F93      		push r16
 3193 01bc 0E94 0000 		call sprintf
 754:main.c        **** 	  lcd_puts(buffer);	
 3195               	.LM394:
 3196 01c0 80E4      		ldi r24,lo8(64)
 3197 01c2 0E94 0000 		call lcd_goto
 755:main.c        **** 	}
 3199               	.LM395:
 3200 01c6 C801      		movw r24,r16
 3201 01c8 0E94 0000 		call lcd_puts
 3202 01cc 0F90      		pop __tmp_reg__
 3203 01ce 0F90      		pop __tmp_reg__
 3204 01d0 0F90      		pop __tmp_reg__
 3205 01d2 0F90      		pop __tmp_reg__
 3206 01d4 0F90      		pop __tmp_reg__
 3207 01d6 0F90      		pop __tmp_reg__
 3208 01d8 00C0      		rjmp .L336
 3209               	.L164:
 758:main.c        **** 	}
 3211               	.LM396:
 3212 01da 0E94 0000 		call lcd_freq
 3213               	.L336:
 743:main.c        **** #endif
 3215               	.LM397:
 3216 01de 1401      		movw r2,r8
 3217               	.L163:
 763:main.c        **** 	vol_timer ++;
 3219               	.LM398:
 3220 01e0 8091 0000 		lds r24,vol_timer
 3221 01e4 8F3F      		cpi r24,lo8(-1)
 3222 01e6 01F0      		breq .L165
 764:main.c        **** 
 3224               	.LM399:
 3225 01e8 8091 0000 		lds r24,vol_timer
 3226 01ec 8F5F      		subi r24,lo8(-(1))
 3227 01ee 8093 0000 		sts vol_timer,r24
 3228               	.L165:
 768:main.c        **** 	band_timer ++;
 3230               	.LM400:
 3231 01f2 8091 0000 		lds r24,band_timer
 3232 01f6 8930      		cpi r24,lo8(9)
 3233 01f8 00F4      		brsh .L166
 769:main.c        **** 	if ((band_timer < 9) && (PINF & (1 << BAND_BUTTON))) {
 3235               	.LM401:
 3236 01fa 8091 0000 		lds r24,band_timer
 3237 01fe 8F5F      		subi r24,lo8(-(1))
 3238 0200 8093 0000 		sts band_timer,r24
 770:main.c        **** 	  band_flag = 0x01; // short press
 3240               	.LM402:
 3241 0204 8091 0000 		lds r24,band_timer
 3242 0208 8930      		cpi r24,lo8(9)
 3243 020a 00F4      		brsh .L167
 770:main.c        **** 	  band_flag = 0x01; // short press
 3245               	.LM403:
 3246 020c 009B      		sbis 0,0
 3247 020e 00C0      		rjmp .L167
 771:main.c        **** 	  band_timer = 255;
 3249               	.LM404:
 3250 0210 81E0      		ldi r24,lo8(1)
 3251 0212 8093 0000 		sts band_flag,r24
 772:main.c        **** 	}
 3253               	.LM405:
 3254 0216 8FEF      		ldi r24,lo8(-1)
 3255 0218 8093 0000 		sts band_timer,r24
 3256               	.L167:
 774:main.c        **** 	  band_flag = 0x02; // long press
 3258               	.LM406:
 3259 021c 8091 0000 		lds r24,band_timer
 3260 0220 8930      		cpi r24,lo8(9)
 3261 0222 01F4      		brne .L169
 774:main.c        **** 	  band_flag = 0x02; // long press
 3263               	.LM407:
 3264 0224 0099      		sbic 0,0
 3265 0226 00C0      		rjmp .L169
 775:main.c        ****       }
 3267               	.LM408:
 3268 0228 82E0      		ldi r24,lo8(2)
 3269 022a 8093 0000 		sts band_flag,r24
 3270 022e 00C0      		rjmp .L169
 3271               	.L166:
 777:main.c        **** 	band_timer = 0;
 3273               	.LM409:
 3274 0230 009B      		sbis 0,0
 778:main.c        ****       }
 3276               	.LM410:
 3277 0232 1092 0000 		sts band_timer,__zero_reg__
 3278               	.L169:
 783:main.c        **** 	mode_flag = 0x01;
 3280               	.LM411:
 3281 0236 0199      		sbic 0,1
 3282 0238 00C0      		rjmp .L171
 784:main.c        ****       }
 3284               	.LM412:
 3285 023a 81E0      		ldi r24,lo8(1)
 3286 023c 8093 0000 		sts mode_flag,r24
 3287               	.L171:
 788:main.c        **** 	lcd_freq();
 3289               	.LM413:
 3290 0240 6091 0000 		lds r22,freq
 3291 0244 7091 0000 		lds r23,freq+1
 3292 0248 8091 0000 		lds r24,freq+2
 3293 024c 9091 0000 		lds r25,freq+3
 3294 0250 2496      		adiw r28,64-60
 3295 0252 2CAD      		ldd r18,Y+60
 3296 0254 3DAD      		ldd r19,Y+61
 3297 0256 4EAD      		ldd r20,Y+62
 3298 0258 5FAD      		ldd r21,Y+63
 3299 025a 2497      		sbiw r28,64-60
 3300 025c 0E94 0000 		call __nesf2
 3301 0260 8823      		tst r24
 3302 0262 01F0      		breq .L172
 789:main.c        **** 	err = updateFreq(1);
 3304               	.LM414:
 3305 0264 0E94 0000 		call lcd_freq
 790:main.c        **** 	if (err) {
 3307               	.LM415:
 3308 0268 81E0      		ldi r24,lo8(1)
 3309 026a 0E94 0000 		call updateFreq
 791:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 3311               	.LM416:
 3312 026e 8823      		tst r24
 3313 0270 01F0      		breq .L174
 792:main.c        **** 	  lcd_goto(0x40);
 3315               	.LM417:
 3316 0272 1F92      		push __zero_reg__
 3317 0274 8F93      		push r24
 3318 0276 80E0      		ldi r24,lo8(.LC3)
 3319 0278 90E0      		ldi r25,hi8(.LC3)
 3320 027a 9F93      		push r25
 3321 027c 8F93      		push r24
 3322 027e 1F93      		push r17
 3323 0280 0F93      		push r16
 3324 0282 0E94 0000 		call sprintf
 793:main.c        **** 	  lcd_puts(buffer);	
 3326               	.LM418:
 3327 0286 80E4      		ldi r24,lo8(64)
 3328 0288 0E94 0000 		call lcd_goto
 794:main.c        **** 	}
 3330               	.LM419:
 3331 028c C801      		movw r24,r16
 3332 028e 0E94 0000 		call lcd_puts
 3333 0292 0F90      		pop __tmp_reg__
 3334 0294 0F90      		pop __tmp_reg__
 3335 0296 0F90      		pop __tmp_reg__
 3336 0298 0F90      		pop __tmp_reg__
 3337 029a 0F90      		pop __tmp_reg__
 3338 029c 0F90      		pop __tmp_reg__
 3339               	.L174:
 796:main.c        ****       }
 3341               	.LM420:
 3342 029e 8091 0000 		lds r24,freq
 3343 02a2 9091 0000 		lds r25,freq+1
 3344 02a6 A091 0000 		lds r26,freq+2
 3345 02aa B091 0000 		lds r27,freq+3
 3346 02ae 2496      		adiw r28,64-60
 3347 02b0 8CAF      		std Y+60,r24
 3348 02b2 9DAF      		std Y+61,r25
 3349 02b4 AEAF      		std Y+62,r26
 3350 02b6 BFAF      		std Y+63,r27
 3351 02b8 2497      		sbiw r28,64-60
 3352               	.L172:
 800:main.c        ****       if (!err) {
 3354               	.LM421:
 3355 02ba BE01      		movw r22,r28
 3356 02bc 635C      		subi r22,-61
 3357 02be 7F4F      		sbci r23,-1
 3358 02c0 83E2      		ldi r24,lo8(35)
 3359 02c2 0E94 0000 		call TWI_read_byte
 801:main.c        **** 	if ((data & 0x80) && (tx_last != 1)) { // Shift to TX ?
 3361               	.LM422:
 3362 02c6 8111      		cpse r24,__zero_reg__
 3363 02c8 00C0      		rjmp .L175
 802:main.c        **** 	  tx = 0x0001;
 3365               	.LM423:
 3366 02ca 8DAD      		ldd r24,Y+61
 3367 02cc 87FF      		sbrs r24,7
 3368 02ce 00C0      		rjmp .L176
 802:main.c        **** 	  tx = 0x0001;
 3370               	.LM424:
 3371 02d0 9EAD      		ldd r25,Y+62
 3372 02d2 9130      		cpi r25,lo8(1)
 3373 02d4 01F0      		breq .L177
 803:main.c        **** 	  updateRFFE();
 3375               	.LM425:
 3376 02d6 81E0      		ldi r24,lo8(1)
 3377 02d8 90E0      		ldi r25,0
 3378 02da 9093 0000 		sts tx+1,r25
 3379 02de 8093 0000 		sts tx,r24
 804:main.c        **** 	  PORTD |= (1 << LED_RED);
 3381               	.LM426:
 3382 02e2 0E94 0000 		call updateRFFE
 805:main.c        **** 	  PORTD &= ~(1 << LED_GREEN);
 3384               	.LM427:
 3385 02e6 969A      		sbi 0x12,6
 806:main.c        **** 	  tx_last = 1;
 3387               	.LM428:
 3388 02e8 9598      		cbi 0x12,5
 807:main.c        **** 	}
 3390               	.LM429:
 3391 02ea A1E0      		ldi r26,lo8(1)
 3392 02ec AEAF      		std Y+62,r26
 3393 02ee 00C0      		rjmp .L177
 3394               	.L176:
 809:main.c        **** 	  tx = 0x0000;
 3396               	.LM430:
 3397 02f0 BEAD      		ldd r27,Y+62
 3398 02f2 BB23      		tst r27
 3399 02f4 01F0      		breq .L177
 810:main.c        **** 	  updateRFFE();
 3401               	.LM431:
 3402 02f6 1092 0000 		sts tx+1,__zero_reg__
 3403 02fa 1092 0000 		sts tx,__zero_reg__
 811:main.c        **** 	  PORTD |= (1 << LED_GREEN);
 3405               	.LM432:
 3406 02fe 0E94 0000 		call updateRFFE
 812:main.c        **** 	  PORTD &= ~(1 << LED_RED);
 3408               	.LM433:
 3409 0302 959A      		sbi 0x12,5
 813:main.c        **** 	  tx_last = 0;
 3411               	.LM434:
 3412 0304 9698      		cbi 0x12,6
 814:main.c        **** 	}
 3414               	.LM435:
 3415 0306 1EAE      		std Y+62,__zero_reg__
 3416 0308 00C0      		rjmp .L177
 3417               	.L175:
 818:main.c        ****       }
 3419               	.LM436:
 3420 030a 82B3      		in r24,0x12
 3421 030c 8F79      		andi r24,lo8(-97)
 3422 030e 82BB      		out 0x12,r24
 3423               	.L177:
 821:main.c        ****       if (rssi_max < rssi) 
 3425               	.LM437:
 3426 0310 8DAD      		ldd r24,Y+61
 3427 0312 8F73      		andi r24,lo8(63)
 3428 0314 F816      		cp r15,r24
 3429 0316 00F4      		brsh .L178
 3430 0318 F82E      		mov r15,r24
 3431               	.L178:
 824:main.c        ****       if ((!rffe_rx_att && rssi_count > 2) || (rffe_rx_att && rssi_count > 2)) {
 3433               	.LM438:
 3434 031a E394      		inc r14
 825:main.c        **** 	rssi_count = 0;
 3436               	.LM439:
 3437 031c 8091 0000 		lds r24,rffe_rx_att
 3438 0320 8111      		cpse r24,__zero_reg__
 3439 0322 00C0      		rjmp .L179
 825:main.c        **** 	rssi_count = 0;
 3441               	.LM440:
 3442 0324 22E0      		ldi r18,lo8(2)
 3443 0326 2E15      		cp r18,r14
 3444 0328 00F0      		brlo .L180
 3445               	.L179:
 825:main.c        **** 	rssi_count = 0;
 3447               	.LM441:
 3448 032a 8091 0000 		lds r24,rffe_rx_att
 3449 032e 8823      		tst r24
 3450 0330 01F4      		brne .+2
 3451 0332 00C0      		rjmp .L181
 825:main.c        **** 	rssi_count = 0;
 3453               	.LM442:
 3454 0334 82E0      		ldi r24,lo8(2)
 3455 0336 8E15      		cp r24,r14
 3456 0338 00F0      		brlo .+2
 3457 033a 00C0      		rjmp .L181
 3458               	.L180:
 827:main.c        **** 	  rssi = 0;
 3460               	.LM443:
 3461 033c 93E0      		ldi r25,lo8(3)
 3462 033e 9F15      		cp r25,r15
 3463 0340 00F4      		brsh .L265
 830:main.c        **** 	rssi_max = 0;
 3465               	.LM444:
 3466 0342 8CEF      		ldi r24,lo8(-4)
 3467 0344 8F0D      		add r24,r15
 3468 0346 00C0      		rjmp .L182
 3469               	.L265:
 828:main.c        **** 	else 
 3471               	.LM445:
 3472 0348 80E0      		ldi r24,0
 3473               	.L182:
 833:main.c        **** 	else if (rffe_rx_att && (rssi>9)) {
 3475               	.LM446:
 3476 034a 9091 0000 		lds r25,vol_timer
 3477 034e 9A30      		cpi r25,lo8(10)
 3478 0350 00F4      		brsh .+2
 3479 0352 00C0      		rjmp .L266
 834:main.c        **** 	  sprintf(buffer,"S---9+++   ");
 3481               	.LM447:
 3482 0354 9091 0000 		lds r25,rffe_rx_att
 3483 0358 9923      		tst r25
 3484 035a 01F0      		breq .L183
 834:main.c        **** 	  sprintf(buffer,"S---9+++   ");
 3486               	.LM448:
 3487 035c 8A30      		cpi r24,lo8(10)
 3488 035e 00F0      		brlo .L183
 835:main.c        **** 	  lcd_goto(0x40);
 3490               	.LM449:
 3491 0360 60E0      		ldi r22,lo8(.LC4)
 3492 0362 70E0      		ldi r23,hi8(.LC4)
 3493 0364 00C0      		rjmp .L343
 3494               	.L183:
 839:main.c        **** 	  rffe_rx_att = false;
 3496               	.LM450:
 3497 0366 9091 0000 		lds r25,rffe_rx_att
 3498 036a 9923      		tst r25
 3499 036c 01F0      		breq .L184
 839:main.c        **** 	  rffe_rx_att = false;
 3501               	.LM451:
 3502 036e 8A30      		cpi r24,lo8(10)
 3503 0370 00F4      		brsh .L185
 840:main.c        **** 	  err = updateRFFE();
 3505               	.LM452:
 3506 0372 1092 0000 		sts rffe_rx_att,__zero_reg__
 3507 0376 00C0      		rjmp .L342
 3508               	.L184:
 843:main.c        **** 	  sprintf(buffer,"S%d         ",rssi);
 3510               	.LM453:
 3511 0378 8230      		cpi r24,lo8(2)
 3512 037a 00F4      		brsh .L186
 844:main.c        **** 	  lcd_goto(0x40);
 3514               	.LM454:
 3515 037c 1F92      		push __zero_reg__
 3516 037e 8F93      		push r24
 3517 0380 80E0      		ldi r24,lo8(.LC5)
 3518 0382 90E0      		ldi r25,hi8(.LC5)
 3519 0384 00C0      		rjmp .L348
 3520               	.L186:
 848:main.c        **** 	  sprintf(buffer,"S-%d        ",rssi);
 3522               	.LM455:
 3523 0386 8430      		cpi r24,lo8(4)
 3524 0388 00F4      		brsh .L185
 849:main.c        **** 	  lcd_goto(0x40);
 3526               	.LM456:
 3527 038a 1F92      		push __zero_reg__
 3528 038c 8F93      		push r24
 3529 038e 80E0      		ldi r24,lo8(.LC6)
 3530 0390 90E0      		ldi r25,hi8(.LC6)
 3531 0392 00C0      		rjmp .L348
 3532               	.L185:
 853:main.c        **** 	  sprintf(buffer,"S--%d       ",rssi);
 3534               	.LM457:
 3535 0394 8630      		cpi r24,lo8(6)
 3536 0396 00F4      		brsh .L187
 854:main.c        **** 	  lcd_goto(0x40);
 3538               	.LM458:
 3539 0398 1F92      		push __zero_reg__
 3540 039a 8F93      		push r24
 3541 039c 80E0      		ldi r24,lo8(.LC7)
 3542 039e 90E0      		ldi r25,hi8(.LC7)
 3543               	.L348:
 3544 03a0 9F93      		push r25
 3545 03a2 8F93      		push r24
 3546 03a4 00C0      		rjmp .L344
 3547               	.L187:
 858:main.c        **** 	  sprintf(buffer,"S---%d      ",rssi);
 3549               	.LM459:
 3550 03a6 8830      		cpi r24,lo8(8)
 3551 03a8 00F4      		brsh .L188
 859:main.c        **** 	  lcd_goto(0x40);
 3553               	.LM460:
 3554 03aa 1F92      		push __zero_reg__
 3555 03ac 8F93      		push r24
 3556 03ae A0E0      		ldi r26,lo8(.LC8)
 3557 03b0 B0E0      		ldi r27,hi8(.LC8)
 3558 03b2 00C0      		rjmp .L345
 3559               	.L188:
 863:main.c        **** 	  sprintf(buffer,"S----%d     ",rssi);
 3561               	.LM461:
 3562 03b4 8A30      		cpi r24,lo8(10)
 3563 03b6 00F4      		brsh .L189
 864:main.c        **** 	  lcd_goto(0x40);
 3565               	.LM462:
 3566 03b8 1F92      		push __zero_reg__
 3567 03ba 8F93      		push r24
 3568 03bc A0E0      		ldi r26,lo8(.LC9)
 3569 03be B0E0      		ldi r27,hi8(.LC9)
 3570               	.L345:
 3571 03c0 BF93      		push r27
 3572 03c2 AF93      		push r26
 3573               	.L344:
 3574 03c4 1F93      		push r17
 3575 03c6 0F93      		push r16
 3576 03c8 0E94 0000 		call sprintf
 865:main.c        **** 	  lcd_puts(buffer);
 3578               	.LM463:
 3579 03cc 80E4      		ldi r24,lo8(64)
 3580 03ce 0E94 0000 		call lcd_goto
 866:main.c        **** 	}
 3582               	.LM464:
 3583 03d2 C801      		movw r24,r16
 3584 03d4 0E94 0000 		call lcd_puts
 3585 03d8 0F90      		pop __tmp_reg__
 3586 03da 0F90      		pop __tmp_reg__
 3587 03dc 0F90      		pop __tmp_reg__
 3588 03de 0F90      		pop __tmp_reg__
 3589 03e0 0F90      		pop __tmp_reg__
 3590 03e2 0F90      		pop __tmp_reg__
 3591 03e4 00C0      		rjmp .L266
 3592               	.L189:
 868:main.c        **** 	  sprintf(buffer,"S----9+    ");
 3594               	.LM465:
 3595 03e6 8C30      		cpi r24,lo8(12)
 3596 03e8 00F4      		brsh .L190
 869:main.c        **** 	  lcd_goto(0x40);
 3598               	.LM466:
 3599 03ea 60E0      		ldi r22,lo8(.LC10)
 3600 03ec 70E0      		ldi r23,hi8(.LC10)
 3601 03ee 00C0      		rjmp .L343
 3602               	.L190:
 873:main.c        **** 	  sprintf(buffer,"S----9++   ");
 3604               	.LM467:
 3605 03f0 8C30      		cpi r24,lo8(12)
 3606 03f2 01F4      		brne .L191
 874:main.c        **** 	  lcd_goto(0x40);
 3608               	.LM468:
 3609 03f4 60E0      		ldi r22,lo8(.LC11)
 3610 03f6 70E0      		ldi r23,hi8(.LC11)
 3611               	.L343:
 3612 03f8 C801      		movw r24,r16
 3613 03fa 0E94 0000 		call strcpy
 875:main.c        **** 	  lcd_puts(buffer);
 3615               	.LM469:
 3616 03fe 80E4      		ldi r24,lo8(64)
 3617 0400 0E94 0000 		call lcd_goto
 876:main.c        **** 	}
 3619               	.LM470:
 3620 0404 C801      		movw r24,r16
 3621 0406 0E94 0000 		call lcd_puts
 3622 040a 00C0      		rjmp .L266
 3623               	.L191:
 879:main.c        **** 	  err = updateRFFE();
 3625               	.LM471:
 3626 040c 81E0      		ldi r24,lo8(1)
 3627 040e 8093 0000 		sts rffe_rx_att,r24
 3628               	.L342:
 880:main.c        **** 	}
 3630               	.LM472:
 3631 0412 0E94 0000 		call updateRFFE
 3632               	.L266:
 826:main.c        **** 	if (rssi_max < 4)
 3634               	.LM473:
 3635 0416 E12C      		mov r14,__zero_reg__
 831:main.c        **** 
 3637               	.LM474:
 3638 0418 F12C      		mov r15,__zero_reg__
 3639               	.L181:
 884:main.c        ****     }
 3641               	.LM475:
 3642 041a 1092 0000 		sts timer_flag,__zero_reg__
 3643 041e 00C0      		rjmp .L192
 3644               	.L161:
 886:main.c        ****       switch (mode) {
 3646               	.LM476:
 3647 0420 8091 0000 		lds r24,mode_flag
 3648 0424 8823      		tst r24
 3649 0426 01F4      		brne .+2
 3650 0428 00C0      		rjmp .L192
 887:main.c        ****       case LSB:
 3652               	.LM477:
 3653 042a 8091 0000 		lds r24,mode
 3654 042e 8330      		cpi r24,lo8(3)
 3655 0430 01F0      		breq .L194
 3656 0432 00F4      		brsh .L195
 3657 0434 8130      		cpi r24,lo8(1)
 3658 0436 01F0      		breq .L196
 3659 0438 00C0      		rjmp .L193
 3660               	.L195:
 3661 043a 8530      		cpi r24,lo8(5)
 3662 043c 01F0      		breq .L197
 3663 043e 8630      		cpi r24,lo8(6)
 3664 0440 01F0      		breq .L198
 3665 0442 00C0      		rjmp .L193
 3666               	.L196:
 889:main.c        **** 	if (!updateSettings()) { 
 3668               	.LM478:
 3669 0444 83E0      		ldi r24,lo8(3)
 3670 0446 8093 0000 		sts mode,r24
 890:main.c        **** 	  lcd_goto(0x00);
 3672               	.LM479:
 3673 044a 0E94 0000 		call updateSettings
 3674 044e 8111      		cpse r24,__zero_reg__
 3675 0450 00C0      		rjmp .L200
 891:main.c        **** 	  sprintf(buffer,"USB ");
 3677               	.LM480:
 3678 0452 0E94 0000 		call lcd_goto
 892:main.c        **** 	  lcd_puts(buffer);
 3680               	.LM481:
 3681 0456 60E0      		ldi r22,lo8(.LC12)
 3682 0458 70E0      		ldi r23,hi8(.LC12)
 3683 045a 00C0      		rjmp .L337
 3684               	.L194:
 897:main.c        **** 	if(!updateSettings()) {
 3686               	.LM482:
 3687 045c 85E0      		ldi r24,lo8(5)
 3688 045e 8093 0000 		sts mode,r24
 898:main.c        **** 	  lcd_goto(0x00);
 3690               	.LM483:
 3691 0462 0E94 0000 		call updateSettings
 3692 0466 8111      		cpse r24,__zero_reg__
 3693 0468 00C0      		rjmp .L200
 899:main.c        **** 	  sprintf(buffer,"CW  ");
 3695               	.LM484:
 3696 046a 0E94 0000 		call lcd_goto
 900:main.c        **** 	  lcd_puts(buffer);
 3698               	.LM485:
 3699 046e 60E0      		ldi r22,lo8(.LC13)
 3700 0470 70E0      		ldi r23,hi8(.LC13)
 3701 0472 00C0      		rjmp .L337
 3702               	.L197:
 905:main.c        **** 	if(!updateSettings()) {
 3704               	.LM486:
 3705 0474 86E0      		ldi r24,lo8(6)
 3706 0476 8093 0000 		sts mode,r24
 906:main.c        **** 	  lcd_goto(0x00);
 3708               	.LM487:
 3709 047a 0E94 0000 		call updateSettings
 3710 047e 8111      		cpse r24,__zero_reg__
 3711 0480 00C0      		rjmp .L200
 907:main.c        **** 	  sprintf(buffer,"CWN ");
 3713               	.LM488:
 3714 0482 0E94 0000 		call lcd_goto
 908:main.c        **** 	  lcd_puts(buffer);
 3716               	.LM489:
 3717 0486 60E0      		ldi r22,lo8(.LC14)
 3718 0488 70E0      		ldi r23,hi8(.LC14)
 3719 048a 00C0      		rjmp .L337
 3720               	.L198:
 913:main.c        **** 	  mode = AM;
 3722               	.LM490:
 3723 048c 8091 0000 		lds r24,band
 3724 0490 883C      		cpi r24,lo8(-56)
 3725 0492 00F4      		brsh .L202
 914:main.c        **** 	  if(!updateSettings()) {
 3727               	.LM491:
 3728 0494 88E0      		ldi r24,lo8(8)
 3729 0496 8093 0000 		sts mode,r24
 915:main.c        **** 	    lcd_goto(0x00);
 3731               	.LM492:
 3732 049a 0E94 0000 		call updateSettings
 3733 049e 8111      		cpse r24,__zero_reg__
 3734 04a0 00C0      		rjmp .L200
 916:main.c        **** 	    sprintf(buffer,"AM  ");
 3736               	.LM493:
 3737 04a2 0E94 0000 		call lcd_goto
 917:main.c        **** 	    lcd_puts(buffer);
 3739               	.LM494:
 3740 04a6 60E0      		ldi r22,lo8(.LC15)
 3741 04a8 70E0      		ldi r23,hi8(.LC15)
 3742 04aa 00C0      		rjmp .L337
 3743               	.L202:
 922:main.c        **** 	  if(!updateSettings()) {
 3745               	.LM495:
 3746 04ac 8AE0      		ldi r24,lo8(10)
 3747 04ae 8093 0000 		sts mode,r24
 923:main.c        **** 	    lcd_goto(0x00);
 3749               	.LM496:
 3750 04b2 0E94 0000 		call updateSettings
 3751 04b6 8111      		cpse r24,__zero_reg__
 3752 04b8 00C0      		rjmp .L200
 924:main.c        **** 	    sprintf(buffer,"FM  ");
 3754               	.LM497:
 3755 04ba 0E94 0000 		call lcd_goto
 925:main.c        **** 	    lcd_puts(buffer);
 3757               	.LM498:
 3758 04be 60E0      		ldi r22,lo8(.LC16)
 3759 04c0 70E0      		ldi r23,hi8(.LC16)
 3760 04c2 00C0      		rjmp .L337
 3761               	.L193:
 933:main.c        **** 	if(!updateSettings()) { 
 3763               	.LM499:
 3764 04c4 81E0      		ldi r24,lo8(1)
 3765 04c6 8093 0000 		sts mode,r24
 934:main.c        **** 	  lcd_goto(0x00);
 3767               	.LM500:
 3768 04ca 0E94 0000 		call updateSettings
 3769 04ce 8111      		cpse r24,__zero_reg__
 3770 04d0 00C0      		rjmp .L200
 935:main.c        **** 	  sprintf(buffer,"LSB ");
 3772               	.LM501:
 3773 04d2 0E94 0000 		call lcd_goto
 936:main.c        **** 	  lcd_puts(buffer);
 3775               	.LM502:
 3776 04d6 60E0      		ldi r22,lo8(.LC17)
 3777 04d8 70E0      		ldi r23,hi8(.LC17)
 3778               	.L337:
 3779 04da C801      		movw r24,r16
 3780 04dc 0E94 0000 		call strcpy
 937:main.c        **** 	}
 3782               	.LM503:
 3783 04e0 C801      		movw r24,r16
 3784 04e2 0E94 0000 		call lcd_puts
 3785               	.L200:
 3786               	.LBB491:
 3787               	.LBB492:
 3789               	.Ltext44:
 163:/usr/lib/avr/include/util/delay.h **** 
 3791               	.LM504:
 3792 04e6 83E2      		ldi r24,lo8(-3037)
 3793 04e8 94EF      		ldi r25,hi8(-3037)
 3794 04ea 0197      	1:	sbiw r24,1
 3795 04ec 01F4      		brne 1b
 3796 04ee 00C0      		rjmp .
 3797 04f0 0000      		nop
 3798               	.LBE492:
 3799               	.LBE491:
 3801               	.Ltext45:
 942:main.c        ****       mode_flag = 0x00;
 3803               	.LM505:
 3804 04f2 81E0      		ldi r24,lo8(1)
 3805 04f4 0E94 0000 		call updateFreq
 943:main.c        ****     }
 3807               	.LM506:
 3808 04f8 1092 0000 		sts mode_flag,__zero_reg__
 3809               	.L192:
 946:main.c        ****       if (band_flag == 0x02) { // long press
 3811               	.LM507:
 3812 04fc 8091 0000 		lds r24,band_flag
 3813 0500 8823      		tst r24
 3814 0502 01F4      		brne .+2
 3815 0504 00C0      		rjmp .L203
 947:main.c        **** #ifdef TWOMETER_TRANSV
 3817               	.LM508:
 3818 0506 8091 0000 		lds r24,band_flag
 3819 050a 8230      		cpi r24,lo8(2)
 3820 050c 01F4      		brne .+2
 3821 050e 00C0      		rjmp .L204
 983:main.c        **** 	  freq = 3510;
 3823               	.LM509:
 3824 0510 6091 0000 		lds r22,freq
 3825 0514 7091 0000 		lds r23,freq+1
 3826 0518 8091 0000 		lds r24,freq+2
 3827 051c 9091 0000 		lds r25,freq+3
 3828 0520 20E0      		ldi r18,0
 3829 0522 30EC      		ldi r19,lo8(-64)
 3830 0524 4AE5      		ldi r20,lo8(90)
 3831 0526 55E4      		ldi r21,lo8(69)
 3832 0528 0E94 0000 		call __ltsf2
 3833 052c 87FF      		sbrs r24,7
 3834 052e 00C0      		rjmp .L325
 3836               	.LM510:
 3837 0530 4092 0000 		sts freq,r4
 3838 0534 5092 0000 		sts freq+1,r5
 3839 0538 6092 0000 		sts freq+2,r6
 3840 053c 7092 0000 		sts freq+3,r7
 3841 0540 00C0      		rjmp .L204
 3842               	.L325:
 985:main.c        **** 	else if(freq<7000)
 3844               	.LM511:
 3845 0542 6091 0000 		lds r22,freq
 3846 0546 7091 0000 		lds r23,freq+1
 3847 054a 8091 0000 		lds r24,freq+2
 3848 054e 9091 0000 		lds r25,freq+3
 3849 0552 20E0      		ldi r18,0
 3850 0554 30EC      		ldi r19,lo8(-64)
 3851 0556 4AED      		ldi r20,lo8(-38)
 3852 0558 55E4      		ldi r21,lo8(69)
 3853 055a 0E94 0000 		call __ltsf2
 3854 055e 87FF      		sbrs r24,7
 3855 0560 00C0      		rjmp .L326
 986:main.c        **** 	  freq = 7010;
 3857               	.LM512:
 3858 0562 80E0      		ldi r24,0
 3859 0564 90E1      		ldi r25,lo8(16)
 3860 0566 ABED      		ldi r26,lo8(-37)
 3861 0568 B5E4      		ldi r27,lo8(69)
 3862 056a 00C0      		rjmp .L338
 3863               	.L326:
 987:main.c        **** 	else if(freq<10100)
 3865               	.LM513:
 3866 056c 6091 0000 		lds r22,freq
 3867 0570 7091 0000 		lds r23,freq+1
 3868 0574 8091 0000 		lds r24,freq+2
 3869 0578 9091 0000 		lds r25,freq+3
 3870 057c 20E0      		ldi r18,0
 3871 057e 30ED      		ldi r19,lo8(-48)
 3872 0580 4DE1      		ldi r20,lo8(29)
 3873 0582 56E4      		ldi r21,lo8(70)
 3874 0584 0E94 0000 		call __ltsf2
 3875 0588 87FF      		sbrs r24,7
 3876 058a 00C0      		rjmp .L327
 988:main.c        **** 	  freq = 10110;
 3878               	.LM514:
 3879 058c 80E0      		ldi r24,0
 3880 058e 98EF      		ldi r25,lo8(-8)
 3881 0590 ADE1      		ldi r26,lo8(29)
 3882 0592 B6E4      		ldi r27,lo8(70)
 3883 0594 00C0      		rjmp .L338
 3884               	.L327:
 989:main.c        **** 	else if(freq<14000)
 3886               	.LM515:
 3887 0596 6091 0000 		lds r22,freq
 3888 059a 7091 0000 		lds r23,freq+1
 3889 059e 8091 0000 		lds r24,freq+2
 3890 05a2 9091 0000 		lds r25,freq+3
 3891 05a6 20E0      		ldi r18,0
 3892 05a8 30EC      		ldi r19,lo8(-64)
 3893 05aa 4AE5      		ldi r20,lo8(90)
 3894 05ac 56E4      		ldi r21,lo8(70)
 3895 05ae 0E94 0000 		call __ltsf2
 3896 05b2 87FF      		sbrs r24,7
 3897 05b4 00C0      		rjmp .L328
 990:main.c        **** 	  freq = 14010;
 3899               	.LM516:
 3900 05b6 80E0      		ldi r24,0
 3901 05b8 98EE      		ldi r25,lo8(-24)
 3902 05ba AAE5      		ldi r26,lo8(90)
 3903 05bc B6E4      		ldi r27,lo8(70)
 3904 05be 00C0      		rjmp .L338
 3905               	.L328:
 991:main.c        **** 	else if(freq<18068)
 3907               	.LM517:
 3908 05c0 6091 0000 		lds r22,freq
 3909 05c4 7091 0000 		lds r23,freq+1
 3910 05c8 8091 0000 		lds r24,freq+2
 3911 05cc 9091 0000 		lds r25,freq+3
 3912 05d0 20E0      		ldi r18,0
 3913 05d2 38E2      		ldi r19,lo8(40)
 3914 05d4 4DE8      		ldi r20,lo8(-115)
 3915 05d6 56E4      		ldi r21,lo8(70)
 3916 05d8 0E94 0000 		call __ltsf2
 3917 05dc 87FF      		sbrs r24,7
 3918 05de 00C0      		rjmp .L329
 992:main.c        **** 	  freq = 18078;
 3920               	.LM518:
 3921 05e0 80E0      		ldi r24,0
 3922 05e2 9CE3      		ldi r25,lo8(60)
 3923 05e4 ADE8      		ldi r26,lo8(-115)
 3924 05e6 B6E4      		ldi r27,lo8(70)
 3925 05e8 00C0      		rjmp .L338
 3926               	.L329:
 993:main.c        **** 	else if(freq<21000)
 3928               	.LM519:
 3929 05ea 6091 0000 		lds r22,freq
 3930 05ee 7091 0000 		lds r23,freq+1
 3931 05f2 8091 0000 		lds r24,freq+2
 3932 05f6 9091 0000 		lds r25,freq+3
 3933 05fa 20E0      		ldi r18,0
 3934 05fc 30E1      		ldi r19,lo8(16)
 3935 05fe 44EA      		ldi r20,lo8(-92)
 3936 0600 56E4      		ldi r21,lo8(70)
 3937 0602 0E94 0000 		call __ltsf2
 3938 0606 87FF      		sbrs r24,7
 3939 0608 00C0      		rjmp .L330
 994:main.c        **** 	  freq = 21010;
 3941               	.LM520:
 3942 060a 80E0      		ldi r24,0
 3943 060c 94E2      		ldi r25,lo8(36)
 3944 060e A4EA      		ldi r26,lo8(-92)
 3945 0610 B6E4      		ldi r27,lo8(70)
 3946 0612 00C0      		rjmp .L338
 3947               	.L330:
 995:main.c        **** 	else if(freq<24890)
 3949               	.LM521:
 3950 0614 6091 0000 		lds r22,freq
 3951 0618 7091 0000 		lds r23,freq+1
 3952 061c 8091 0000 		lds r24,freq+2
 3953 0620 9091 0000 		lds r25,freq+3
 3954 0624 20E0      		ldi r18,0
 3955 0626 34E7      		ldi r19,lo8(116)
 3956 0628 42EC      		ldi r20,lo8(-62)
 3957 062a 56E4      		ldi r21,lo8(70)
 3958 062c 0E94 0000 		call __ltsf2
 3959 0630 87FF      		sbrs r24,7
 3960 0632 00C0      		rjmp .L331
 996:main.c        **** 	  freq = 24900;
 3962               	.LM522:
 3963 0634 80E0      		ldi r24,0
 3964 0636 98E8      		ldi r25,lo8(-120)
 3965 0638 A2EC      		ldi r26,lo8(-62)
 3966 063a B6E4      		ldi r27,lo8(70)
 3967 063c 00C0      		rjmp .L338
 3968               	.L331:
 997:main.c        **** 	else if(freq<28000)
 3970               	.LM523:
 3971 063e 6091 0000 		lds r22,freq
 3972 0642 7091 0000 		lds r23,freq+1
 3973 0646 8091 0000 		lds r24,freq+2
 3974 064a 9091 0000 		lds r25,freq+3
 3975 064e 20E0      		ldi r18,0
 3976 0650 30EC      		ldi r19,lo8(-64)
 3977 0652 4AED      		ldi r20,lo8(-38)
 3978 0654 56E4      		ldi r21,lo8(70)
 3979 0656 0E94 0000 		call __ltsf2
 3980 065a 87FF      		sbrs r24,7
 3981 065c 00C0      		rjmp .L332
 998:main.c        **** 	  freq = 28010;
 3983               	.LM524:
 3984 065e 80E0      		ldi r24,0
 3985 0660 94ED      		ldi r25,lo8(-44)
 3986 0662 AAED      		ldi r26,lo8(-38)
 3987 0664 B6E4      		ldi r27,lo8(70)
 3988 0666 00C0      		rjmp .L338
 3989               	.L332:
 999:main.c        **** 	else if(freq<28500)
 3991               	.LM525:
 3992 0668 6091 0000 		lds r22,freq
 3993 066c 7091 0000 		lds r23,freq+1
 3994 0670 8091 0000 		lds r24,freq+2
 3995 0674 9091 0000 		lds r25,freq+3
 3996 0678 20E0      		ldi r18,0
 3997 067a 38EA      		ldi r19,lo8(-88)
 3998 067c 4EED      		ldi r20,lo8(-34)
 3999 067e 56E4      		ldi r21,lo8(70)
 4000 0680 0E94 0000 		call __ltsf2
 4001 0684 87FF      		sbrs r24,7
 4002 0686 00C0      		rjmp .L333
1000:main.c        **** 	  freq = 28600;
 4004               	.LM526:
 4005 0688 80E0      		ldi r24,0
 4006 068a 90E7      		ldi r25,lo8(112)
 4007 068c AFED      		ldi r26,lo8(-33)
 4008 068e B6E4      		ldi r27,lo8(70)
 4009 0690 00C0      		rjmp .L338
 4010               	.L333:
1001:main.c        **** 	else
1002:main.c        **** 	  freq = 1810;
 4012               	.LM527:
 4013 0692 80E0      		ldi r24,0
 4014 0694 90E4      		ldi r25,lo8(64)
 4015 0696 A2EE      		ldi r26,lo8(-30)
 4016 0698 B4E4      		ldi r27,lo8(68)
 4017               	.L338:
 4018 069a 8093 0000 		sts freq,r24
 4019 069e 9093 0000 		sts freq+1,r25
 4020 06a2 A093 0000 		sts freq+2,r26
 4021 06a6 B093 0000 		sts freq+3,r27
 4022               	.L204:
1003:main.c        **** #endif
1004:main.c        **** #ifdef TWOMETER
1005:main.c        ****       if(freq<144150)
1006:main.c        **** 	freq = 144300;
1007:main.c        ****       else if(freq<144400)
1008:main.c        **** 	freq = 144450;
1009:main.c        ****       else if(freq<145000)
1010:main.c        **** 	freq = 145500;
1011:main.c        ****       else if(freq<150000)
1012:main.c        **** 	freq = 144050;
1013:main.c        **** #endif
1014:main.c        **** #ifdef TWOMETER_TRANSV
1015:main.c        ****       if(freq<144700)
1016:main.c        **** 	freq = 144800;
1017:main.c        ****       else if(freq<150000)
1018:main.c        **** 	freq = 144200;
1019:main.c        **** #endif
1020:main.c        ****       }
1021:main.c        **** 
1022:main.c        ****       lcd_freq();
 4024               	.LM528:
 4025 06aa 0E94 0000 		call lcd_freq
1023:main.c        ****       err = updateFreq(1);
 4027               	.LM529:
 4028 06ae 81E0      		ldi r24,lo8(1)
 4029 06b0 0E94 0000 		call updateFreq
1024:main.c        ****       if (err) {
 4031               	.LM530:
 4032 06b4 8823      		tst r24
 4033 06b6 01F0      		breq .L223
1025:main.c        **** 	sprintf(buffer,"Err freq %x         ",err);
 4035               	.LM531:
 4036 06b8 1F92      		push __zero_reg__
 4037 06ba 8F93      		push r24
 4038 06bc 80E0      		ldi r24,lo8(.LC18)
 4039 06be 90E0      		ldi r25,hi8(.LC18)
 4040 06c0 9F93      		push r25
 4041 06c2 8F93      		push r24
 4042 06c4 1F93      		push r17
 4043 06c6 0F93      		push r16
 4044 06c8 0E94 0000 		call sprintf
1026:main.c        **** 	lcd_goto(0x40);
 4046               	.LM532:
 4047 06cc 80E4      		ldi r24,lo8(64)
 4048 06ce 0E94 0000 		call lcd_goto
1027:main.c        **** 	lcd_puts(buffer);	
 4050               	.LM533:
 4051 06d2 C801      		movw r24,r16
 4052 06d4 0E94 0000 		call lcd_puts
 4053 06d8 0F90      		pop __tmp_reg__
 4054 06da 0F90      		pop __tmp_reg__
 4055 06dc 0F90      		pop __tmp_reg__
 4056 06de 0F90      		pop __tmp_reg__
 4057 06e0 0F90      		pop __tmp_reg__
 4058 06e2 0F90      		pop __tmp_reg__
 4059               	.L223:
1028:main.c        ****       }      
1029:main.c        ****       err = updateSettings();
 4061               	.LM534:
 4062 06e4 0E94 0000 		call updateSettings
1030:main.c        ****       if (err) {
 4064               	.LM535:
 4065 06e8 8823      		tst r24
 4066 06ea 01F0      		breq .L224
1031:main.c        **** 	sprintf(buffer,"Err sett %x         ",err);
 4068               	.LM536:
 4069 06ec 1F92      		push __zero_reg__
 4070 06ee 8F93      		push r24
 4071 06f0 80E0      		ldi r24,lo8(.LC19)
 4072 06f2 90E0      		ldi r25,hi8(.LC19)
 4073 06f4 9F93      		push r25
 4074 06f6 8F93      		push r24
 4075 06f8 1F93      		push r17
 4076 06fa 0F93      		push r16
 4077 06fc 0E94 0000 		call sprintf
1032:main.c        **** 	lcd_goto(0x40);
 4079               	.LM537:
 4080 0700 80E4      		ldi r24,lo8(64)
 4081 0702 0E94 0000 		call lcd_goto
1033:main.c        **** 	lcd_puts(buffer);	
 4083               	.LM538:
 4084 0706 C801      		movw r24,r16
 4085 0708 0E94 0000 		call lcd_puts
 4086 070c 0F90      		pop __tmp_reg__
 4087 070e 0F90      		pop __tmp_reg__
 4088 0710 0F90      		pop __tmp_reg__
 4089 0712 0F90      		pop __tmp_reg__
 4090 0714 0F90      		pop __tmp_reg__
 4091 0716 0F90      		pop __tmp_reg__
 4092               	.L224:
 4093               	.LBB493:
 4094               	.LBB494:
 4096               	.Ltext46:
 163:/usr/lib/avr/include/util/delay.h **** 
 4098               	.LM539:
 4099 0718 AFE4      		ldi r26,lo8(-15537)
 4100 071a B3EC      		ldi r27,hi8(-15537)
 4101 071c 1197      	1:	sbiw r26,1
 4102 071e 01F4      		brne 1b
 4103 0720 00C0      		rjmp .
 4104 0722 0000      		nop
 4105               	.LBE494:
 4106               	.LBE493:
 4108               	.Ltext47:
1034:main.c        ****       }      
1035:main.c        ****       _delay_ms(200);
1036:main.c        ****       band_flag = 0x00;
 4110               	.LM540:
 4111 0724 1092 0000 		sts band_flag,__zero_reg__
 4112 0728 00C0      		rjmp .L160
 4113               	.L203:
1037:main.c        ****     }
1038:main.c        ****     else if (rot_flag) {
 4115               	.LM541:
 4116 072a 8091 0000 		lds r24,rot_flag
 4117 072e 8823      		tst r24
 4118 0730 01F4      		brne .+2
 4119 0732 00C0      		rjmp .L226
1039:main.c        ****       if (rot_flag != last_dir) {
 4121               	.LM542:
 4122 0734 8091 0000 		lds r24,rot_flag
 4123 0738 BFAD      		ldd r27,Y+63
 4124 073a 8B17      		cp r24,r27
 4125 073c 01F0      		breq .L227
1040:main.c        **** 	steps = 0;
1041:main.c        **** 	step_timer = 0;
 4127               	.LM543:
 4128 073e 1092 0000 		sts step_timer+1,__zero_reg__
 4129 0742 1092 0000 		sts step_timer,__zero_reg__
1042:main.c        **** 	last_dir = rot_flag;
 4131               	.LM544:
 4132 0746 8091 0000 		lds r24,rot_flag
1040:main.c        **** 	steps = 0;
 4134               	.LM545:
 4135 074a C12C      		mov r12,__zero_reg__
 4136 074c D12C      		mov r13,__zero_reg__
 4137 074e 00C0      		rjmp .L228
 4138               	.L227:
1043:main.c        ****       }
1044:main.c        ****       else if (rot_flag == 0x01) {
 4140               	.LM546:
 4141 0750 9091 0000 		lds r25,rot_flag
 4142 0754 9130      		cpi r25,lo8(1)
 4143 0756 01F0      		breq .+2
 4144 0758 00C0      		rjmp .L229
1045:main.c        **** 	if (step_timer < 30) {
 4146               	.LM547:
 4147 075a 8091 0000 		lds r24,step_timer
 4148 075e 9091 0000 		lds r25,step_timer+1
1046:main.c        **** 	  step_timer = 0;
 4150               	.LM548:
 4151 0762 1092 0000 		sts step_timer+1,__zero_reg__
 4152 0766 1092 0000 		sts step_timer,__zero_reg__
1045:main.c        **** 	if (step_timer < 30) {
 4154               	.LM549:
 4155 076a 4E97      		sbiw r24,30
 4156 076c 00F4      		brsh .L230
1047:main.c        **** 	  steps ++;
 4158               	.LM550:
 4159 076e 2FEF      		ldi r18,-1
 4160 0770 C21A      		sub r12,r18
 4161 0772 D20A      		sbc r13,r18
1048:main.c        **** 	}
1049:main.c        **** 	else {
1050:main.c        **** 	  step_timer = 0;
1051:main.c        **** 	  steps = 1;
1052:main.c        **** 	}
1053:main.c        **** 	
1054:main.c        **** 	if (steps > 500) {
 4163               	.LM551:
 4164 0774 85EF      		ldi r24,-11
 4165 0776 C816      		cp r12,r24
 4166 0778 81E0      		ldi r24,1
 4167 077a D806      		cpc r13,r24
 4168 077c 00F4      		brsh .L231
 4169 077e 00C0      		rjmp .L349
 4170               	.L230:
1051:main.c        **** 	}
 4172               	.LM552:
 4173 0780 CC24      		clr r12
 4174 0782 C394      		inc r12
 4175 0784 D12C      		mov r13,__zero_reg__
 4176 0786 00C0      		rjmp .L233
 4177               	.L231:
1055:main.c        **** 	  if (mode == AM)
 4179               	.LM553:
 4180 0788 8091 0000 		lds r24,mode
 4181 078c 8830      		cpi r24,lo8(8)
 4182 078e 01F4      		brne .L234
1056:main.c        **** 	    freq += 20;
 4184               	.LM554:
 4185 0790 6091 0000 		lds r22,freq
 4186 0794 7091 0000 		lds r23,freq+1
 4187 0798 8091 0000 		lds r24,freq+2
 4188 079c 9091 0000 		lds r25,freq+3
 4189 07a0 20E0      		ldi r18,0
 4190 07a2 30E0      		ldi r19,0
 4191 07a4 40EA      		ldi r20,lo8(-96)
 4192 07a6 51E4      		ldi r21,lo8(65)
 4193 07a8 00C0      		rjmp .L339
 4194               	.L234:
1057:main.c        **** 	  else if (mode == FM)
 4196               	.LM555:
 4197 07aa 8091 0000 		lds r24,mode
 4198 07ae 8A30      		cpi r24,lo8(10)
 4199 07b0 01F0      		breq .+2
 4200 07b2 00C0      		rjmp .L346
1058:main.c        **** 	    freq += 50;
 4202               	.LM556:
 4203 07b4 6091 0000 		lds r22,freq
 4204 07b8 7091 0000 		lds r23,freq+1
 4205 07bc 8091 0000 		lds r24,freq+2
 4206 07c0 9091 0000 		lds r25,freq+3
 4207 07c4 20E0      		ldi r18,0
 4208 07c6 30E0      		ldi r19,0
 4209 07c8 48E4      		ldi r20,lo8(72)
 4210 07ca 52E4      		ldi r21,lo8(66)
 4211 07cc 00C0      		rjmp .L339
 4212               	.L349:
1059:main.c        **** 	  else
1060:main.c        **** 	    freq += 1;
1061:main.c        **** 	}
1062:main.c        **** 	else if (steps > 150) {
 4214               	.LM557:
 4215 07ce 97E9      		ldi r25,-105
 4216 07d0 C916      		cp r12,r25
 4217 07d2 D104      		cpc r13,__zero_reg__
 4218 07d4 00F0      		brlo .L233
1063:main.c        **** 	  if (mode == AM)
 4220               	.LM558:
 4221 07d6 8091 0000 		lds r24,mode
 4222 07da 8830      		cpi r24,lo8(8)
 4223 07dc 01F4      		brne .L236
1064:main.c        **** 	    freq += 5;
 4225               	.LM559:
 4226 07de 6091 0000 		lds r22,freq
 4227 07e2 7091 0000 		lds r23,freq+1
 4228 07e6 8091 0000 		lds r24,freq+2
 4229 07ea 9091 0000 		lds r25,freq+3
 4230 07ee 20E0      		ldi r18,0
 4231 07f0 30E0      		ldi r19,0
 4232 07f2 40EA      		ldi r20,lo8(-96)
 4233 07f4 50E4      		ldi r21,lo8(64)
 4234 07f6 00C0      		rjmp .L339
 4235               	.L236:
1065:main.c        **** 	  else if (mode == FM)
 4237               	.LM560:
 4238 07f8 8091 0000 		lds r24,mode
 4239 07fc 8A30      		cpi r24,lo8(10)
 4240 07fe 01F4      		brne .L237
1066:main.c        **** 	    freq += 25;
 4242               	.LM561:
 4243 0800 6091 0000 		lds r22,freq
 4244 0804 7091 0000 		lds r23,freq+1
 4245 0808 8091 0000 		lds r24,freq+2
 4246 080c 9091 0000 		lds r25,freq+3
 4247 0810 20E0      		ldi r18,0
 4248 0812 30E0      		ldi r19,0
 4249 0814 48EC      		ldi r20,lo8(-56)
 4250 0816 51E4      		ldi r21,lo8(65)
 4251 0818 00C0      		rjmp .L339
 4252               	.L237:
1067:main.c        **** 	  else
1068:main.c        **** 	    freq += 0.5;
 4254               	.LM562:
 4255 081a 6091 0000 		lds r22,freq
 4256 081e 7091 0000 		lds r23,freq+1
 4257 0822 8091 0000 		lds r24,freq+2
 4258 0826 9091 0000 		lds r25,freq+3
 4259 082a 20E0      		ldi r18,0
 4260 082c 30E0      		ldi r19,0
 4261 082e 40E0      		ldi r20,0
 4262 0830 5FE3      		ldi r21,lo8(63)
 4263 0832 00C0      		rjmp .L339
 4264               	.L233:
1069:main.c        **** 	}
1070:main.c        **** 	else {
1071:main.c        **** 	  if (mode == AM) {
 4266               	.LM563:
 4267 0834 8091 0000 		lds r24,mode
 4268 0838 8830      		cpi r24,lo8(8)
 4269 083a 01F4      		brne .L238
1072:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4271               	.LM564:
 4272 083c 0B9B      		sbis 0x1,3
 4273 083e 00C0      		rjmp .L239
 4274               	.L346:
1073:main.c        **** 		freq += 1;
 4276               	.LM565:
 4277 0840 6091 0000 		lds r22,freq
 4278 0844 7091 0000 		lds r23,freq+1
 4279 0848 8091 0000 		lds r24,freq+2
 4280 084c 9091 0000 		lds r25,freq+3
 4281 0850 20E0      		ldi r18,0
 4282 0852 30E0      		ldi r19,0
 4283 0854 40E8      		ldi r20,lo8(-128)
 4284 0856 5FE3      		ldi r21,lo8(63)
 4285 0858 00C0      		rjmp .L339
 4286               	.L239:
1074:main.c        **** 	    else
1075:main.c        **** 	      freq += 10;
 4288               	.LM566:
 4289 085a 6091 0000 		lds r22,freq
 4290 085e 7091 0000 		lds r23,freq+1
 4291 0862 8091 0000 		lds r24,freq+2
 4292 0866 9091 0000 		lds r25,freq+3
 4293 086a 20E0      		ldi r18,0
 4294 086c 30E0      		ldi r19,0
 4295 086e 40E2      		ldi r20,lo8(32)
 4296 0870 51E4      		ldi r21,lo8(65)
 4297 0872 00C0      		rjmp .L339
 4298               	.L238:
1076:main.c        **** 	  }
1077:main.c        **** 	  else if (mode == FM)
 4300               	.LM567:
 4301 0874 8091 0000 		lds r24,mode
 4302 0878 8A30      		cpi r24,lo8(10)
 4303 087a 01F4      		brne .L240
1078:main.c        **** 	    freq += 2.5;
 4305               	.LM568:
 4306 087c 6091 0000 		lds r22,freq
 4307 0880 7091 0000 		lds r23,freq+1
 4308 0884 8091 0000 		lds r24,freq+2
 4309 0888 9091 0000 		lds r25,freq+3
 4310 088c 20E0      		ldi r18,0
 4311 088e 30E0      		ldi r19,0
 4312 0890 40E2      		ldi r20,lo8(32)
 4313 0892 50E4      		ldi r21,lo8(64)
 4314 0894 00C0      		rjmp .L339
 4315               	.L240:
1079:main.c        **** 	  else {
1080:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4317               	.LM569:
 4318 0896 0B9B      		sbis 0x1,3
 4319 0898 00C0      		rjmp .L241
1081:main.c        **** 		freq += 0.05;
 4321               	.LM570:
 4322 089a 6091 0000 		lds r22,freq
 4323 089e 7091 0000 		lds r23,freq+1
 4324 08a2 8091 0000 		lds r24,freq+2
 4325 08a6 9091 0000 		lds r25,freq+3
 4326 08aa 2DEC      		ldi r18,lo8(-51)
 4327 08ac 3CEC      		ldi r19,lo8(-52)
 4328 08ae 4CE4      		ldi r20,lo8(76)
 4329 08b0 5DE3      		ldi r21,lo8(61)
 4330 08b2 00C0      		rjmp .L339
 4331               	.L241:
1082:main.c        **** 	    else
1083:main.c        **** 	      freq += 2;
 4333               	.LM571:
 4334 08b4 6091 0000 		lds r22,freq
 4335 08b8 7091 0000 		lds r23,freq+1
 4336 08bc 8091 0000 		lds r24,freq+2
 4337 08c0 9091 0000 		lds r25,freq+3
 4338 08c4 20E0      		ldi r18,0
 4339 08c6 30E0      		ldi r19,0
 4340 08c8 40E0      		ldi r20,0
 4341 08ca 50E4      		ldi r21,lo8(64)
 4342               	.L339:
 4343 08cc 0E94 0000 		call __addsf3
 4344 08d0 6093 0000 		sts freq,r22
 4345 08d4 7093 0000 		sts freq+1,r23
 4346 08d8 8093 0000 		sts freq+2,r24
 4347 08dc 9093 0000 		sts freq+3,r25
1084:main.c        **** 	  }
1085:main.c        **** 	}
1086:main.c        **** 	last_dir = 0x01;
 4349               	.LM572:
 4350 08e0 81E0      		ldi r24,lo8(1)
 4351 08e2 00C0      		rjmp .L228
 4352               	.L229:
1087:main.c        ****       }
1088:main.c        ****       else if (rot_flag == 0x02) {
 4354               	.LM573:
 4355 08e4 9091 0000 		lds r25,rot_flag
 4356 08e8 9230      		cpi r25,lo8(2)
 4357 08ea 01F0      		breq .+2
 4358 08ec 00C0      		rjmp .L228
1089:main.c        **** 	if ((step_timer < 30) && (last_dir == rot_flag)) {
 4360               	.LM574:
 4361 08ee 8091 0000 		lds r24,step_timer
 4362 08f2 9091 0000 		lds r25,step_timer+1
 4363 08f6 4E97      		sbiw r24,30
 4364 08f8 00F4      		brsh .L242
 4366               	.LM575:
 4367 08fa 8091 0000 		lds r24,rot_flag
 4368 08fe AFAD      		ldd r26,Y+63
 4369 0900 A813      		cpse r26,r24
 4370 0902 00C0      		rjmp .L242
1090:main.c        **** 	  step_timer = 0;
 4372               	.LM576:
 4373 0904 1092 0000 		sts step_timer+1,__zero_reg__
 4374 0908 1092 0000 		sts step_timer,__zero_reg__
1091:main.c        **** 	  steps ++;
 4376               	.LM577:
 4377 090c BFEF      		ldi r27,-1
 4378 090e CB1A      		sub r12,r27
 4379 0910 DB0A      		sbc r13,r27
1092:main.c        **** 	}
1093:main.c        **** 	else {
1094:main.c        **** 	  step_timer = 0;
1095:main.c        **** 	  steps = 1;
1096:main.c        **** 	}
1097:main.c        **** 	
1098:main.c        **** 	if (steps > 500) {
 4381               	.LM578:
 4382 0912 25EF      		ldi r18,-11
 4383 0914 C216      		cp r12,r18
 4384 0916 21E0      		ldi r18,1
 4385 0918 D206      		cpc r13,r18
 4386 091a 00F4      		brsh .L243
 4387 091c 00C0      		rjmp .L350
 4388               	.L242:
1094:main.c        **** 	  steps = 1;
 4390               	.LM579:
 4391 091e 1092 0000 		sts step_timer+1,__zero_reg__
 4392 0922 1092 0000 		sts step_timer,__zero_reg__
1095:main.c        **** 	}
 4394               	.LM580:
 4395 0926 CC24      		clr r12
 4396 0928 C394      		inc r12
 4397 092a D12C      		mov r13,__zero_reg__
 4398 092c 00C0      		rjmp .L245
 4399               	.L243:
1099:main.c        **** 	  if (mode == AM)
 4401               	.LM581:
 4402 092e 8091 0000 		lds r24,mode
 4403 0932 8830      		cpi r24,lo8(8)
 4404 0934 01F4      		brne .L246
1100:main.c        **** 	    freq -= 20;
 4406               	.LM582:
 4407 0936 6091 0000 		lds r22,freq
 4408 093a 7091 0000 		lds r23,freq+1
 4409 093e 8091 0000 		lds r24,freq+2
 4410 0942 9091 0000 		lds r25,freq+3
 4411 0946 20E0      		ldi r18,0
 4412 0948 30E0      		ldi r19,0
 4413 094a 40EA      		ldi r20,lo8(-96)
 4414 094c 51E4      		ldi r21,lo8(65)
 4415 094e 00C0      		rjmp .L340
 4416               	.L246:
1101:main.c        **** 	  else if (mode == FM)
 4418               	.LM583:
 4419 0950 8091 0000 		lds r24,mode
 4420 0954 8A30      		cpi r24,lo8(10)
 4421 0956 01F0      		breq .+2
 4422 0958 00C0      		rjmp .L347
1102:main.c        **** 	    freq -= 50;
 4424               	.LM584:
 4425 095a 6091 0000 		lds r22,freq
 4426 095e 7091 0000 		lds r23,freq+1
 4427 0962 8091 0000 		lds r24,freq+2
 4428 0966 9091 0000 		lds r25,freq+3
 4429 096a 20E0      		ldi r18,0
 4430 096c 30E0      		ldi r19,0
 4431 096e 48E4      		ldi r20,lo8(72)
 4432 0970 52E4      		ldi r21,lo8(66)
 4433 0972 00C0      		rjmp .L340
 4434               	.L350:
1103:main.c        **** 	  else
1104:main.c        **** 	    freq -= 1;
1105:main.c        **** 	}
1106:main.c        **** 	else if (steps > 150) {
 4436               	.LM585:
 4437 0974 87E9      		ldi r24,-105
 4438 0976 C816      		cp r12,r24
 4439 0978 D104      		cpc r13,__zero_reg__
 4440 097a 00F0      		brlo .L245
1107:main.c        **** 	  if (mode == AM)
 4442               	.LM586:
 4443 097c 8091 0000 		lds r24,mode
 4444 0980 8830      		cpi r24,lo8(8)
 4445 0982 01F4      		brne .L248
1108:main.c        **** 	    freq -= 5;
 4447               	.LM587:
 4448 0984 6091 0000 		lds r22,freq
 4449 0988 7091 0000 		lds r23,freq+1
 4450 098c 8091 0000 		lds r24,freq+2
 4451 0990 9091 0000 		lds r25,freq+3
 4452 0994 20E0      		ldi r18,0
 4453 0996 30E0      		ldi r19,0
 4454 0998 40EA      		ldi r20,lo8(-96)
 4455 099a 50E4      		ldi r21,lo8(64)
 4456 099c 00C0      		rjmp .L340
 4457               	.L248:
1109:main.c        **** 	  else if (mode == FM)
 4459               	.LM588:
 4460 099e 8091 0000 		lds r24,mode
 4461 09a2 8A30      		cpi r24,lo8(10)
 4462 09a4 01F4      		brne .L249
1110:main.c        **** 	    freq -= 25;
 4464               	.LM589:
 4465 09a6 6091 0000 		lds r22,freq
 4466 09aa 7091 0000 		lds r23,freq+1
 4467 09ae 8091 0000 		lds r24,freq+2
 4468 09b2 9091 0000 		lds r25,freq+3
 4469 09b6 20E0      		ldi r18,0
 4470 09b8 30E0      		ldi r19,0
 4471 09ba 48EC      		ldi r20,lo8(-56)
 4472 09bc 51E4      		ldi r21,lo8(65)
 4473 09be 00C0      		rjmp .L340
 4474               	.L249:
1111:main.c        **** 	  else
1112:main.c        **** 	    freq -= 0.5;
 4476               	.LM590:
 4477 09c0 6091 0000 		lds r22,freq
 4478 09c4 7091 0000 		lds r23,freq+1
 4479 09c8 8091 0000 		lds r24,freq+2
 4480 09cc 9091 0000 		lds r25,freq+3
 4481 09d0 20E0      		ldi r18,0
 4482 09d2 30E0      		ldi r19,0
 4483 09d4 40E0      		ldi r20,0
 4484 09d6 5FE3      		ldi r21,lo8(63)
 4485 09d8 00C0      		rjmp .L340
 4486               	.L245:
1113:main.c        **** 	}
1114:main.c        **** 	else {
1115:main.c        **** 	  if (mode == AM) {
 4488               	.LM591:
 4489 09da 8091 0000 		lds r24,mode
 4490 09de 8830      		cpi r24,lo8(8)
 4491 09e0 01F4      		brne .L250
1116:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4493               	.LM592:
 4494 09e2 0B9B      		sbis 0x1,3
 4495 09e4 00C0      		rjmp .L251
 4496               	.L347:
1117:main.c        **** 		freq -= 1;
 4498               	.LM593:
 4499 09e6 6091 0000 		lds r22,freq
 4500 09ea 7091 0000 		lds r23,freq+1
 4501 09ee 8091 0000 		lds r24,freq+2
 4502 09f2 9091 0000 		lds r25,freq+3
 4503 09f6 20E0      		ldi r18,0
 4504 09f8 30E0      		ldi r19,0
 4505 09fa 40E8      		ldi r20,lo8(-128)
 4506 09fc 5FE3      		ldi r21,lo8(63)
 4507 09fe 00C0      		rjmp .L340
 4508               	.L251:
1118:main.c        **** 	    else
1119:main.c        **** 	      freq -= 10;
 4510               	.LM594:
 4511 0a00 6091 0000 		lds r22,freq
 4512 0a04 7091 0000 		lds r23,freq+1
 4513 0a08 8091 0000 		lds r24,freq+2
 4514 0a0c 9091 0000 		lds r25,freq+3
 4515 0a10 20E0      		ldi r18,0
 4516 0a12 30E0      		ldi r19,0
 4517 0a14 40E2      		ldi r20,lo8(32)
 4518 0a16 51E4      		ldi r21,lo8(65)
 4519 0a18 00C0      		rjmp .L340
 4520               	.L250:
1120:main.c        **** 	  }
1121:main.c        **** 	  else if (mode == FM)
 4522               	.LM595:
 4523 0a1a 8091 0000 		lds r24,mode
 4524 0a1e 8A30      		cpi r24,lo8(10)
 4525 0a20 01F4      		brne .L252
1122:main.c        **** 	    freq -= 2.5;
 4527               	.LM596:
 4528 0a22 6091 0000 		lds r22,freq
 4529 0a26 7091 0000 		lds r23,freq+1
 4530 0a2a 8091 0000 		lds r24,freq+2
 4531 0a2e 9091 0000 		lds r25,freq+3
 4532 0a32 20E0      		ldi r18,0
 4533 0a34 30E0      		ldi r19,0
 4534 0a36 40E2      		ldi r20,lo8(32)
 4535 0a38 50E4      		ldi r21,lo8(64)
 4536 0a3a 00C0      		rjmp .L340
 4537               	.L252:
1123:main.c        **** 	  else {
1124:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4539               	.LM597:
 4540 0a3c 0B9B      		sbis 0x1,3
 4541 0a3e 00C0      		rjmp .L253
1125:main.c        **** 		freq -= 0.05;
 4543               	.LM598:
 4544 0a40 6091 0000 		lds r22,freq
 4545 0a44 7091 0000 		lds r23,freq+1
 4546 0a48 8091 0000 		lds r24,freq+2
 4547 0a4c 9091 0000 		lds r25,freq+3
 4548 0a50 2DEC      		ldi r18,lo8(-51)
 4549 0a52 3CEC      		ldi r19,lo8(-52)
 4550 0a54 4CE4      		ldi r20,lo8(76)
 4551 0a56 5DE3      		ldi r21,lo8(61)
 4552 0a58 00C0      		rjmp .L340
 4553               	.L253:
1126:main.c        **** 	    else
1127:main.c        **** 	      freq -= 2;
 4555               	.LM599:
 4556 0a5a 6091 0000 		lds r22,freq
 4557 0a5e 7091 0000 		lds r23,freq+1
 4558 0a62 8091 0000 		lds r24,freq+2
 4559 0a66 9091 0000 		lds r25,freq+3
 4560 0a6a 20E0      		ldi r18,0
 4561 0a6c 30E0      		ldi r19,0
 4562 0a6e 40E0      		ldi r20,0
 4563 0a70 50E4      		ldi r21,lo8(64)
 4564               	.L340:
 4565 0a72 0E94 0000 		call __subsf3
 4566 0a76 6093 0000 		sts freq,r22
 4567 0a7a 7093 0000 		sts freq+1,r23
 4568 0a7e 8093 0000 		sts freq+2,r24
 4569 0a82 9093 0000 		sts freq+3,r25
1128:main.c        **** 	  }
1129:main.c        **** 	}
1130:main.c        ****       last_dir = 0x02;
 4571               	.LM600:
 4572 0a86 82E0      		ldi r24,lo8(2)
 4573               	.L228:
1131:main.c        ****       }
1132:main.c        ****       //_delay_ms(30);
1133:main.c        **** 
1134:main.c        ****       rot_flag = 0x00;
 4575               	.LM601:
 4576 0a88 1092 0000 		sts rot_flag,__zero_reg__
 4577 0a8c 8FAF      		std Y+63,r24
 4578 0a8e 00C0      		rjmp .L160
 4579               	.L226:
1135:main.c        ****     }
1136:main.c        ****     else if (vol_flag) {
 4581               	.LM602:
 4582 0a90 8091 0000 		lds r24,vol_flag
 4583 0a94 8823      		tst r24
 4584 0a96 01F4      		brne .+2
 4585 0a98 00C0      		rjmp .L160
1137:main.c        ****       if (vol_timer > 1) {
 4587               	.LM603:
 4588 0a9a 8091 0000 		lds r24,vol_timer
 4589 0a9e 8230      		cpi r24,lo8(2)
 4590 0aa0 00F4      		brsh .+2
 4591 0aa2 00C0      		rjmp .L254
1138:main.c        **** 	if (PINF & (1 << SQUELCH_BUTTON)) {
 4593               	.LM604:
 4594 0aa4 049B      		sbis 0,4
 4595 0aa6 00C0      		rjmp .L255
1139:main.c        **** 	    if (vol_flag == 0x01) {
 4597               	.LM605:
 4598 0aa8 8091 0000 		lds r24,vol_flag
 4599 0aac 8130      		cpi r24,lo8(1)
 4600 0aae 01F4      		brne .L256
1140:main.c        **** 	      if(vol<31)
 4602               	.LM606:
 4603 0ab0 9EE1      		ldi r25,lo8(30)
 4604 0ab2 9A15      		cp r25,r10
 4605 0ab4 00F0      		brlo .L259
1141:main.c        **** 		vol ++; // Higher means lower 
 4607               	.LM607:
 4608 0ab6 A394      		inc r10
 4609 0ab8 00C0      		rjmp .L259
 4610               	.L256:
1142:main.c        **** 	      sprintf(buffer,"Vol %d    ", 31-vol);
1143:main.c        **** 	      lcd_goto(0x40);
1144:main.c        **** 	      lcd_puts(buffer);
1145:main.c        **** 	    }
1146:main.c        **** 	    else if (vol_flag == 0x02) {
 4612               	.LM608:
 4613 0aba 8091 0000 		lds r24,vol_flag
 4614 0abe 8230      		cpi r24,lo8(2)
 4615 0ac0 01F4      		brne .L258
1147:main.c        **** 	      if(vol>0)
 4617               	.LM609:
 4618 0ac2 A110      		cpse r10,__zero_reg__
1148:main.c        **** 		vol --;
 4620               	.LM610:
 4621 0ac4 AA94      		dec r10
 4622               	.L259:
1149:main.c        **** 	      sprintf(buffer,"Vol %d    ", 31-vol);
 4624               	.LM611:
 4625 0ac6 8FE1      		ldi r24,lo8(31)
 4626 0ac8 90E0      		ldi r25,0
 4627 0aca 8A19      		sub r24,r10
 4628 0acc 9109      		sbc r25,__zero_reg__
 4629 0ace 9F93      		push r25
 4630 0ad0 8F93      		push r24
 4631 0ad2 80E0      		ldi r24,lo8(.LC20)
 4632 0ad4 90E0      		ldi r25,hi8(.LC20)
 4633 0ad6 9F93      		push r25
 4634 0ad8 8F93      		push r24
 4635 0ada 1F93      		push r17
 4636 0adc 0F93      		push r16
 4637 0ade 0E94 0000 		call sprintf
1150:main.c        **** 	      lcd_goto(0x40);
 4639               	.LM612:
 4640 0ae2 80E4      		ldi r24,lo8(64)
 4641 0ae4 0E94 0000 		call lcd_goto
1151:main.c        **** 	      lcd_puts(buffer);
 4643               	.LM613:
 4644 0ae8 C801      		movw r24,r16
 4645 0aea 0E94 0000 		call lcd_puts
 4646 0aee 0F90      		pop __tmp_reg__
 4647 0af0 0F90      		pop __tmp_reg__
 4648 0af2 0F90      		pop __tmp_reg__
 4649 0af4 0F90      		pop __tmp_reg__
 4650 0af6 0F90      		pop __tmp_reg__
 4651 0af8 0F90      		pop __tmp_reg__
 4652               	.L258:
1152:main.c        **** 	    }
1153:main.c        **** 	    
1154:main.c        **** 	    err = updateVolumeSquelch(vol, squelch);
 4654               	.LM614:
 4655 0afa 6B2D      		mov r22,r11
 4656 0afc 8A2D      		mov r24,r10
 4657 0afe 0E94 0000 		call updateVolumeSquelch
1155:main.c        **** 	    
1156:main.c        **** 	    if (err) {
 4659               	.LM615:
 4660 0b02 8823      		tst r24
 4661 0b04 01F4      		brne .+2
 4662 0b06 00C0      		rjmp .L260
1157:main.c        **** 	      sprintf(buffer,"Err Vol %x         ",err);
 4664               	.LM616:
 4665 0b08 1F92      		push __zero_reg__
 4666 0b0a 8F93      		push r24
 4667 0b0c 80E0      		ldi r24,lo8(.LC21)
 4668 0b0e 90E0      		ldi r25,hi8(.LC21)
 4669 0b10 00C0      		rjmp .L341
 4670               	.L255:
1158:main.c        **** 	      lcd_goto(0x40);
1159:main.c        **** 	      lcd_puts(buffer);	
1160:main.c        **** 	    }      
1161:main.c        **** 	  }
1162:main.c        **** 	  else {
1163:main.c        **** 	    if (vol_flag == 0x02) {
 4672               	.LM617:
 4673 0b12 8091 0000 		lds r24,vol_flag
 4674 0b16 8230      		cpi r24,lo8(2)
 4675 0b18 01F4      		brne .L261
1164:main.c        **** 	      if(squelch<31)
 4677               	.LM618:
 4678 0b1a AEE1      		ldi r26,lo8(30)
 4679 0b1c AB15      		cp r26,r11
 4680 0b1e 00F0      		brlo .L264
1165:main.c        **** 		squelch ++; 
 4682               	.LM619:
 4683 0b20 B394      		inc r11
 4684 0b22 00C0      		rjmp .L264
 4685               	.L261:
1166:main.c        **** 	      sprintf(buffer,"Sq %d    ", squelch);
1167:main.c        **** 	      lcd_goto(0x40);
1168:main.c        **** 	      lcd_puts(buffer);
1169:main.c        **** 	    }
1170:main.c        **** 	    else if (vol_flag == 0x01) {
 4687               	.LM620:
 4688 0b24 8091 0000 		lds r24,vol_flag
 4689 0b28 8130      		cpi r24,lo8(1)
 4690 0b2a 01F4      		brne .L263
1171:main.c        **** 	      if(squelch>0)
 4692               	.LM621:
 4693 0b2c B110      		cpse r11,__zero_reg__
1172:main.c        **** 		squelch --;
 4695               	.LM622:
 4696 0b2e BA94      		dec r11
 4697               	.L264:
1173:main.c        **** 	      sprintf(buffer,"Sq %d    ", squelch);
 4699               	.LM623:
 4700 0b30 1F92      		push __zero_reg__
 4701 0b32 BF92      		push r11
 4702 0b34 80E0      		ldi r24,lo8(.LC22)
 4703 0b36 90E0      		ldi r25,hi8(.LC22)
 4704 0b38 9F93      		push r25
 4705 0b3a 8F93      		push r24
 4706 0b3c 1F93      		push r17
 4707 0b3e 0F93      		push r16
 4708 0b40 0E94 0000 		call sprintf
1174:main.c        **** 	      lcd_goto(0x40);
 4710               	.LM624:
 4711 0b44 80E4      		ldi r24,lo8(64)
 4712 0b46 0E94 0000 		call lcd_goto
1175:main.c        **** 	      lcd_puts(buffer);
 4714               	.LM625:
 4715 0b4a C801      		movw r24,r16
 4716 0b4c 0E94 0000 		call lcd_puts
 4717 0b50 0F90      		pop __tmp_reg__
 4718 0b52 0F90      		pop __tmp_reg__
 4719 0b54 0F90      		pop __tmp_reg__
 4720 0b56 0F90      		pop __tmp_reg__
 4721 0b58 0F90      		pop __tmp_reg__
 4722 0b5a 0F90      		pop __tmp_reg__
 4723               	.L263:
1176:main.c        **** 	    }
1177:main.c        **** 	    
1178:main.c        **** 	    err = updateVolumeSquelch(vol, squelch);
 4725               	.LM626:
 4726 0b5c 6B2D      		mov r22,r11
 4727 0b5e 8A2D      		mov r24,r10
 4728 0b60 0E94 0000 		call updateVolumeSquelch
1179:main.c        **** 	    
1180:main.c        **** 	    if (err) {
 4730               	.LM627:
 4731 0b64 8823      		tst r24
 4732 0b66 01F0      		breq .L260
1181:main.c        **** 	      sprintf(buffer,"Err Sq %x         ",err);
 4734               	.LM628:
 4735 0b68 1F92      		push __zero_reg__
 4736 0b6a 8F93      		push r24
 4737 0b6c 80E0      		ldi r24,lo8(.LC23)
 4738 0b6e 90E0      		ldi r25,hi8(.LC23)
 4739               	.L341:
 4740 0b70 9F93      		push r25
 4741 0b72 8F93      		push r24
 4742 0b74 1F93      		push r17
 4743 0b76 0F93      		push r16
 4744 0b78 0E94 0000 		call sprintf
1182:main.c        **** 	      lcd_goto(0x40);
 4746               	.LM629:
 4747 0b7c 80E4      		ldi r24,lo8(64)
 4748 0b7e 0E94 0000 		call lcd_goto
1183:main.c        **** 	      lcd_puts(buffer);	
 4750               	.LM630:
 4751 0b82 C801      		movw r24,r16
 4752 0b84 0E94 0000 		call lcd_puts
 4753 0b88 0F90      		pop __tmp_reg__
 4754 0b8a 0F90      		pop __tmp_reg__
 4755 0b8c 0F90      		pop __tmp_reg__
 4756 0b8e 0F90      		pop __tmp_reg__
 4757 0b90 0F90      		pop __tmp_reg__
 4758 0b92 0F90      		pop __tmp_reg__
 4759               	.L260:
1184:main.c        **** 	    }      
1185:main.c        **** 	  }
1186:main.c        **** 	vol_timer = 0;
 4761               	.LM631:
 4762 0b94 1092 0000 		sts vol_timer,__zero_reg__
 4763               	.L254:
1187:main.c        ****       }
1188:main.c        ****       vol_flag = 0x00;
 4765               	.LM632:
 4766 0b98 1092 0000 		sts vol_flag,__zero_reg__
 4767 0b9c 00C0      		rjmp .L160
 4782               	.Lscope31:
 4783               		.section	.progmem.data,"a",@progbits
 4786               	string_intro_row2.2454:
 4787 0000 5374 6172 		.string	"Starting radio"
 4787      7469 6E67 
 4787      2072 6164 
 4787      696F 00
 4790               	string_intro_row1.2453:
 4791 000f 2A2A 2A20 		.string	"*** SM6VFZ"
 4791      534D 3656 
 4791      465A 00
 4792               		.local	ftw_botbot.2410
 4793               		.comm	ftw_botbot.2410,4,1
 4794               		.local	ftw_bottop.2409
 4795               		.comm	ftw_bottop.2409,4,1
 4796               		.local	ftw_topbot.2408
 4797               		.comm	ftw_topbot.2408,4,1
 4798               		.local	ftw_toptop.2407
 4799               		.comm	ftw_toptop.2407,4,1
 4800               	.global	freq_offset
 4801               		.section .bss
 4804               	freq_offset:
 4805 0000 0000      		.zero	2
 4806               	.global	clar
 4809               	clar:
 4810 0002 00        		.zero	1
 4811               		.comm	freq,4,1
 4812               		.comm	rffe_rx_att,1,1
 4813               		.comm	rx_att,1,1
 4814               	.global	pll_n
 4817               	pll_n:
 4818 0003 0000      		.zero	2
 4819               		.comm	tx,2,1
 4820               		.comm	bandf,2,1
 4821               	.global	vol_timer
 4822               		.data
 4825               	vol_timer:
 4826 0000 FF        		.byte	-1
 4827               	.global	band_timer
 4830               	band_timer:
 4831 0001 FF        		.byte	-1
 4832               		.comm	tx_att,1,1
 4833               		.comm	band,1,1
 4834               		.comm	mode,1,1
 4835               		.comm	step_timer,2,1
 4836               		.comm	vol_flag,1,1
 4837               		.comm	timer_flag,1,1
 4838               		.comm	band_flag,1,1
 4839               		.comm	mode_flag,1,1
 4840               		.comm	rot_flag,1,1
 4860               		.text
 4862               	.Letext0:
 4863               		.ident	"GCC: (GNU) 4.9.2"
 4864               	.global __do_copy_data
 4865               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccETJSu9.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccETJSu9.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccETJSu9.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccETJSu9.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccETJSu9.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccETJSu9.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccETJSu9.s:125    .text:0000000000000000 __vector_15
                            *COM*:0000000000000002 step_timer
     /tmp/ccETJSu9.s:172    .text:0000000000000040 __vector_12
                            *COM*:0000000000000001 timer_flag
     /tmp/ccETJSu9.s:204    .text:000000000000005e __vector_3
                            *COM*:0000000000000001 rot_flag
     /tmp/ccETJSu9.s:295    .text:00000000000000a4 __vector_4
     /tmp/ccETJSu9.s:386    .text:00000000000000ea __vector_5
     /tmp/ccETJSu9.s:483    .text:000000000000013c __vector_6
     /tmp/ccETJSu9.s:580    .text:000000000000018e __vector_7
                            *COM*:0000000000000001 vol_flag
     /tmp/ccETJSu9.s:677    .text:00000000000001e0 __vector_8
     /tmp/ccETJSu9.s:774    .text:0000000000000232 TWIinit
     /tmp/ccETJSu9.s:796    .text:0000000000000240 TWIStart
     /tmp/ccETJSu9.s:823    .text:0000000000000250 TWIStop
     /tmp/ccETJSu9.s:842    .text:0000000000000258 TWIWrite
     /tmp/ccETJSu9.s:872    .text:000000000000026c TWIReadACK
     /tmp/ccETJSu9.s:901    .text:0000000000000280 TWIReadNACK
     /tmp/ccETJSu9.s:930    .text:0000000000000294 TWIGetStatus
     /tmp/ccETJSu9.s:952    .text:000000000000029c TWI_write_byte
     /tmp/ccETJSu9.s:1082   .text:000000000000030c TWI_read_byte
     /tmp/ccETJSu9.s:1192   .text:0000000000000370 TWI_write_word
     /tmp/ccETJSu9.s:1360   .text:0000000000000400 TWI_write_3bytes
     /tmp/ccETJSu9.s:1545   .text:00000000000004a6 TWI_write_4bytes
     /tmp/ccETJSu9.s:1749   .text:0000000000000560 TWI_write_5bytes
     /tmp/ccETJSu9.s:1981   .text:000000000000062e lcd_freq
                            *COM*:0000000000000001 mode
                            *COM*:0000000000000004 freq
     /tmp/ccETJSu9.s:4804   .bss:0000000000000000 freq_offset
     /tmp/ccETJSu9.s:4809   .bss:0000000000000002 clar
     /tmp/ccETJSu9.s:2167   .text:0000000000000784 updateVolumeSquelch
     /tmp/ccETJSu9.s:2197   .text:000000000000079e readClar
     /tmp/ccETJSu9.s:2217   .text:00000000000007a4 updateRFFE
                            *COM*:0000000000000001 rx_att
     /tmp/ccETJSu9.s:4817   .bss:0000000000000003 pll_n
                            *COM*:0000000000000002 tx
                            *COM*:0000000000000002 bandf
     /tmp/ccETJSu9.s:2296   .text:0000000000000806 updateFreq
     /tmp/ccETJSu9.s:4797   .bss:0000000000000011 ftw_toptop.2407
     /tmp/ccETJSu9.s:4795   .bss:000000000000000d ftw_topbot.2408
     /tmp/ccETJSu9.s:4793   .bss:0000000000000009 ftw_bottop.2409
                             .bss:0000000000000005 ftw_botbot.2410
     /tmp/ccETJSu9.s:2546   .text:00000000000009ea updateSettings
                            *COM*:0000000000000001 tx_att
     /tmp/ccETJSu9.s:2694   .text:0000000000000ab4 adcInit
     /tmp/ccETJSu9.s:2719   .text:0000000000000ac0 Timer0Init
     /tmp/ccETJSu9.s:2746   .text:0000000000000ad0 Timer1Init
     /tmp/ccETJSu9.s:2824   .text.startup:0000000000000000 main
     /tmp/ccETJSu9.s:4790   .progmem.data:000000000000000f string_intro_row1.2453
     /tmp/ccETJSu9.s:4786   .progmem.data:0000000000000000 string_intro_row2.2454
                            *COM*:0000000000000001 mode_flag
                            *COM*:0000000000000001 band_flag
                            *COM*:0000000000000001 band
                            *COM*:0000000000000001 rffe_rx_att
     /tmp/ccETJSu9.s:4825   .data:0000000000000000 vol_timer
     /tmp/ccETJSu9.s:4830   .data:0000000000000001 band_timer

UNDEFINED SYMBOLS
__divsf3
__floatsisf
__addsf3
__fixsfsi
round
lcd_goto
fmod
floor
sprintf
lcd_puts
strcpy
__subsf3
__mulsf3
__fixunssfsi
__nesf2
__ltsf2
lcd_init
lcd_clrscr
strcpy_P
__do_copy_data
__do_clear_bss
