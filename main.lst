   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 123               	.global	__vector_15
 125               	__vector_15:
   1:main.c        **** #define F_CPU 1000000UL
   2:main.c        **** 
   3:main.c        **** #include <avr/io.h>
   4:main.c        **** #include <avr/wdt.h>
   5:main.c        **** #include <avr/sleep.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #include <util/delay.h>
   8:main.c        **** #include <math.h>
   9:main.c        **** #include <string.h>
  10:main.c        **** #include <stdio.h>
  11:main.c        **** #include <stdint.h>
  12:main.c        **** #include <stdlib.h>
  13:main.c        **** #include <stdbool.h>
  14:main.c        **** #include <avr/pgmspace.h>
  15:main.c        **** #include "hd44780.h"
  16:main.c        **** #include "build_settings.h"
  17:main.c        **** 
  18:main.c        **** #define fpga_addr 0x23
  19:main.c        **** #define pll_addr 0x22
  20:main.c        **** 
  21:main.c        **** #define ROT1_A PE4
  22:main.c        **** #define ROT1_B PE5
  23:main.c        **** #define ROT2_A PD2
  24:main.c        **** #define ROT2_B PD3
  25:main.c        **** #define ROT_BUTTON PE3
  26:main.c        **** #define SQUELCH_BUTTON PF4
  27:main.c        **** #define MENU_BUTTON PF2
  28:main.c        **** #define MODE_BUTTON PF1
  29:main.c        **** #define BAND_BUTTON PF0
  30:main.c        **** #define VOLROT_A PE6
  31:main.c        **** #define VOLROT_B PE7
  32:main.c        **** #define VOL_BUTTON PF4
  33:main.c        **** #define FREQ_BUTTON PE3
  34:main.c        **** #define CLAR_POT PF3
  35:main.c        **** #define MUTE PE0
  36:main.c        **** 
  37:main.c        **** #define LED_RED PD6
  38:main.c        **** #define LED_GREEN PD5
  39:main.c        **** 
  40:main.c        **** #define LSB 0x01
  41:main.c        **** #define LSBN 0x02
  42:main.c        **** #define USB 0x03
  43:main.c        **** #define USBN 0x04
  44:main.c        **** #define CW 0x05
  45:main.c        **** #define CWN 0x06
  46:main.c        **** #define CWNN 0x07
  47:main.c        **** #define AM 0x08
  48:main.c        **** #define AMN 0x09
  49:main.c        **** #define FM 0x0A
  50:main.c        **** 
  51:main.c        **** #define lcd_freq() \
  52:main.c        ****   lcd_goto(0x04);  \
  53:main.c        ****   sprintf(buffer,"%d,%06.2f     ",(int)floor(freq/1000+freq_offset),fmod(freq,1000));  \
  54:main.c        ****   lcd_puts(buffer);  \
  55:main.c        ****   lcd_goto(0x0f);  \
  56:main.c        ****   if (clar > 10)  \
  57:main.c        ****     sprintf(buffer,"+");  \
  58:main.c        ****   else if (clar < -10)  \
  59:main.c        ****     sprintf(buffer,"-");  \
  60:main.c        ****   else  \
  61:main.c        ****     sprintf(buffer," ");  \
  62:main.c        ****   lcd_puts(buffer)
  63:main.c        **** 
  64:main.c        **** 
  65:main.c        **** volatile uint8_t rot_flag, mode_flag, band_flag, timer_flag, vol_flag;
  66:main.c        **** volatile uint16_t step_timer;
  67:main.c        **** volatile uint8_t mode;
  68:main.c        **** volatile uint8_t band;
  69:main.c        **** volatile uint8_t tx_att;
  70:main.c        **** volatile uint8_t band_timer = 255, vol_timer = 255;
  71:main.c        **** volatile uint16_t bandf, tx, pll_n = 0;
  72:main.c        **** volatile uint8_t rx_att;
  73:main.c        **** volatile bool rffe_rx_att;
  74:main.c        **** 
  75:main.c        **** ISR(TIMER0_COMP_vect) {
 127               	.LM0:
 128               	.LFBB1:
 129 0000 1F92      		push r1
 130 0002 0F92      		push r0
 131 0004 0FB6      		in r0,__SREG__
 132 0006 0F92      		push r0
 133 0008 1124      		clr __zero_reg__
 134 000a 2F93      		push r18
 135 000c 8F93      		push r24
 136 000e 9F93      		push r25
 137               	/* prologue: Signal */
 138               	/* frame size = 0 */
 139               	/* stack size = 6 */
 140               	.L__stack_usage = 6
  76:main.c        ****   if (step_timer < 500)
 142               	.LM1:
 143 0010 8091 0000 		lds r24,step_timer
 144 0014 9091 0000 		lds r25,step_timer+1
 145 0018 843F      		cpi r24,-12
 146 001a 9140      		sbci r25,1
 147 001c 00F4      		brsh .L1
  77:main.c        ****     step_timer ++;
 149               	.LM2:
 150 001e 8091 0000 		lds r24,step_timer
 151 0022 9091 0000 		lds r25,step_timer+1
 152 0026 0196      		adiw r24,1
 153 0028 9093 0000 		sts step_timer+1,r25
 154 002c 8093 0000 		sts step_timer,r24
 155               	.L1:
 156               	/* epilogue start */
  78:main.c        **** }
 158               	.LM3:
 159 0030 9F91      		pop r25
 160 0032 8F91      		pop r24
 161 0034 2F91      		pop r18
 162 0036 0F90      		pop r0
 163 0038 0FBE      		out __SREG__,r0
 164 003a 0F90      		pop r0
 165 003c 1F90      		pop r1
 166 003e 1895      		reti
 168               	.Lscope1:
 170               	.global	__vector_12
 172               	__vector_12:
  79:main.c        **** 
  80:main.c        **** ISR(TIMER1_COMPA_vect) {
 174               	.LM4:
 175               	.LFBB2:
 176 0040 1F92      		push r1
 177 0042 0F92      		push r0
 178 0044 0FB6      		in r0,__SREG__
 179 0046 0F92      		push r0
 180 0048 1124      		clr __zero_reg__
 181 004a 8F93      		push r24
 182               	/* prologue: Signal */
 183               	/* frame size = 0 */
 184               	/* stack size = 4 */
 185               	.L__stack_usage = 4
  81:main.c        ****   timer_flag = 1;
 187               	.LM5:
 188 004c 81E0      		ldi r24,lo8(1)
 189 004e 8093 0000 		sts timer_flag,r24
 190               	/* epilogue start */
  82:main.c        ****   
  83:main.c        **** }
 192               	.LM6:
 193 0052 8F91      		pop r24
 194 0054 0F90      		pop r0
 195 0056 0FBE      		out __SREG__,r0
 196 0058 0F90      		pop r0
 197 005a 1F90      		pop r1
 198 005c 1895      		reti
 200               	.Lscope2:
 202               	.global	__vector_3
 204               	__vector_3:
  84:main.c        **** 
  85:main.c        **** 
  86:main.c        **** ISR(INT2_vect) {  // falling level on INT2
 206               	.LM7:
 207               	.LFBB3:
 208 005e 1F92      		push r1
 209 0060 0F92      		push r0
 210 0062 0FB6      		in r0,__SREG__
 211 0064 0F92      		push r0
 212 0066 1124      		clr __zero_reg__
 213 0068 8F93      		push r24
 214               	/* prologue: Signal */
 215               	/* frame size = 0 */
 216               	/* stack size = 4 */
 217               	.L__stack_usage = 4
  87:main.c        ****   if(!(PIND & (1 << ROT2_A))) {
 219               	.LM8:
 220 006a 8299      		sbic 0x10,2
 221 006c 00C0      		rjmp .L5
 222               	.LBB231:
 223               	.LBB232:
 225               	.Ltext1:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/lib/avr/include/util/delay.h **** 
 155:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/lib/avr/include/util/delay.h **** 
 158:/usr/lib/avr/include/util/delay.h **** 	#else
 159:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 160:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/lib/avr/include/util/delay.h **** 	#endif
 162:/usr/lib/avr/include/util/delay.h **** 
 163:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/lib/avr/include/util/delay.h **** 
 165:/usr/lib/avr/include/util/delay.h **** #else
 166:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/lib/avr/include/util/delay.h **** 
 234:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/lib/avr/include/util/delay.h **** 
 237:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/lib/avr/include/util/delay.h **** 
 240:/usr/lib/avr/include/util/delay.h **** 	#else
 241:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 242:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/lib/avr/include/util/delay.h **** 	#endif
 244:/usr/lib/avr/include/util/delay.h **** 
 245:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 227               	.LM9:
 228 006e 86E0      		ldi r24,lo8(6)
 229 0070 8A95      	1:	dec r24
 230 0072 01F4      		brne 1b
 231 0074 00C0      		rjmp .
 232               	.LBE232:
 233               	.LBE231:
 235               	.Ltext2:
  88:main.c        ****     _delay_us(20);
  89:main.c        ****     if ((PIND & (1 << ROT2_B))) {
 237               	.LM10:
 238 0076 839B      		sbis 0x10,3
 239 0078 00C0      		rjmp .L5
 240               	.LBB233:
 241               	.LBB234:
 243               	.Ltext3:
 245               	.LM11:
 246 007a 86E0      		ldi r24,lo8(6)
 247 007c 8A95      	1:	dec r24
 248 007e 01F4      		brne 1b
 249 0080 00C0      		rjmp .
 250               	.LBE234:
 251               	.LBE233:
 253               	.Ltext4:
  90:main.c        ****       _delay_us(20);
  91:main.c        ****       if (!(PIND & (1 << ROT2_A)) && (PIND & (1 << ROT2_B))) {
 255               	.LM12:
 256 0082 8299      		sbic 0x10,2
 257 0084 00C0      		rjmp .L5
 259               	.LM13:
 260 0086 839B      		sbis 0x10,3
 261 0088 00C0      		rjmp .L5
 262               	.LBB235:
 263               	.LBB236:
 265               	.Ltext5:
 267               	.LM14:
 268 008a 81E2      		ldi r24,lo8(33)
 269 008c 8A95      	1:	dec r24
 270 008e 01F4      		brne 1b
 271 0090 0000      		nop
 272               	.LBE236:
 273               	.LBE235:
 275               	.Ltext6:
  92:main.c        **** 	_delay_us(100);
  93:main.c        **** 	rot_flag = 0x01;
 277               	.LM15:
 278 0092 81E0      		ldi r24,lo8(1)
 279 0094 8093 0000 		sts rot_flag,r24
 280               	.L5:
 281               	/* epilogue start */
  94:main.c        ****       }
  95:main.c        ****     }
  96:main.c        ****   }
  97:main.c        **** }
 283               	.LM16:
 284 0098 8F91      		pop r24
 285 009a 0F90      		pop r0
 286 009c 0FBE      		out __SREG__,r0
 287 009e 0F90      		pop r0
 288 00a0 1F90      		pop r1
 289 00a2 1895      		reti
 291               	.Lscope3:
 293               	.global	__vector_4
 295               	__vector_4:
  98:main.c        **** 
  99:main.c        **** ISR(INT3_vect) {  // falling level on INT3
 297               	.LM17:
 298               	.LFBB4:
 299 00a4 1F92      		push r1
 300 00a6 0F92      		push r0
 301 00a8 0FB6      		in r0,__SREG__
 302 00aa 0F92      		push r0
 303 00ac 1124      		clr __zero_reg__
 304 00ae 8F93      		push r24
 305               	/* prologue: Signal */
 306               	/* frame size = 0 */
 307               	/* stack size = 4 */
 308               	.L__stack_usage = 4
 100:main.c        ****   if (!(PIND & (1 << ROT2_B))) {
 310               	.LM18:
 311 00b0 8399      		sbic 0x10,3
 312 00b2 00C0      		rjmp .L15
 313               	.LBB237:
 314               	.LBB238:
 316               	.Ltext7:
 318               	.LM19:
 319 00b4 86E0      		ldi r24,lo8(6)
 320 00b6 8A95      	1:	dec r24
 321 00b8 01F4      		brne 1b
 322 00ba 00C0      		rjmp .
 323               	.LBE238:
 324               	.LBE237:
 326               	.Ltext8:
 101:main.c        ****    _delay_us(20);
 102:main.c        ****     if ((PIND & (1 << ROT2_A))) {
 328               	.LM20:
 329 00bc 829B      		sbis 0x10,2
 330 00be 00C0      		rjmp .L15
 331               	.LBB239:
 332               	.LBB240:
 334               	.Ltext9:
 336               	.LM21:
 337 00c0 86E0      		ldi r24,lo8(6)
 338 00c2 8A95      	1:	dec r24
 339 00c4 01F4      		brne 1b
 340 00c6 00C0      		rjmp .
 341               	.LBE240:
 342               	.LBE239:
 344               	.Ltext10:
 103:main.c        ****       _delay_us(20);
 104:main.c        ****       if ((PIND & (1 << ROT2_A)) && !(PIND & (1 << ROT2_B))) {
 346               	.LM22:
 347 00c8 829B      		sbis 0x10,2
 348 00ca 00C0      		rjmp .L15
 350               	.LM23:
 351 00cc 8399      		sbic 0x10,3
 352 00ce 00C0      		rjmp .L15
 353               	.LBB241:
 354               	.LBB242:
 356               	.Ltext11:
 358               	.LM24:
 359 00d0 81E2      		ldi r24,lo8(33)
 360 00d2 8A95      	1:	dec r24
 361 00d4 01F4      		brne 1b
 362 00d6 0000      		nop
 363               	.LBE242:
 364               	.LBE241:
 366               	.Ltext12:
 105:main.c        **** 	_delay_us(100);
 106:main.c        **** 	rot_flag = 0x02;
 368               	.LM25:
 369 00d8 82E0      		ldi r24,lo8(2)
 370 00da 8093 0000 		sts rot_flag,r24
 371               	.L15:
 372               	/* epilogue start */
 107:main.c        ****       }
 108:main.c        ****     }
 109:main.c        ****   }
 110:main.c        **** }
 374               	.LM26:
 375 00de 8F91      		pop r24
 376 00e0 0F90      		pop r0
 377 00e2 0FBE      		out __SREG__,r0
 378 00e4 0F90      		pop r0
 379 00e6 1F90      		pop r1
 380 00e8 1895      		reti
 382               	.Lscope4:
 384               	.global	__vector_5
 386               	__vector_5:
 111:main.c        **** 
 112:main.c        **** ISR(INT4_vect) {  // falling level on INT4
 388               	.LM27:
 389               	.LFBB5:
 390 00ea 1F92      		push r1
 391 00ec 0F92      		push r0
 392 00ee 0FB6      		in r0,__SREG__
 393 00f0 0F92      		push r0
 394 00f2 1124      		clr __zero_reg__
 395 00f4 8F93      		push r24
 396 00f6 9F93      		push r25
 397               	/* prologue: Signal */
 398               	/* frame size = 0 */
 399               	/* stack size = 5 */
 400               	.L__stack_usage = 5
 113:main.c        ****   if(!(PINE & (1 << ROT1_A))) {
 402               	.LM28:
 403 00f8 0C99      		sbic 0x1,4
 404 00fa 00C0      		rjmp .L25
 405               	.LBB243:
 406               	.LBB244:
 408               	.Ltext13:
 410               	.LM29:
 411 00fc 83EF      		ldi r24,lo8(499)
 412 00fe 91E0      		ldi r25,hi8(499)
 413 0100 0197      	1:	sbiw r24,1
 414 0102 01F4      		brne 1b
 415 0104 00C0      		rjmp .
 416 0106 0000      		nop
 417               	.LBE244:
 418               	.LBE243:
 420               	.Ltext14:
 114:main.c        ****     _delay_us(2000);
 115:main.c        ****     if ((PINE & (1 << ROT1_B))) {
 422               	.LM30:
 423 0108 0D9B      		sbis 0x1,5
 424 010a 00C0      		rjmp .L25
 425               	.LBB245:
 426               	.LBB246:
 428               	.Ltext15:
 430               	.LM31:
 431 010c 83EF      		ldi r24,lo8(499)
 432 010e 91E0      		ldi r25,hi8(499)
 433 0110 0197      	1:	sbiw r24,1
 434 0112 01F4      		brne 1b
 435 0114 00C0      		rjmp .
 436 0116 0000      		nop
 437               	.LBE246:
 438               	.LBE245:
 440               	.Ltext16:
 116:main.c        ****       _delay_us(2000);
 117:main.c        ****       if (!(PINE & (1 << ROT1_A)) && (PINE & (1 << ROT1_B))) {
 442               	.LM32:
 443 0118 0C99      		sbic 0x1,4
 444 011a 00C0      		rjmp .L25
 446               	.LM33:
 447 011c 0D9B      		sbis 0x1,5
 448 011e 00C0      		rjmp .L25
 449               	.LBB247:
 450               	.LBB248:
 452               	.Ltext17:
 454               	.LM34:
 455 0120 91E2      		ldi r25,lo8(33)
 456 0122 9A95      	1:	dec r25
 457 0124 01F4      		brne 1b
 458 0126 0000      		nop
 459               	.LBE248:
 460               	.LBE247:
 462               	.Ltext18:
 118:main.c        **** 	_delay_us(100);
 119:main.c        **** 	rot_flag = 0x01;
 464               	.LM35:
 465 0128 81E0      		ldi r24,lo8(1)
 466 012a 8093 0000 		sts rot_flag,r24
 467               	.L25:
 468               	/* epilogue start */
 120:main.c        ****       }
 121:main.c        ****     }
 122:main.c        ****   }
 123:main.c        **** }
 470               	.LM36:
 471 012e 9F91      		pop r25
 472 0130 8F91      		pop r24
 473 0132 0F90      		pop r0
 474 0134 0FBE      		out __SREG__,r0
 475 0136 0F90      		pop r0
 476 0138 1F90      		pop r1
 477 013a 1895      		reti
 479               	.Lscope5:
 481               	.global	__vector_6
 483               	__vector_6:
 124:main.c        **** 
 125:main.c        **** ISR(INT5_vect) {  // falling level on INT5
 485               	.LM37:
 486               	.LFBB6:
 487 013c 1F92      		push r1
 488 013e 0F92      		push r0
 489 0140 0FB6      		in r0,__SREG__
 490 0142 0F92      		push r0
 491 0144 1124      		clr __zero_reg__
 492 0146 8F93      		push r24
 493 0148 9F93      		push r25
 494               	/* prologue: Signal */
 495               	/* frame size = 0 */
 496               	/* stack size = 5 */
 497               	.L__stack_usage = 5
 126:main.c        ****   if (!(PINE & (1 << ROT1_B))) {
 499               	.LM38:
 500 014a 0D99      		sbic 0x1,5
 501 014c 00C0      		rjmp .L35
 502               	.LBB249:
 503               	.LBB250:
 505               	.Ltext19:
 507               	.LM39:
 508 014e 83EF      		ldi r24,lo8(499)
 509 0150 91E0      		ldi r25,hi8(499)
 510 0152 0197      	1:	sbiw r24,1
 511 0154 01F4      		brne 1b
 512 0156 00C0      		rjmp .
 513 0158 0000      		nop
 514               	.LBE250:
 515               	.LBE249:
 517               	.Ltext20:
 127:main.c        ****    _delay_us(2000);
 128:main.c        ****     if ((PINE & (1 << ROT1_A))) {
 519               	.LM40:
 520 015a 0C9B      		sbis 0x1,4
 521 015c 00C0      		rjmp .L35
 522               	.LBB251:
 523               	.LBB252:
 525               	.Ltext21:
 527               	.LM41:
 528 015e 83EF      		ldi r24,lo8(499)
 529 0160 91E0      		ldi r25,hi8(499)
 530 0162 0197      	1:	sbiw r24,1
 531 0164 01F4      		brne 1b
 532 0166 00C0      		rjmp .
 533 0168 0000      		nop
 534               	.LBE252:
 535               	.LBE251:
 537               	.Ltext22:
 129:main.c        ****       _delay_us(2000);
 130:main.c        ****       if ((PINE & (1 << ROT1_A)) && !(PINE & (1 << ROT1_B))) {
 539               	.LM42:
 540 016a 0C9B      		sbis 0x1,4
 541 016c 00C0      		rjmp .L35
 543               	.LM43:
 544 016e 0D99      		sbic 0x1,5
 545 0170 00C0      		rjmp .L35
 546               	.LBB253:
 547               	.LBB254:
 549               	.Ltext23:
 551               	.LM44:
 552 0172 91E2      		ldi r25,lo8(33)
 553 0174 9A95      	1:	dec r25
 554 0176 01F4      		brne 1b
 555 0178 0000      		nop
 556               	.LBE254:
 557               	.LBE253:
 559               	.Ltext24:
 131:main.c        **** 	_delay_us(100);
 132:main.c        **** 	rot_flag = 0x02;
 561               	.LM45:
 562 017a 82E0      		ldi r24,lo8(2)
 563 017c 8093 0000 		sts rot_flag,r24
 564               	.L35:
 565               	/* epilogue start */
 133:main.c        ****       }
 134:main.c        ****     }
 135:main.c        ****   }
 136:main.c        **** }
 567               	.LM46:
 568 0180 9F91      		pop r25
 569 0182 8F91      		pop r24
 570 0184 0F90      		pop r0
 571 0186 0FBE      		out __SREG__,r0
 572 0188 0F90      		pop r0
 573 018a 1F90      		pop r1
 574 018c 1895      		reti
 576               	.Lscope6:
 578               	.global	__vector_7
 580               	__vector_7:
 137:main.c        **** 
 138:main.c        **** ISR(INT6_vect) {  // falling level on INT6
 582               	.LM47:
 583               	.LFBB7:
 584 018e 1F92      		push r1
 585 0190 0F92      		push r0
 586 0192 0FB6      		in r0,__SREG__
 587 0194 0F92      		push r0
 588 0196 1124      		clr __zero_reg__
 589 0198 8F93      		push r24
 590 019a 9F93      		push r25
 591               	/* prologue: Signal */
 592               	/* frame size = 0 */
 593               	/* stack size = 5 */
 594               	.L__stack_usage = 5
 139:main.c        ****   if(!(PINE & (1 << VOLROT_A))) {
 596               	.LM48:
 597 019c 0E99      		sbic 0x1,6
 598 019e 00C0      		rjmp .L45
 599               	.LBB255:
 600               	.LBB256:
 602               	.Ltext25:
 604               	.LM49:
 605 01a0 83EF      		ldi r24,lo8(499)
 606 01a2 91E0      		ldi r25,hi8(499)
 607 01a4 0197      	1:	sbiw r24,1
 608 01a6 01F4      		brne 1b
 609 01a8 00C0      		rjmp .
 610 01aa 0000      		nop
 611               	.LBE256:
 612               	.LBE255:
 614               	.Ltext26:
 140:main.c        ****     _delay_us(2000);
 141:main.c        ****     if ((PINE & (1 << VOLROT_B))) {
 616               	.LM50:
 617 01ac 0F9B      		sbis 0x1,7
 618 01ae 00C0      		rjmp .L45
 619               	.LBB257:
 620               	.LBB258:
 622               	.Ltext27:
 624               	.LM51:
 625 01b0 83EF      		ldi r24,lo8(499)
 626 01b2 91E0      		ldi r25,hi8(499)
 627 01b4 0197      	1:	sbiw r24,1
 628 01b6 01F4      		brne 1b
 629 01b8 00C0      		rjmp .
 630 01ba 0000      		nop
 631               	.LBE258:
 632               	.LBE257:
 634               	.Ltext28:
 142:main.c        ****       _delay_us(2000);
 143:main.c        ****       if (!(PINE & (1 << VOLROT_A)) && (PINE & (1 << VOLROT_B))) {
 636               	.LM52:
 637 01bc 0E99      		sbic 0x1,6
 638 01be 00C0      		rjmp .L45
 640               	.LM53:
 641 01c0 0F9B      		sbis 0x1,7
 642 01c2 00C0      		rjmp .L45
 643               	.LBB259:
 644               	.LBB260:
 646               	.Ltext29:
 648               	.LM54:
 649 01c4 91E2      		ldi r25,lo8(33)
 650 01c6 9A95      	1:	dec r25
 651 01c8 01F4      		brne 1b
 652 01ca 0000      		nop
 653               	.LBE260:
 654               	.LBE259:
 656               	.Ltext30:
 144:main.c        **** 	_delay_us(100);
 145:main.c        **** 	vol_flag = 0x02;
 658               	.LM55:
 659 01cc 82E0      		ldi r24,lo8(2)
 660 01ce 8093 0000 		sts vol_flag,r24
 661               	.L45:
 662               	/* epilogue start */
 146:main.c        ****       }
 147:main.c        ****     }
 148:main.c        ****   }
 149:main.c        **** }
 664               	.LM56:
 665 01d2 9F91      		pop r25
 666 01d4 8F91      		pop r24
 667 01d6 0F90      		pop r0
 668 01d8 0FBE      		out __SREG__,r0
 669 01da 0F90      		pop r0
 670 01dc 1F90      		pop r1
 671 01de 1895      		reti
 673               	.Lscope7:
 675               	.global	__vector_8
 677               	__vector_8:
 150:main.c        **** 
 151:main.c        **** ISR(INT7_vect) {  // falling level on INT7
 679               	.LM57:
 680               	.LFBB8:
 681 01e0 1F92      		push r1
 682 01e2 0F92      		push r0
 683 01e4 0FB6      		in r0,__SREG__
 684 01e6 0F92      		push r0
 685 01e8 1124      		clr __zero_reg__
 686 01ea 8F93      		push r24
 687 01ec 9F93      		push r25
 688               	/* prologue: Signal */
 689               	/* frame size = 0 */
 690               	/* stack size = 5 */
 691               	.L__stack_usage = 5
 152:main.c        ****   if (!(PINE & (1 << VOLROT_B))) {
 693               	.LM58:
 694 01ee 0F99      		sbic 0x1,7
 695 01f0 00C0      		rjmp .L49
 696               	.LBB261:
 697               	.LBB262:
 699               	.Ltext31:
 701               	.LM59:
 702 01f2 83EF      		ldi r24,lo8(499)
 703 01f4 91E0      		ldi r25,hi8(499)
 704 01f6 0197      	1:	sbiw r24,1
 705 01f8 01F4      		brne 1b
 706 01fa 00C0      		rjmp .
 707 01fc 0000      		nop
 708               	.LBE262:
 709               	.LBE261:
 711               	.Ltext32:
 153:main.c        ****     _delay_us(2000);
 154:main.c        ****     if ((PINE & (1 << VOLROT_A))) {
 713               	.LM60:
 714 01fe 0E9B      		sbis 0x1,6
 715 0200 00C0      		rjmp .L49
 716               	.LBB263:
 717               	.LBB264:
 719               	.Ltext33:
 721               	.LM61:
 722 0202 83EF      		ldi r24,lo8(499)
 723 0204 91E0      		ldi r25,hi8(499)
 724 0206 0197      	1:	sbiw r24,1
 725 0208 01F4      		brne 1b
 726 020a 00C0      		rjmp .
 727 020c 0000      		nop
 728               	.LBE264:
 729               	.LBE263:
 731               	.Ltext34:
 155:main.c        ****       _delay_us(2000);
 156:main.c        ****       if ((PINE & (1 << VOLROT_A)) && !(PINE & (1 << VOLROT_B))) {
 733               	.LM62:
 734 020e 0E9B      		sbis 0x1,6
 735 0210 00C0      		rjmp .L49
 737               	.LM63:
 738 0212 0F99      		sbic 0x1,7
 739 0214 00C0      		rjmp .L49
 740               	.LBB265:
 741               	.LBB266:
 743               	.Ltext35:
 745               	.LM64:
 746 0216 91E2      		ldi r25,lo8(33)
 747 0218 9A95      	1:	dec r25
 748 021a 01F4      		brne 1b
 749 021c 0000      		nop
 750               	.LBE266:
 751               	.LBE265:
 753               	.Ltext36:
 157:main.c        **** 	_delay_us(100);
 158:main.c        **** 	vol_flag = 0x01;
 755               	.LM65:
 756 021e 81E0      		ldi r24,lo8(1)
 757 0220 8093 0000 		sts vol_flag,r24
 758               	.L49:
 759               	/* epilogue start */
 159:main.c        ****       }
 160:main.c        ****     }
 161:main.c        ****   }
 162:main.c        **** }
 761               	.LM66:
 762 0224 9F91      		pop r25
 763 0226 8F91      		pop r24
 764 0228 0F90      		pop r0
 765 022a 0FBE      		out __SREG__,r0
 766 022c 0F90      		pop r0
 767 022e 1F90      		pop r1
 768 0230 1895      		reti
 770               	.Lscope8:
 772               	.global	TWIinit
 774               	TWIinit:
 163:main.c        **** 
 164:main.c        **** void TWIinit(void) {
 776               	.LM67:
 777               	.LFBB9:
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780               	/* stack size = 0 */
 781               	.L__stack_usage = 0
 165:main.c        ****   TWBR = 0x45;
 783               	.LM68:
 784 0232 85E4      		ldi r24,lo8(69)
 785 0234 8093 7000 		sts 112,r24
 166:main.c        ****   TWCR = (1 << TWEN);
 787               	.LM69:
 788 0238 84E0      		ldi r24,lo8(4)
 789 023a 8093 7400 		sts 116,r24
 790 023e 0895      		ret
 792               	.Lscope9:
 794               	.global	TWIStart
 796               	TWIStart:
 167:main.c        **** }
 168:main.c        **** 
 169:main.c        **** void TWIStart(void) {
 798               	.LM70:
 799               	.LFBB10:
 800               	/* prologue: function */
 801               	/* frame size = 0 */
 802               	/* stack size = 0 */
 803               	.L__stack_usage = 0
 170:main.c        ****   TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 805               	.LM71:
 806 0240 84EA      		ldi r24,lo8(-92)
 807 0242 8093 7400 		sts 116,r24
 808               	.L61:
 171:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 810               	.LM72:
 811 0246 8091 7400 		lds r24,116
 812 024a 87FF      		sbrs r24,7
 813 024c 00C0      		rjmp .L61
 814               	/* epilogue start */
 172:main.c        **** }
 816               	.LM73:
 817 024e 0895      		ret
 819               	.Lscope10:
 821               	.global	TWIStop
 823               	TWIStop:
 173:main.c        **** 
 174:main.c        **** void TWIStop(void) {
 825               	.LM74:
 826               	.LFBB11:
 827               	/* prologue: function */
 828               	/* frame size = 0 */
 829               	/* stack size = 0 */
 830               	.L__stack_usage = 0
 175:main.c        ****   TWCR = (1<<TWINT)|(1<<TWSTO)|(1<<TWEN);
 832               	.LM75:
 833 0250 84E9      		ldi r24,lo8(-108)
 834 0252 8093 7400 		sts 116,r24
 835 0256 0895      		ret
 837               	.Lscope11:
 840               	.global	TWIWrite
 842               	TWIWrite:
 176:main.c        **** }
 177:main.c        **** 
 178:main.c        **** void TWIWrite(uint8_t u8data) {
 844               	.LM76:
 845               	.LFBB12:
 846               	/* prologue: function */
 847               	/* frame size = 0 */
 848               	/* stack size = 0 */
 849               	.L__stack_usage = 0
 179:main.c        ****   TWDR = u8data;
 851               	.LM77:
 852 0258 8093 7300 		sts 115,r24
 180:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN);
 854               	.LM78:
 855 025c 84E8      		ldi r24,lo8(-124)
 856 025e 8093 7400 		sts 116,r24
 857               	.L65:
 181:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 859               	.LM79:
 860 0262 8091 7400 		lds r24,116
 861 0266 87FF      		sbrs r24,7
 862 0268 00C0      		rjmp .L65
 863               	/* epilogue start */
 182:main.c        **** }
 865               	.LM80:
 866 026a 0895      		ret
 868               	.Lscope12:
 870               	.global	TWIReadACK
 872               	TWIReadACK:
 183:main.c        **** 
 184:main.c        **** uint8_t TWIReadACK(void) {
 874               	.LM81:
 875               	.LFBB13:
 876               	/* prologue: function */
 877               	/* frame size = 0 */
 878               	/* stack size = 0 */
 879               	.L__stack_usage = 0
 185:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
 881               	.LM82:
 882 026c 84EC      		ldi r24,lo8(-60)
 883 026e 8093 7400 		sts 116,r24
 884               	.L68:
 186:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 886               	.LM83:
 887 0272 8091 7400 		lds r24,116
 888 0276 87FF      		sbrs r24,7
 889 0278 00C0      		rjmp .L68
 187:main.c        ****   return TWDR;
 891               	.LM84:
 892 027a 8091 7300 		lds r24,115
 188:main.c        **** }
 894               	.LM85:
 895 027e 0895      		ret
 897               	.Lscope13:
 899               	.global	TWIReadNACK
 901               	TWIReadNACK:
 189:main.c        **** 
 190:main.c        **** //read byte with NACK
 191:main.c        **** uint8_t TWIReadNACK(void) {
 903               	.LM86:
 904               	.LFBB14:
 905               	/* prologue: function */
 906               	/* frame size = 0 */
 907               	/* stack size = 0 */
 908               	.L__stack_usage = 0
 192:main.c        ****   TWCR = (1<<TWINT)|(1<<TWEN);
 910               	.LM87:
 911 0280 84E8      		ldi r24,lo8(-124)
 912 0282 8093 7400 		sts 116,r24
 913               	.L71:
 193:main.c        ****   while ((TWCR & (1<<TWINT)) == 0);
 915               	.LM88:
 916 0286 8091 7400 		lds r24,116
 917 028a 87FF      		sbrs r24,7
 918 028c 00C0      		rjmp .L71
 194:main.c        ****   return TWDR;
 920               	.LM89:
 921 028e 8091 7300 		lds r24,115
 195:main.c        **** }
 923               	.LM90:
 924 0292 0895      		ret
 926               	.Lscope14:
 928               	.global	TWIGetStatus
 930               	TWIGetStatus:
 196:main.c        **** 
 197:main.c        **** uint8_t TWIGetStatus(void) {
 932               	.LM91:
 933               	.LFBB15:
 934               	/* prologue: function */
 935               	/* frame size = 0 */
 936               	/* stack size = 0 */
 937               	.L__stack_usage = 0
 198:main.c        ****   uint8_t status;
 199:main.c        ****   //mask status
 200:main.c        ****   status = TWSR & 0xF8;
 939               	.LM92:
 940 0294 8091 7100 		lds r24,113
 201:main.c        ****   return status;
 202:main.c        **** }
 942               	.LM93:
 943 0298 887F      		andi r24,lo8(-8)
 944 029a 0895      		ret
 946               	.Lscope15:
 950               	.global	TWI_write_byte
 952               	TWI_write_byte:
 203:main.c        **** 
 204:main.c        **** uint8_t TWI_write_byte(uint8_t addr, uint8_t data) {
 954               	.LM94:
 955               	.LFBB16:
 956 029c 1F93      		push r17
 957 029e CF93      		push r28
 958 02a0 DF93      		push r29
 959 02a2 1F92      		push __zero_reg__
 960 02a4 CDB7      		in r28,__SP_L__
 961 02a6 DEB7      		in r29,__SP_H__
 962               	/* prologue: function */
 963               	/* frame size = 1 */
 964               	/* stack size = 4 */
 965               	.L__stack_usage = 4
 966 02a8 162F      		mov r17,r22
 205:main.c        **** 
 206:main.c        ****   TWIStart();
 968               	.LM95:
 969 02aa 8983      		std Y+1,r24
 970 02ac 0E94 0000 		call TWIStart
 971               	.LBB267:
 972               	.LBB268:
 200:main.c        ****   return status;
 974               	.LM96:
 975 02b0 9091 7100 		lds r25,113
 976 02b4 987F      		andi r25,lo8(-8)
 977               	.LBE268:
 978               	.LBE267:
 207:main.c        ****   if (TWIGetStatus() != 0x08) {
 980               	.LM97:
 981 02b6 8981      		ldd r24,Y+1
 982 02b8 9830      		cpi r25,lo8(8)
 983 02ba 01F0      		breq .L75
 984               	.LBB269:
 985               	.LBB270:
 175:main.c        **** }
 987               	.LM98:
 988 02bc 84E9      		ldi r24,lo8(-108)
 989 02be 8093 7400 		sts 116,r24
 990               	.LBE270:
 991               	.LBE269:
 208:main.c        ****     TWIStop();
 209:main.c        ****     return 0x01;
 993               	.LM99:
 994 02c2 81E0      		ldi r24,lo8(1)
 995 02c4 00C0      		rjmp .L76
 996               	.L75:
 210:main.c        ****   }
 211:main.c        ****   TWIWrite(addr << 1);
 998               	.LM100:
 999 02c6 880F      		lsl r24
 1000 02c8 0E94 0000 		call TWIWrite
 1001               	.LBB271:
 1002               	.LBB272:
 200:main.c        ****   return status;
 1004               	.LM101:
 1005 02cc 9091 7100 		lds r25,113
 1006 02d0 987F      		andi r25,lo8(-8)
 1007               	.LBE272:
 1008               	.LBE271:
 212:main.c        ****   if (TWIGetStatus() != 0x18) {
 1010               	.LM102:
 1011 02d2 9831      		cpi r25,lo8(24)
 1012 02d4 01F0      		breq .L77
 1013               	.LBB273:
 1014               	.LBB274:
 175:main.c        **** }
 1016               	.LM103:
 1017 02d6 84E9      		ldi r24,lo8(-108)
 1018 02d8 8093 7400 		sts 116,r24
 1019               	.LBE274:
 1020               	.LBE273:
 213:main.c        ****     TWIStop();
 214:main.c        ****     return 0x02;
 1022               	.LM104:
 1023 02dc 82E0      		ldi r24,lo8(2)
 1024 02de 00C0      		rjmp .L76
 1025               	.L77:
 215:main.c        ****   }  
 216:main.c        ****   TWIWrite(data);
 1027               	.LM105:
 1028 02e0 812F      		mov r24,r17
 1029 02e2 0E94 0000 		call TWIWrite
 1030               	.LBB275:
 1031               	.LBB276:
 200:main.c        ****   return status;
 1033               	.LM106:
 1034 02e6 8091 7100 		lds r24,113
 1035 02ea 887F      		andi r24,lo8(-8)
 1036               	.LBE276:
 1037               	.LBE275:
 217:main.c        ****   if (TWIGetStatus() != 0x28) {
 1039               	.LM107:
 1040 02ec 8832      		cpi r24,lo8(40)
 1041 02ee 01F0      		breq .L78
 1042               	.LBB277:
 1043               	.LBB278:
 175:main.c        **** }
 1045               	.LM108:
 1046 02f0 84E9      		ldi r24,lo8(-108)
 1047 02f2 8093 7400 		sts 116,r24
 1048               	.LBE278:
 1049               	.LBE277:
 218:main.c        ****     TWIStop();
 219:main.c        ****     return 0x03;
 1051               	.LM109:
 1052 02f6 83E0      		ldi r24,lo8(3)
 1053 02f8 00C0      		rjmp .L76
 1054               	.L78:
 1055               	.LBB279:
 1056               	.LBB280:
 175:main.c        **** }
 1058               	.LM110:
 1059 02fa 84E9      		ldi r24,lo8(-108)
 1060 02fc 8093 7400 		sts 116,r24
 1061               	.LBE280:
 1062               	.LBE279:
 220:main.c        ****   }
 221:main.c        ****   TWIStop();
 222:main.c        ****   return 0x00;
 1064               	.LM111:
 1065 0300 80E0      		ldi r24,0
 1066               	.L76:
 1067               	/* epilogue start */
 223:main.c        **** }
 1069               	.LM112:
 1070 0302 0F90      		pop __tmp_reg__
 1071 0304 DF91      		pop r29
 1072 0306 CF91      		pop r28
 1073 0308 1F91      		pop r17
 1074 030a 0895      		ret
 1076               	.Lscope16:
 1080               	.global	TWI_read_byte
 1082               	TWI_read_byte:
 224:main.c        **** 
 225:main.c        **** uint8_t TWI_read_byte(uint8_t addr, uint8_t* data) {
 1084               	.LM113:
 1085               	.LFBB17:
 1086 030c 0F93      		push r16
 1087 030e 1F93      		push r17
 1088 0310 CF93      		push r28
 1089 0312 DF93      		push r29
 1090 0314 1F92      		push __zero_reg__
 1091 0316 CDB7      		in r28,__SP_L__
 1092 0318 DEB7      		in r29,__SP_H__
 1093               	/* prologue: function */
 1094               	/* frame size = 1 */
 1095               	/* stack size = 5 */
 1096               	.L__stack_usage = 5
 1097 031a 8B01      		movw r16,r22
 226:main.c        **** 
 227:main.c        ****   TWIStart();
 1099               	.LM114:
 1100 031c 8983      		std Y+1,r24
 1101 031e 0E94 0000 		call TWIStart
 1102               	.LBB301:
 1103               	.LBB302:
 200:main.c        ****   return status;
 1105               	.LM115:
 1106 0322 9091 7100 		lds r25,113
 1107 0326 987F      		andi r25,lo8(-8)
 1108               	.LBE302:
 1109               	.LBE301:
 228:main.c        ****   if (TWIGetStatus() != 0x08) {
 1111               	.LM116:
 1112 0328 8981      		ldd r24,Y+1
 1113 032a 9830      		cpi r25,lo8(8)
 1114 032c 01F0      		breq .L80
 1115               	.LBB303:
 1116               	.LBB304:
 175:main.c        **** }
 1118               	.LM117:
 1119 032e 84E9      		ldi r24,lo8(-108)
 1120 0330 8093 7400 		sts 116,r24
 1121               	.LBE304:
 1122               	.LBE303:
 229:main.c        ****     TWIStop();
 230:main.c        ****     return 0x01;
 1124               	.LM118:
 1125 0334 81E0      		ldi r24,lo8(1)
 1126 0336 00C0      		rjmp .L81
 1127               	.L80:
 231:main.c        ****   }
 232:main.c        ****   TWIWrite((addr << 1) | 0x01);
 1129               	.LM119:
 1130 0338 880F      		lsl r24
 1131 033a 8160      		ori r24,lo8(1)
 1132 033c 0E94 0000 		call TWIWrite
 1133               	.LBB305:
 1134               	.LBB306:
 200:main.c        ****   return status;
 1136               	.LM120:
 1137 0340 8091 7100 		lds r24,113
 1138 0344 887F      		andi r24,lo8(-8)
 1139               	.LBE306:
 1140               	.LBE305:
 233:main.c        ****   if (TWIGetStatus() != 0x40) {
 1142               	.LM121:
 1143 0346 8034      		cpi r24,lo8(64)
 1144 0348 01F0      		breq .L82
 1145               	.LBB307:
 1146               	.LBB308:
 175:main.c        **** }
 1148               	.LM122:
 1149 034a 84E9      		ldi r24,lo8(-108)
 1150 034c 8093 7400 		sts 116,r24
 1151               	.LBE308:
 1152               	.LBE307:
 234:main.c        ****     TWIStop();
 235:main.c        ****     return 0x02;
 1154               	.LM123:
 1155 0350 82E0      		ldi r24,lo8(2)
 1156 0352 00C0      		rjmp .L81
 1157               	.L82:
 1158               	.LBB309:
 1159               	.LBB310:
 236:main.c        ****   }
 237:main.c        ****   *data = TWIReadNACK();
 1161               	.LM124:
 1162 0354 0E94 0000 		call TWIReadNACK
 1163 0358 F801      		movw r30,r16
 1164 035a 8083      		st Z,r24
 1165               	.LBB311:
 1166               	.LBB312:
 175:main.c        **** }
 1168               	.LM125:
 1169 035c 84E9      		ldi r24,lo8(-108)
 1170 035e 8093 7400 		sts 116,r24
 1171 0362 80E0      		ldi r24,0
 1172               	.L81:
 1173               	/* epilogue start */
 1174               	.LBE312:
 1175               	.LBE311:
 1176               	.LBE310:
 1177               	.LBE309:
 238:main.c        ****   TWIStop();
 239:main.c        ****   return 0x00;
 240:main.c        **** }
 1179               	.LM126:
 1180 0364 0F90      		pop __tmp_reg__
 1181 0366 DF91      		pop r29
 1182 0368 CF91      		pop r28
 1183 036a 1F91      		pop r17
 1184 036c 0F91      		pop r16
 1185 036e 0895      		ret
 1187               	.Lscope17:
 1190               	.global	TWI_write_word
 1192               	TWI_write_word:
 241:main.c        **** 
 242:main.c        **** uint8_t TWI_write_word(uint8_t addr, uint16_t data_word) {
 1194               	.LM127:
 1195               	.LFBB18:
 1196 0370 0F93      		push r16
 1197 0372 1F93      		push r17
 1198 0374 CF93      		push r28
 1199 0376 DF93      		push r29
 1200 0378 1F92      		push __zero_reg__
 1201 037a CDB7      		in r28,__SP_L__
 1202 037c DEB7      		in r29,__SP_H__
 1203               	/* prologue: function */
 1204               	/* frame size = 1 */
 1205               	/* stack size = 5 */
 1206               	.L__stack_usage = 5
 1207 037e 162F      		mov r17,r22
 1208 0380 072F      		mov r16,r23
 243:main.c        **** 
 244:main.c        ****   TWIStart();
 1210               	.LM128:
 1211 0382 8983      		std Y+1,r24
 1212 0384 0E94 0000 		call TWIStart
 1213               	.LBB345:
 1214               	.LBB346:
 200:main.c        ****   return status;
 1216               	.LM129:
 1217 0388 9091 7100 		lds r25,113
 1218 038c 987F      		andi r25,lo8(-8)
 1219               	.LBE346:
 1220               	.LBE345:
 245:main.c        ****   if (TWIGetStatus() != 0x08) {
 1222               	.LM130:
 1223 038e 8981      		ldd r24,Y+1
 1224 0390 9830      		cpi r25,lo8(8)
 1225 0392 01F0      		breq .L84
 1226               	.LBB347:
 1227               	.LBB348:
 175:main.c        **** }
 1229               	.LM131:
 1230 0394 84E9      		ldi r24,lo8(-108)
 1231 0396 8093 7400 		sts 116,r24
 1232               	.LBE348:
 1233               	.LBE347:
 246:main.c        ****     TWIStop();
 247:main.c        ****     return 0x01;
 1235               	.LM132:
 1236 039a 81E0      		ldi r24,lo8(1)
 1237 039c 00C0      		rjmp .L85
 1238               	.L84:
 248:main.c        ****   }
 249:main.c        ****   TWIWrite(addr << 1);
 1240               	.LM133:
 1241 039e 880F      		lsl r24
 1242 03a0 0E94 0000 		call TWIWrite
 1243               	.LBB349:
 1244               	.LBB350:
 200:main.c        ****   return status;
 1246               	.LM134:
 1247 03a4 9091 7100 		lds r25,113
 1248 03a8 987F      		andi r25,lo8(-8)
 1249               	.LBE350:
 1250               	.LBE349:
 250:main.c        ****   if (TWIGetStatus() != 0x18) {
 1252               	.LM135:
 1253 03aa 9831      		cpi r25,lo8(24)
 1254 03ac 01F0      		breq .L86
 1255               	.LBB351:
 1256               	.LBB352:
 175:main.c        **** }
 1258               	.LM136:
 1259 03ae 84E9      		ldi r24,lo8(-108)
 1260 03b0 8093 7400 		sts 116,r24
 1261               	.LBE352:
 1262               	.LBE351:
 251:main.c        ****     TWIStop();
 252:main.c        ****     return 0x02;  
 1264               	.LM137:
 1265 03b4 82E0      		ldi r24,lo8(2)
 1266 03b6 00C0      		rjmp .L85
 1267               	.L86:
 253:main.c        ****   }
 254:main.c        ****   TWIWrite((uint8_t)((data_word & 0xFF00) >> 8));
 1269               	.LM138:
 1270 03b8 802F      		mov r24,r16
 1271 03ba 0E94 0000 		call TWIWrite
 1272               	.LBB353:
 1273               	.LBB354:
 200:main.c        ****   return status;
 1275               	.LM139:
 1276 03be 9091 7100 		lds r25,113
 1277 03c2 987F      		andi r25,lo8(-8)
 1278               	.LBE354:
 1279               	.LBE353:
 255:main.c        ****   if (TWIGetStatus() != 0x28) {
 1281               	.LM140:
 1282 03c4 9832      		cpi r25,lo8(40)
 1283 03c6 01F0      		breq .L87
 1284               	.LBB355:
 1285               	.LBB356:
 175:main.c        **** }
 1287               	.LM141:
 1288 03c8 84E9      		ldi r24,lo8(-108)
 1289 03ca 8093 7400 		sts 116,r24
 1290               	.LBE356:
 1291               	.LBE355:
 256:main.c        ****     TWIStop();
 257:main.c        ****     return 0x03;
 1293               	.LM142:
 1294 03ce 83E0      		ldi r24,lo8(3)
 1295 03d0 00C0      		rjmp .L85
 1296               	.L87:
 1297               	.LBB357:
 1298               	.LBB358:
 258:main.c        ****   }
 259:main.c        ****   TWIWrite((uint8_t)(data_word & 0x00FF));
 1300               	.LM143:
 1301 03d2 812F      		mov r24,r17
 1302 03d4 0E94 0000 		call TWIWrite
 1303               	.LBB359:
 1304               	.LBB360:
 200:main.c        ****   return status;
 1306               	.LM144:
 1307 03d8 8091 7100 		lds r24,113
 1308 03dc 887F      		andi r24,lo8(-8)
 1309               	.LBE360:
 1310               	.LBE359:
 260:main.c        ****   if (TWIGetStatus() != 0x28) {
 1312               	.LM145:
 1313 03de 8832      		cpi r24,lo8(40)
 1314 03e0 01F0      		breq .L88
 1315               	.LBB361:
 1316               	.LBB362:
 175:main.c        **** }
 1318               	.LM146:
 1319 03e2 84E9      		ldi r24,lo8(-108)
 1320 03e4 8093 7400 		sts 116,r24
 1321               	.LBE362:
 1322               	.LBE361:
 261:main.c        ****     TWIStop();
 262:main.c        ****     return 0x04;
 1324               	.LM147:
 1325 03e8 84E0      		ldi r24,lo8(4)
 1326 03ea 00C0      		rjmp .L85
 1327               	.L88:
 1328               	.LBB363:
 1329               	.LBB364:
 175:main.c        **** }
 1331               	.LM148:
 1332 03ec 84E9      		ldi r24,lo8(-108)
 1333 03ee 8093 7400 		sts 116,r24
 1334               	.LBE364:
 1335               	.LBE363:
 263:main.c        ****   }
 264:main.c        ****   TWIStop();
 265:main.c        ****   return 0x00;
 1337               	.LM149:
 1338 03f2 80E0      		ldi r24,0
 1339               	.L85:
 1340               	/* epilogue start */
 1341               	.LBE358:
 1342               	.LBE357:
 266:main.c        **** }
 1344               	.LM150:
 1345 03f4 0F90      		pop __tmp_reg__
 1346 03f6 DF91      		pop r29
 1347 03f8 CF91      		pop r28
 1348 03fa 1F91      		pop r17
 1349 03fc 0F91      		pop r16
 1350 03fe 0895      		ret
 1352               	.Lscope18:
 1358               	.global	TWI_write_3bytes
 1360               	TWI_write_3bytes:
 267:main.c        **** 
 268:main.c        **** uint8_t TWI_write_3bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3) {
 1362               	.LM151:
 1363               	.LFBB19:
 1364 0400 FF92      		push r15
 1365 0402 0F93      		push r16
 1366 0404 1F93      		push r17
 1367 0406 CF93      		push r28
 1368 0408 DF93      		push r29
 1369 040a 1F92      		push __zero_reg__
 1370 040c CDB7      		in r28,__SP_L__
 1371 040e DEB7      		in r29,__SP_H__
 1372               	/* prologue: function */
 1373               	/* frame size = 1 */
 1374               	/* stack size = 6 */
 1375               	.L__stack_usage = 6
 1376 0410 162F      		mov r17,r22
 1377 0412 042F      		mov r16,r20
 1378 0414 F22E      		mov r15,r18
 269:main.c        **** 
 270:main.c        ****   TWIStart();
 1380               	.LM152:
 1381 0416 8983      		std Y+1,r24
 1382 0418 0E94 0000 		call TWIStart
 1383               	.LBB365:
 1384               	.LBB366:
 200:main.c        ****   return status;
 1386               	.LM153:
 1387 041c 9091 7100 		lds r25,113
 1388 0420 987F      		andi r25,lo8(-8)
 1389               	.LBE366:
 1390               	.LBE365:
 271:main.c        ****   if (TWIGetStatus() != 0x08) {
 1392               	.LM154:
 1393 0422 8981      		ldd r24,Y+1
 1394 0424 9830      		cpi r25,lo8(8)
 1395 0426 01F0      		breq .L90
 1396               	.LBB367:
 1397               	.LBB368:
 175:main.c        **** }
 1399               	.LM155:
 1400 0428 84E9      		ldi r24,lo8(-108)
 1401 042a 8093 7400 		sts 116,r24
 1402               	.LBE368:
 1403               	.LBE367:
 272:main.c        ****     TWIStop();
 273:main.c        ****     return 0x01;
 1405               	.LM156:
 1406 042e 81E0      		ldi r24,lo8(1)
 1407 0430 00C0      		rjmp .L91
 1408               	.L90:
 274:main.c        ****   }
 275:main.c        ****   TWIWrite(addr << 1);
 1410               	.LM157:
 1411 0432 880F      		lsl r24
 1412 0434 0E94 0000 		call TWIWrite
 1413               	.LBB369:
 1414               	.LBB370:
 200:main.c        ****   return status;
 1416               	.LM158:
 1417 0438 9091 7100 		lds r25,113
 1418 043c 987F      		andi r25,lo8(-8)
 1419               	.LBE370:
 1420               	.LBE369:
 276:main.c        ****   if (TWIGetStatus() != 0x18) {
 1422               	.LM159:
 1423 043e 9831      		cpi r25,lo8(24)
 1424 0440 01F0      		breq .L92
 1425               	.LBB371:
 1426               	.LBB372:
 175:main.c        **** }
 1428               	.LM160:
 1429 0442 84E9      		ldi r24,lo8(-108)
 1430 0444 8093 7400 		sts 116,r24
 1431               	.LBE372:
 1432               	.LBE371:
 277:main.c        ****     TWIStop();
 278:main.c        ****     return 0x02;  
 1434               	.LM161:
 1435 0448 82E0      		ldi r24,lo8(2)
 1436 044a 00C0      		rjmp .L91
 1437               	.L92:
 279:main.c        ****   }
 280:main.c        ****   TWIWrite(byte1);
 1439               	.LM162:
 1440 044c 812F      		mov r24,r17
 1441 044e 0E94 0000 		call TWIWrite
 1442               	.LBB373:
 1443               	.LBB374:
 200:main.c        ****   return status;
 1445               	.LM163:
 1446 0452 9091 7100 		lds r25,113
 1447 0456 987F      		andi r25,lo8(-8)
 1448               	.LBE374:
 1449               	.LBE373:
 281:main.c        ****   if (TWIGetStatus() != 0x28) {
 1451               	.LM164:
 1452 0458 9832      		cpi r25,lo8(40)
 1453 045a 01F0      		breq .L93
 1454               	.LBB375:
 1455               	.LBB376:
 175:main.c        **** }
 1457               	.LM165:
 1458 045c 84E9      		ldi r24,lo8(-108)
 1459 045e 8093 7400 		sts 116,r24
 1460               	.LBE376:
 1461               	.LBE375:
 282:main.c        ****     TWIStop();
 283:main.c        ****     return 0x03;
 1463               	.LM166:
 1464 0462 83E0      		ldi r24,lo8(3)
 1465 0464 00C0      		rjmp .L91
 1466               	.L93:
 284:main.c        ****   }
 285:main.c        ****   TWIWrite(byte2);
 1468               	.LM167:
 1469 0466 802F      		mov r24,r16
 1470 0468 0E94 0000 		call TWIWrite
 1471               	.LBB377:
 1472               	.LBB378:
 200:main.c        ****   return status;
 1474               	.LM168:
 1475 046c 9091 7100 		lds r25,113
 1476 0470 987F      		andi r25,lo8(-8)
 1477               	.LBE378:
 1478               	.LBE377:
 286:main.c        ****   if (TWIGetStatus() != 0x28) {
 1480               	.LM169:
 1481 0472 9832      		cpi r25,lo8(40)
 1482 0474 01F4      		brne .L96
 287:main.c        ****     TWIStop();
 288:main.c        ****     return 0x04;
 289:main.c        ****   }
 290:main.c        ****   TWIWrite(byte3);
 1484               	.LM170:
 1485 0476 8F2D      		mov r24,r15
 1486 0478 0E94 0000 		call TWIWrite
 1487               	.LBB379:
 1488               	.LBB380:
 200:main.c        ****   return status;
 1490               	.LM171:
 1491 047c 8091 7100 		lds r24,113
 1492 0480 887F      		andi r24,lo8(-8)
 1493               	.LBE380:
 1494               	.LBE379:
 291:main.c        ****   if (TWIGetStatus() != 0x28) {
 1496               	.LM172:
 1497 0482 8832      		cpi r24,lo8(40)
 1498 0484 01F0      		breq .L95
 1499               	.L96:
 1500               	.LBB381:
 1501               	.LBB382:
 175:main.c        **** }
 1503               	.LM173:
 1504 0486 84E9      		ldi r24,lo8(-108)
 1505 0488 8093 7400 		sts 116,r24
 1506               	.LBE382:
 1507               	.LBE381:
 292:main.c        ****     TWIStop();
 293:main.c        ****     return 0x04;
 1509               	.LM174:
 1510 048c 84E0      		ldi r24,lo8(4)
 1511 048e 00C0      		rjmp .L91
 1512               	.L95:
 1513               	.LBB383:
 1514               	.LBB384:
 175:main.c        **** }
 1516               	.LM175:
 1517 0490 84E9      		ldi r24,lo8(-108)
 1518 0492 8093 7400 		sts 116,r24
 1519               	.LBE384:
 1520               	.LBE383:
 294:main.c        ****   }
 295:main.c        ****   TWIStop();
 296:main.c        ****   return 0x00;
 1522               	.LM176:
 1523 0496 80E0      		ldi r24,0
 1524               	.L91:
 1525               	/* epilogue start */
 297:main.c        **** }
 1527               	.LM177:
 1528 0498 0F90      		pop __tmp_reg__
 1529 049a DF91      		pop r29
 1530 049c CF91      		pop r28
 1531 049e 1F91      		pop r17
 1532 04a0 0F91      		pop r16
 1533 04a2 FF90      		pop r15
 1534 04a4 0895      		ret
 1536               	.Lscope19:
 1543               	.global	TWI_write_4bytes
 1545               	TWI_write_4bytes:
 298:main.c        **** 
 299:main.c        **** uint8_t TWI_write_4bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3, uint8_t byte4) 
 1547               	.LM178:
 1548               	.LFBB20:
 1549 04a6 EF92      		push r14
 1550 04a8 FF92      		push r15
 1551 04aa 0F93      		push r16
 1552 04ac 1F93      		push r17
 1553 04ae CF93      		push r28
 1554 04b0 DF93      		push r29
 1555 04b2 1F92      		push __zero_reg__
 1556 04b4 CDB7      		in r28,__SP_L__
 1557 04b6 DEB7      		in r29,__SP_H__
 1558               	/* prologue: function */
 1559               	/* frame size = 1 */
 1560               	/* stack size = 7 */
 1561               	.L__stack_usage = 7
 1562 04b8 162F      		mov r17,r22
 1563 04ba F42E      		mov r15,r20
 1564 04bc E22E      		mov r14,r18
 300:main.c        **** 
 301:main.c        ****   TWIStart();
 1566               	.LM179:
 1567 04be 8983      		std Y+1,r24
 1568 04c0 0E94 0000 		call TWIStart
 1569               	.LBB385:
 1570               	.LBB386:
 200:main.c        ****   return status;
 1572               	.LM180:
 1573 04c4 9091 7100 		lds r25,113
 1574 04c8 987F      		andi r25,lo8(-8)
 1575               	.LBE386:
 1576               	.LBE385:
 302:main.c        ****   if (TWIGetStatus() != 0x08) {
 1578               	.LM181:
 1579 04ca 8981      		ldd r24,Y+1
 1580 04cc 9830      		cpi r25,lo8(8)
 1581 04ce 01F0      		breq .L98
 1582               	.LBB387:
 1583               	.LBB388:
 175:main.c        **** }
 1585               	.LM182:
 1586 04d0 84E9      		ldi r24,lo8(-108)
 1587 04d2 8093 7400 		sts 116,r24
 1588               	.LBE388:
 1589               	.LBE387:
 303:main.c        ****     TWIStop();
 304:main.c        ****     return 0x01;
 1591               	.LM183:
 1592 04d6 81E0      		ldi r24,lo8(1)
 1593 04d8 00C0      		rjmp .L99
 1594               	.L98:
 305:main.c        ****   }
 306:main.c        ****   TWIWrite(addr << 1);
 1596               	.LM184:
 1597 04da 880F      		lsl r24
 1598 04dc 0E94 0000 		call TWIWrite
 1599               	.LBB389:
 1600               	.LBB390:
 200:main.c        ****   return status;
 1602               	.LM185:
 1603 04e0 9091 7100 		lds r25,113
 1604 04e4 987F      		andi r25,lo8(-8)
 1605               	.LBE390:
 1606               	.LBE389:
 307:main.c        ****   if (TWIGetStatus() != 0x18) {
 1608               	.LM186:
 1609 04e6 9831      		cpi r25,lo8(24)
 1610 04e8 01F0      		breq .L100
 1611               	.LBB391:
 1612               	.LBB392:
 175:main.c        **** }
 1614               	.LM187:
 1615 04ea 84E9      		ldi r24,lo8(-108)
 1616 04ec 8093 7400 		sts 116,r24
 1617               	.LBE392:
 1618               	.LBE391:
 308:main.c        ****     TWIStop();
 309:main.c        ****     return 0x02;  
 1620               	.LM188:
 1621 04f0 82E0      		ldi r24,lo8(2)
 1622 04f2 00C0      		rjmp .L99
 1623               	.L100:
 310:main.c        ****   }
 311:main.c        ****   TWIWrite(byte1);
 1625               	.LM189:
 1626 04f4 812F      		mov r24,r17
 1627 04f6 0E94 0000 		call TWIWrite
 1628               	.LBB393:
 1629               	.LBB394:
 200:main.c        ****   return status;
 1631               	.LM190:
 1632 04fa 9091 7100 		lds r25,113
 1633 04fe 987F      		andi r25,lo8(-8)
 1634               	.LBE394:
 1635               	.LBE393:
 312:main.c        ****   if (TWIGetStatus() != 0x28) {
 1637               	.LM191:
 1638 0500 9832      		cpi r25,lo8(40)
 1639 0502 01F0      		breq .L101
 1640               	.LBB395:
 1641               	.LBB396:
 175:main.c        **** }
 1643               	.LM192:
 1644 0504 84E9      		ldi r24,lo8(-108)
 1645 0506 8093 7400 		sts 116,r24
 1646               	.LBE396:
 1647               	.LBE395:
 313:main.c        ****     TWIStop();
 314:main.c        ****     return 0x03;
 1649               	.LM193:
 1650 050a 83E0      		ldi r24,lo8(3)
 1651 050c 00C0      		rjmp .L99
 1652               	.L101:
 315:main.c        ****   }
 316:main.c        ****   TWIWrite(byte2);
 1654               	.LM194:
 1655 050e 8F2D      		mov r24,r15
 1656 0510 0E94 0000 		call TWIWrite
 1657               	.LBB397:
 1658               	.LBB398:
 200:main.c        ****   return status;
 1660               	.LM195:
 1661 0514 9091 7100 		lds r25,113
 1662 0518 987F      		andi r25,lo8(-8)
 1663               	.LBE398:
 1664               	.LBE397:
 317:main.c        ****   if (TWIGetStatus() != 0x28) {
 1666               	.LM196:
 1667 051a 9832      		cpi r25,lo8(40)
 1668 051c 01F4      		brne .L106
 318:main.c        ****     TWIStop();
 319:main.c        ****     return 0x04;
 320:main.c        ****   }
 321:main.c        ****   TWIWrite(byte3);
 1670               	.LM197:
 1671 051e 8E2D      		mov r24,r14
 1672 0520 0E94 0000 		call TWIWrite
 1673               	.LBB399:
 1674               	.LBB400:
 200:main.c        ****   return status;
 1676               	.LM198:
 1677 0524 9091 7100 		lds r25,113
 1678 0528 987F      		andi r25,lo8(-8)
 1679               	.LBE400:
 1680               	.LBE399:
 322:main.c        ****   if (TWIGetStatus() != 0x28) {
 1682               	.LM199:
 1683 052a 9832      		cpi r25,lo8(40)
 1684 052c 01F4      		brne .L106
 323:main.c        ****     TWIStop();
 324:main.c        ****     return 0x04;
 325:main.c        ****   }
 326:main.c        ****   TWIWrite(byte4);
 1686               	.LM200:
 1687 052e 802F      		mov r24,r16
 1688 0530 0E94 0000 		call TWIWrite
 1689               	.LBB401:
 1690               	.LBB402:
 200:main.c        ****   return status;
 1692               	.LM201:
 1693 0534 8091 7100 		lds r24,113
 1694 0538 887F      		andi r24,lo8(-8)
 1695               	.LBE402:
 1696               	.LBE401:
 327:main.c        ****   if (TWIGetStatus() != 0x28) {
 1698               	.LM202:
 1699 053a 8832      		cpi r24,lo8(40)
 1700 053c 01F0      		breq .L104
 1701               	.L106:
 1702               	.LBB403:
 1703               	.LBB404:
 175:main.c        **** }
 1705               	.LM203:
 1706 053e 84E9      		ldi r24,lo8(-108)
 1707 0540 8093 7400 		sts 116,r24
 1708               	.LBE404:
 1709               	.LBE403:
 328:main.c        ****     TWIStop();
 329:main.c        ****     return 0x04;
 1711               	.LM204:
 1712 0544 84E0      		ldi r24,lo8(4)
 1713 0546 00C0      		rjmp .L99
 1714               	.L104:
 1715               	.LBB405:
 1716               	.LBB406:
 175:main.c        **** }
 1718               	.LM205:
 1719 0548 84E9      		ldi r24,lo8(-108)
 1720 054a 8093 7400 		sts 116,r24
 1721               	.LBE406:
 1722               	.LBE405:
 330:main.c        ****   }
 331:main.c        ****   TWIStop();
 332:main.c        ****   return 0x00;
 1724               	.LM206:
 1725 054e 80E0      		ldi r24,0
 1726               	.L99:
 1727               	/* epilogue start */
 333:main.c        **** }
 1729               	.LM207:
 1730 0550 0F90      		pop __tmp_reg__
 1731 0552 DF91      		pop r29
 1732 0554 CF91      		pop r28
 1733 0556 1F91      		pop r17
 1734 0558 0F91      		pop r16
 1735 055a FF90      		pop r15
 1736 055c EF90      		pop r14
 1737 055e 0895      		ret
 1739               	.Lscope20:
 1747               	.global	TWI_write_5bytes
 1749               	TWI_write_5bytes:
 334:main.c        **** 
 335:main.c        **** uint8_t TWI_write_5bytes(uint8_t addr, uint8_t byte1, uint8_t byte2, uint8_t byte3, uint8_t byte4, 
 1751               	.LM208:
 1752               	.LFBB21:
 1753 0560 DF92      		push r13
 1754 0562 EF92      		push r14
 1755 0564 FF92      		push r15
 1756 0566 0F93      		push r16
 1757 0568 1F93      		push r17
 1758 056a CF93      		push r28
 1759 056c DF93      		push r29
 1760 056e 1F92      		push __zero_reg__
 1761 0570 CDB7      		in r28,__SP_L__
 1762 0572 DEB7      		in r29,__SP_H__
 1763               	/* prologue: function */
 1764               	/* frame size = 1 */
 1765               	/* stack size = 8 */
 1766               	.L__stack_usage = 8
 1767 0574 162F      		mov r17,r22
 1768 0576 F42E      		mov r15,r20
 1769 0578 D22E      		mov r13,r18
 336:main.c        **** 
 337:main.c        ****   TWIStart();
 1771               	.LM209:
 1772 057a 8983      		std Y+1,r24
 1773 057c 0E94 0000 		call TWIStart
 1774               	.LBB455:
 1775               	.LBB456:
 200:main.c        ****   return status;
 1777               	.LM210:
 1778 0580 9091 7100 		lds r25,113
 1779 0584 987F      		andi r25,lo8(-8)
 1780               	.LBE456:
 1781               	.LBE455:
 338:main.c        ****   if (TWIGetStatus() != 0x08) {
 1783               	.LM211:
 1784 0586 8981      		ldd r24,Y+1
 1785 0588 9830      		cpi r25,lo8(8)
 1786 058a 01F0      		breq .L108
 1787               	.LBB457:
 1788               	.LBB458:
 175:main.c        **** }
 1790               	.LM212:
 1791 058c 84E9      		ldi r24,lo8(-108)
 1792 058e 8093 7400 		sts 116,r24
 1793               	.LBE458:
 1794               	.LBE457:
 339:main.c        ****     TWIStop();
 340:main.c        ****     return 0x01;
 1796               	.LM213:
 1797 0592 81E0      		ldi r24,lo8(1)
 1798 0594 00C0      		rjmp .L109
 1799               	.L108:
 341:main.c        ****   }
 342:main.c        ****   TWIWrite(addr << 1);
 1801               	.LM214:
 1802 0596 880F      		lsl r24
 1803 0598 0E94 0000 		call TWIWrite
 1804               	.LBB459:
 1805               	.LBB460:
 200:main.c        ****   return status;
 1807               	.LM215:
 1808 059c 9091 7100 		lds r25,113
 1809 05a0 987F      		andi r25,lo8(-8)
 1810               	.LBE460:
 1811               	.LBE459:
 343:main.c        ****   if (TWIGetStatus() != 0x18) {
 1813               	.LM216:
 1814 05a2 9831      		cpi r25,lo8(24)
 1815 05a4 01F0      		breq .L110
 1816               	.LBB461:
 1817               	.LBB462:
 175:main.c        **** }
 1819               	.LM217:
 1820 05a6 84E9      		ldi r24,lo8(-108)
 1821 05a8 8093 7400 		sts 116,r24
 1822               	.LBE462:
 1823               	.LBE461:
 344:main.c        ****     TWIStop();
 345:main.c        ****     return 0x02;  
 1825               	.LM218:
 1826 05ac 82E0      		ldi r24,lo8(2)
 1827 05ae 00C0      		rjmp .L109
 1828               	.L110:
 346:main.c        ****   }
 347:main.c        ****   TWIWrite(byte1);
 1830               	.LM219:
 1831 05b0 812F      		mov r24,r17
 1832 05b2 0E94 0000 		call TWIWrite
 1833               	.LBB463:
 1834               	.LBB464:
 200:main.c        ****   return status;
 1836               	.LM220:
 1837 05b6 9091 7100 		lds r25,113
 1838 05ba 987F      		andi r25,lo8(-8)
 1839               	.LBE464:
 1840               	.LBE463:
 348:main.c        ****   if (TWIGetStatus() != 0x28) {
 1842               	.LM221:
 1843 05bc 9832      		cpi r25,lo8(40)
 1844 05be 01F0      		breq .L111
 1845               	.LBB465:
 1846               	.LBB466:
 175:main.c        **** }
 1848               	.LM222:
 1849 05c0 84E9      		ldi r24,lo8(-108)
 1850 05c2 8093 7400 		sts 116,r24
 1851               	.LBE466:
 1852               	.LBE465:
 349:main.c        ****     TWIStop();
 350:main.c        ****     return 0x03;
 1854               	.LM223:
 1855 05c6 83E0      		ldi r24,lo8(3)
 1856 05c8 00C0      		rjmp .L109
 1857               	.L111:
 351:main.c        ****   }
 352:main.c        ****   TWIWrite(byte2);
 1859               	.LM224:
 1860 05ca 8F2D      		mov r24,r15
 1861 05cc 0E94 0000 		call TWIWrite
 1862               	.LBB467:
 1863               	.LBB468:
 200:main.c        ****   return status;
 1865               	.LM225:
 1866 05d0 9091 7100 		lds r25,113
 1867 05d4 987F      		andi r25,lo8(-8)
 1868               	.LBE468:
 1869               	.LBE467:
 353:main.c        ****   if (TWIGetStatus() != 0x28) {
 1871               	.LM226:
 1872 05d6 9832      		cpi r25,lo8(40)
 1873 05d8 01F4      		brne .L116
 1874               	.LBB469:
 1875               	.LBB470:
 354:main.c        ****     TWIStop();
 355:main.c        ****     return 0x04;
 356:main.c        ****   }
 357:main.c        ****   TWIWrite(byte3);
 1877               	.LM227:
 1878 05da 8D2D      		mov r24,r13
 1879 05dc 0E94 0000 		call TWIWrite
 1880               	.LBB471:
 1881               	.LBB472:
 200:main.c        ****   return status;
 1883               	.LM228:
 1884 05e0 9091 7100 		lds r25,113
 1885 05e4 987F      		andi r25,lo8(-8)
 1886               	.LBE472:
 1887               	.LBE471:
 358:main.c        ****   if (TWIGetStatus() != 0x28) {
 1889               	.LM229:
 1890 05e6 9832      		cpi r25,lo8(40)
 1891 05e8 01F4      		brne .L116
 359:main.c        ****     TWIStop();
 360:main.c        ****     return 0x04;
 361:main.c        ****   }
 362:main.c        ****   TWIWrite(byte4);
 1893               	.LM230:
 1894 05ea 802F      		mov r24,r16
 1895 05ec 0E94 0000 		call TWIWrite
 1896               	.LBB473:
 1897               	.LBB474:
 200:main.c        ****   return status;
 1899               	.LM231:
 1900 05f0 9091 7100 		lds r25,113
 1901 05f4 987F      		andi r25,lo8(-8)
 1902               	.LBE474:
 1903               	.LBE473:
 363:main.c        ****   if (TWIGetStatus() != 0x28) {
 1905               	.LM232:
 1906 05f6 9832      		cpi r25,lo8(40)
 1907 05f8 01F4      		brne .L116
 364:main.c        ****     TWIStop();
 365:main.c        ****     return 0x04;
 366:main.c        ****   }
 367:main.c        ****   TWIWrite(byte5);
 1909               	.LM233:
 1910 05fa 8E2D      		mov r24,r14
 1911 05fc 0E94 0000 		call TWIWrite
 1912               	.LBB475:
 1913               	.LBB476:
 200:main.c        ****   return status;
 1915               	.LM234:
 1916 0600 8091 7100 		lds r24,113
 1917 0604 887F      		andi r24,lo8(-8)
 1918               	.LBE476:
 1919               	.LBE475:
 368:main.c        ****   if (TWIGetStatus() != 0x28) {
 1921               	.LM235:
 1922 0606 8832      		cpi r24,lo8(40)
 1923 0608 01F0      		breq .L115
 1924               	.L116:
 1925               	.LBB477:
 1926               	.LBB478:
 175:main.c        **** }
 1928               	.LM236:
 1929 060a 84E9      		ldi r24,lo8(-108)
 1930 060c 8093 7400 		sts 116,r24
 1931               	.LBE478:
 1932               	.LBE477:
 369:main.c        ****     TWIStop();
 370:main.c        ****     return 0x04;
 1934               	.LM237:
 1935 0610 84E0      		ldi r24,lo8(4)
 1936 0612 00C0      		rjmp .L109
 1937               	.L115:
 1938               	.LBB479:
 1939               	.LBB480:
 175:main.c        **** }
 1941               	.LM238:
 1942 0614 84E9      		ldi r24,lo8(-108)
 1943 0616 8093 7400 		sts 116,r24
 1944               	.LBE480:
 1945               	.LBE479:
 371:main.c        ****   }
 372:main.c        ****   TWIStop();
 373:main.c        ****   return 0x00;
 1947               	.LM239:
 1948 061a 80E0      		ldi r24,0
 1949               	.L109:
 1950               	/* epilogue start */
 1951               	.LBE470:
 1952               	.LBE469:
 374:main.c        **** }
 1954               	.LM240:
 1955 061c 0F90      		pop __tmp_reg__
 1956 061e DF91      		pop r29
 1957 0620 CF91      		pop r28
 1958 0622 1F91      		pop r17
 1959 0624 0F91      		pop r16
 1960 0626 FF90      		pop r15
 1961 0628 EF90      		pop r14
 1962 062a DF90      		pop r13
 1963 062c 0895      		ret
 1965               	.Lscope21:
 1969               	.global	updateVolumeSquelch
 1971               	updateVolumeSquelch:
 375:main.c        **** 
 376:main.c        **** uint8_t updateVolumeSquelch(uint8_t vol, uint8_t sq) {
 1973               	.LM241:
 1974               	.LFBB22:
 1975 062e EF92      		push r14
 1976 0630 0F93      		push r16
 1977               	/* prologue: function */
 1978               	/* frame size = 0 */
 1979               	/* stack size = 2 */
 1980               	.L__stack_usage = 2
 377:main.c        ****   
 378:main.c        ****   uint8_t addr, err;
 379:main.c        **** 
 380:main.c        ****   addr = 0x80; // Address for audio conf
 381:main.c        **** 
 382:main.c        ****   err = TWI_write_5bytes(fpga_addr, addr, 0x00, 0x00, sq, vol);
 1982               	.LM242:
 1983 0632 E82E      		mov r14,r24
 1984 0634 062F      		mov r16,r22
 1985 0636 20E0      		ldi r18,0
 1986 0638 40E0      		ldi r20,0
 1987 063a 60E8      		ldi r22,lo8(-128)
 1988 063c 83E2      		ldi r24,lo8(35)
 1989 063e 0E94 0000 		call TWI_write_5bytes
 1990               	/* epilogue start */
 383:main.c        ****   if(err)
 384:main.c        ****     return err;
 385:main.c        ****   return 0x00;
 386:main.c        **** }
 1992               	.LM243:
 1993 0642 0F91      		pop r16
 1994 0644 EF90      		pop r14
 1995 0646 0895      		ret
 1997               	.Lscope22:
 1999               	.global	readClar
 2001               	readClar:
 387:main.c        **** 
 388:main.c        **** uint16_t readClar(void) {
 2003               	.LM244:
 2004               	.LFBB23:
 2005               	/* prologue: function */
 2006               	/* frame size = 0 */
 2007               	/* stack size = 0 */
 2008               	.L__stack_usage = 0
 389:main.c        ****   return (ADC);
 2010               	.LM245:
 2011 0648 84B1      		in r24,0x4
 2012 064a 95B1      		in r25,0x4+1
 390:main.c        **** }
 2014               	.LM246:
 2015 064c 0895      		ret
 2017               	.Lscope23:
 2019               	.global	updateRFFE
 2021               	updateRFFE:
 391:main.c        **** 
 392:main.c        **** uint8_t updateRFFE(void) {
 2023               	.LM247:
 2024               	.LFBB24:
 2025               	/* prologue: function */
 2026               	/* frame size = 0 */
 2027               	/* stack size = 0 */
 2028               	.L__stack_usage = 0
 393:main.c        ****   uint8_t err;
 394:main.c        ****   uint16_t rxatt;
 395:main.c        **** 
 396:main.c        ****   if (rx_att)
 2030               	.LM248:
 2031 064e 4091 0000 		lds r20,rx_att
 397:main.c        ****     rxatt = 0x0001;
 398:main.c        ****   else
 399:main.c        ****     rxatt = 0x0000;
 400:main.c        **** 
 401:main.c        ****   err = TWI_write_word(pll_addr,(pll_n & 0x0fff) | (tx << 15) | (bandf << 14) | (rxatt << 13));
 2033               	.LM249:
 2034 0652 8091 0000 		lds r24,pll_n
 2035 0656 9091 0000 		lds r25,pll_n+1
 2036 065a 6091 0000 		lds r22,tx
 2037 065e 7091 0000 		lds r23,tx+1
 2038 0662 2091 0000 		lds r18,bandf
 2039 0666 3091 0000 		lds r19,bandf+1
 2040 066a 7727      		clr r23
 2041 066c 6695      		lsr r22
 2042 066e 7795      		ror r23
 2043 0670 6627      		clr r22
 2044 0672 9F70      		andi r25,15
 2045 0674 682B      		or r22,r24
 2046 0676 792B      		or r23,r25
 2047 0678 30E4      		ldi r19,0x40
 2048 067a 239F      		mul r18,r19
 2049 067c 302D      		mov r19,r0
 2050 067e 2227      		clr r18
 2051 0680 1124      		clr __zero_reg__
 2052 0682 622B      		or r22,r18
 2053 0684 732B      		or r23,r19
 396:main.c        ****     rxatt = 0x0001;
 2055               	.LM250:
 2056 0686 21E0      		ldi r18,lo8(1)
 2057 0688 4111      		cpse r20,__zero_reg__
 2058 068a 00C0      		rjmp .L120
 2059 068c 20E0      		ldi r18,0
 2060               	.L120:
 2062               	.LM251:
 2063 068e 80E0      		ldi r24,0
 2064 0690 90E0      		ldi r25,0
 2065 0692 922F      		mov r25,r18
 2066 0694 9295      		swap r25
 2067 0696 990F      		lsl r25
 2068 0698 907E      		andi r25,lo8(-32)
 2069 069a 682B      		or r22,r24
 2070 069c 792B      		or r23,r25
 2071 069e 82E2      		ldi r24,lo8(34)
 2072 06a0 0E94 0000 		call TWI_write_word
 402:main.c        ****   if (err)
 2074               	.LM252:
 2075 06a4 8823      		tst r24
 2076 06a6 01F0      		breq .L122
 403:main.c        ****     return err+5;
 2078               	.LM253:
 2079 06a8 8B5F      		subi r24,lo8(-(5))
 2080 06aa 0895      		ret
 2081               	.L122:
 404:main.c        ****   return 0x00;
 2083               	.LM254:
 2084 06ac 80E0      		ldi r24,0
 405:main.c        **** } 
 2086               	.LM255:
 2087 06ae 0895      		ret
 2092               	.Lscope24:
 2093               	.global	__subsf3
 2094               	.global	__addsf3
 2095               	.global	__mulsf3
 2096               	.global	__fixunssfsi
 2101               	.global	updateFreq
 2103               	updateFreq:
 406:main.c        ****   
 407:main.c        **** uint8_t updateFreq(double freq, int8_t clar, uint8_t all_update) {
 2105               	.LM256:
 2106               	.LFBB25:
 2107 06b0 8F92      		push r8
 2108 06b2 9F92      		push r9
 2109 06b4 AF92      		push r10
 2110 06b6 BF92      		push r11
 2111 06b8 CF92      		push r12
 2112 06ba DF92      		push r13
 2113 06bc EF92      		push r14
 2114 06be FF92      		push r15
 2115 06c0 0F93      		push r16
 2116 06c2 1F93      		push r17
 2117 06c4 CF93      		push r28
 2118 06c6 DF93      		push r29
 2119 06c8 1F92      		push __zero_reg__
 2120 06ca CDB7      		in r28,__SP_L__
 2121 06cc DEB7      		in r29,__SP_H__
 2122               	/* prologue: function */
 2123               	/* frame size = 1 */
 2124               	/* stack size = 13 */
 2125               	.L__stack_usage = 13
 2126 06ce 142F      		mov r17,r20
 408:main.c        ****   //   char buffer[60];
 409:main.c        ****   uint8_t byte1, byte2, byte3, byte4, byte5, err;
 410:main.c        ****   uint16_t pll_n_ = pll_n;
 2128               	.LM257:
 2129 06d0 4091 0000 		lds r20,pll_n
 2130 06d4 5091 0000 		lds r21,pll_n+1
 411:main.c        ****   double freq_lo, if_freq, ref_freq, ftw;
 412:main.c        ****   static double ftw_toptop, ftw_topbot, ftw_bottop, ftw_botbot;
 413:main.c        **** 
 414:main.c        ****   /*  if (band < 200) { 
 415:main.c        ****     freq_lo = (double)(freq_MHz*1000 + 45000 + freq_kHz);
 416:main.c        ****     bandf = 0;
 417:main.c        ****   }
 418:main.c        ****   else {
 419:main.c        ****     if (freq < 200*1e6) 
 420:main.c        ****       freq_lo = (double)(freq_MHz*1000 + 21400 + freq_kHz);
 421:main.c        ****     else
 422:main.c        ****       freq_lo = (double)((freq_MHz - 1152)*1000 + 21400 + freq_kHz);
 423:main.c        ****     bandf = 1;
 424:main.c        ****     }*/
 425:main.c        **** 
 426:main.c        ****   if (all_update) {
 2132               	.LM258:
 2133 06d8 2223      		tst r18
 2134 06da 01F4      		brne .+2
 2135 06dc 00C0      		rjmp .L124
 427:main.c        **** #if F_IF == 21
 428:main.c        ****     if_freq=21400;
 429:main.c        **** #elif F_IF == 45
 430:main.c        ****     if_freq=45000;
 431:main.c        **** #endif
 432:main.c        **** #ifdef LO_FREQ_PLUS_IF
 433:main.c        ****     freq_lo = freq + if_freq;
 434:main.c        **** #endif
 435:main.c        **** #ifdef LO_FREQ_MINUS_IF
 436:main.c        ****     freq_lo = freq - if_freq;
 437:main.c        **** #endif
 438:main.c        **** #ifdef LO_IF_PLUS_FREQ
 439:main.c        ****     freq_lo = if_freq + freq;
 440:main.c        **** #endif
 441:main.c        **** #ifdef LO_IF_MINUS_FREQ
 442:main.c        ****     freq_lo = if_freq - freq;
 2137               	.LM259:
 2138 06de 9B01      		movw r18,r22
 2139 06e0 AC01      		movw r20,r24
 2140 06e2 60E0      		ldi r22,0
 2141 06e4 78EC      		ldi r23,lo8(-56)
 2142 06e6 8FE2      		ldi r24,lo8(47)
 2143 06e8 97E4      		ldi r25,lo8(71)
 2144 06ea 0E94 0000 		call __subsf3
 443:main.c        **** #endif
 444:main.c        **** 
 445:main.c        ****     bandf = 1;
 2146               	.LM260:
 2147 06ee 21E0      		ldi r18,lo8(1)
 2148 06f0 30E0      		ldi r19,0
 2149 06f2 3093 0000 		sts bandf+1,r19
 2150 06f6 2093 0000 		sts bandf,r18
 446:main.c        **** 
 447:main.c        ****     if (mode == USB) {
 2152               	.LM261:
 2153 06fa 2091 0000 		lds r18,mode
 2154 06fe 2330      		cpi r18,lo8(3)
 2155 0700 01F4      		brne .L125
 448:main.c        ****       freq_lo -= (double)1.8;
 2157               	.LM262:
 2158 0702 26E6      		ldi r18,lo8(102)
 2159 0704 36E6      		ldi r19,lo8(102)
 2160 0706 46EE      		ldi r20,lo8(-26)
 2161 0708 5FE3      		ldi r21,lo8(63)
 2162 070a 00C0      		rjmp .L134
 2163               	.L125:
 449:main.c        ****     }
 450:main.c        ****     else if (mode == CW) {
 2165               	.LM263:
 2166 070c 2091 0000 		lds r18,mode
 2167 0710 2530      		cpi r18,lo8(5)
 2168 0712 01F4      		brne .L127
 451:main.c        ****       freq_lo -= (double)0.9;
 2170               	.LM264:
 2171 0714 26E6      		ldi r18,lo8(102)
 2172 0716 36E6      		ldi r19,lo8(102)
 2173 0718 46E6      		ldi r20,lo8(102)
 2174 071a 5FE3      		ldi r21,lo8(63)
 2175               	.L134:
 2176 071c 0E94 0000 		call __subsf3
 2177 0720 00C0      		rjmp .L126
 2178               	.L127:
 452:main.c        ****     }
 453:main.c        ****     else if (mode == CWN) {
 2180               	.LM265:
 2181 0722 2091 0000 		lds r18,mode
 2182 0726 2630      		cpi r18,lo8(6)
 2183 0728 01F0      		breq .L126
 454:main.c        ****       //freq_lo += (double)0.9;
 455:main.c        ****     }
 456:main.c        ****     else if (mode == LSB ) {
 2185               	.LM266:
 2186 072a 2091 0000 		lds r18,mode
 2187 072e 2130      		cpi r18,lo8(1)
 2188 0730 01F4      		brne .L126
 457:main.c        ****       freq_lo += (double)1.8;
 2190               	.LM267:
 2191 0732 26E6      		ldi r18,lo8(102)
 2192 0734 36E6      		ldi r19,lo8(102)
 2193 0736 46EE      		ldi r20,lo8(-26)
 2194 0738 5FE3      		ldi r21,lo8(63)
 2195 073a 0E94 0000 		call __addsf3
 2196               	.L126:
 458:main.c        ****     }
 459:main.c        **** 
 460:main.c        **** #ifdef INDIRECT_FREQ
 461:main.c        ****     pll_n_ = (uint16_t)lround(freq_lo/(double)100);  // 100 kHz step
 462:main.c        ****     ref_freq = 170*freq_lo/pll_n_;  // 170 ref divider value
 463:main.c        ****     ftw = ref_freq*(double)279.62026666667; // 20MHz,25bit: 279.620266667 19.2MHz,22bit: 36.4088889
 464:main.c        ****     ftw_toptop = floor(ftw/(double)16777216);
 465:main.c        ****     ftw_topbot = floor((ftw-ftw_toptop*(double)16777216)/(double)65536);
 466:main.c        ****     ftw_bottop = floor((ftw-ftw_toptop*(double)16777216-ftw_topbot*(double)65536)/(double)256);
 467:main.c        ****     ftw_botbot = fmod(ftw,256);
 468:main.c        **** #endif
 469:main.c        **** #ifdef DIRECT_FREQ
 470:main.c        ****     ftw = freq_lo*(double)279.62026666667; // 20MHz,25bit: 279.620266667 19.2MHz,22bit: 36.4088889
 2198               	.LM268:
 2199 073e 25E6      		ldi r18,lo8(101)
 2200 0740 3FEC      		ldi r19,lo8(-49)
 2201 0742 4BE8      		ldi r20,lo8(-117)
 2202 0744 53E4      		ldi r21,lo8(67)
 2203 0746 0E94 0000 		call __mulsf3
 2204 074a 6B01      		movw r12,r22
 2205 074c 7C01      		movw r14,r24
 471:main.c        ****     ftw_toptop = floor(ftw/(double)16777216);
 2207               	.LM269:
 2208 074e 20E0      		ldi r18,0
 2209 0750 30E0      		ldi r19,0
 2210 0752 40E8      		ldi r20,lo8(-128)
 2211 0754 53E3      		ldi r21,lo8(51)
 2212 0756 0E94 0000 		call __mulsf3
 2213 075a 0E94 0000 		call floor
 2214 075e 6093 0000 		sts ftw_toptop.2403,r22
 2215 0762 7093 0000 		sts ftw_toptop.2403+1,r23
 2216 0766 8093 0000 		sts ftw_toptop.2403+2,r24
 2217 076a 9093 0000 		sts ftw_toptop.2403+3,r25
 472:main.c        ****     ftw_topbot = floor((ftw-ftw_toptop*(double)16777216)/(double)65536);
 2219               	.LM270:
 2220 076e 20E0      		ldi r18,0
 2221 0770 30E0      		ldi r19,0
 2222 0772 40E8      		ldi r20,lo8(-128)
 2223 0774 5BE4      		ldi r21,lo8(75)
 2224 0776 0E94 0000 		call __mulsf3
 2225 077a 9B01      		movw r18,r22
 2226 077c AC01      		movw r20,r24
 2227 077e C701      		movw r24,r14
 2228 0780 B601      		movw r22,r12
 2229 0782 0E94 0000 		call __subsf3
 2230 0786 4B01      		movw r8,r22
 2231 0788 5C01      		movw r10,r24
 2232 078a 20E0      		ldi r18,0
 2233 078c 30E0      		ldi r19,0
 2234 078e 40E8      		ldi r20,lo8(-128)
 2235 0790 57E3      		ldi r21,lo8(55)
 2236 0792 0E94 0000 		call __mulsf3
 2237 0796 0E94 0000 		call floor
 2238 079a 6093 0000 		sts ftw_topbot.2404,r22
 2239 079e 7093 0000 		sts ftw_topbot.2404+1,r23
 2240 07a2 8093 0000 		sts ftw_topbot.2404+2,r24
 2241 07a6 9093 0000 		sts ftw_topbot.2404+3,r25
 473:main.c        ****     ftw_bottop = floor((ftw-ftw_toptop*(double)16777216-ftw_topbot*(double)65536)/(double)256);
 2243               	.LM271:
 2244 07aa 20E0      		ldi r18,0
 2245 07ac 30E0      		ldi r19,0
 2246 07ae 40E8      		ldi r20,lo8(-128)
 2247 07b0 57E4      		ldi r21,lo8(71)
 2248 07b2 0E94 0000 		call __mulsf3
 2249 07b6 9B01      		movw r18,r22
 2250 07b8 AC01      		movw r20,r24
 2251 07ba C501      		movw r24,r10
 2252 07bc B401      		movw r22,r8
 2253 07be 0E94 0000 		call __subsf3
 2254 07c2 20E0      		ldi r18,0
 2255 07c4 30E0      		ldi r19,0
 2256 07c6 40E8      		ldi r20,lo8(-128)
 2257 07c8 5BE3      		ldi r21,lo8(59)
 2258 07ca 0E94 0000 		call __mulsf3
 2259 07ce 0E94 0000 		call floor
 2260 07d2 6093 0000 		sts ftw_bottop.2405,r22
 2261 07d6 7093 0000 		sts ftw_bottop.2405+1,r23
 2262 07da 8093 0000 		sts ftw_bottop.2405+2,r24
 2263 07de 9093 0000 		sts ftw_bottop.2405+3,r25
 474:main.c        ****     ftw_botbot = fmod(ftw,256);
 2265               	.LM272:
 2266 07e2 20E0      		ldi r18,0
 2267 07e4 30E0      		ldi r19,0
 2268 07e6 40E8      		ldi r20,lo8(-128)
 2269 07e8 53E4      		ldi r21,lo8(67)
 2270 07ea C701      		movw r24,r14
 2271 07ec B601      		movw r22,r12
 2272 07ee 0E94 0000 		call fmod
 2273 07f2 6093 0000 		sts ftw_botbot.2406,r22
 2274 07f6 7093 0000 		sts ftw_botbot.2406+1,r23
 2275 07fa 8093 0000 		sts ftw_botbot.2406+2,r24
 2276 07fe 9093 0000 		sts ftw_botbot.2406+3,r25
 2277               	.L124:
 475:main.c        **** #endif    
 476:main.c        ****   }
 477:main.c        **** 
 478:main.c        **** #if defined(LO_FREQ_PLUS_IF) || defined(LO_IF_PLUS_FREQ)
 479:main.c        ****   clar = -(clar+1);  // For arch with LO above RF freq
 480:main.c        **** #endif
 481:main.c        ****   byte1 = 0xc0;
 482:main.c        ****   byte2 = (uint8_t)(ftw_toptop) | (clar & 0xfe);
 483:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 484:main.c        ****   byte4 = (uint8_t)ftw_bottop;
 485:main.c        ****   byte5 = (uint8_t)ftw_botbot;
 2279               	.LM273:
 2280 0802 6091 0000 		lds r22,ftw_botbot.2406
 2281 0806 7091 0000 		lds r23,ftw_botbot.2406+1
 2282 080a 8091 0000 		lds r24,ftw_botbot.2406+2
 2283 080e 9091 0000 		lds r25,ftw_botbot.2406+3
 2284 0812 0E94 0000 		call __fixunssfsi
 2285 0816 E62E      		mov r14,r22
 484:main.c        ****   byte5 = (uint8_t)ftw_botbot;
 2287               	.LM274:
 2288 0818 6091 0000 		lds r22,ftw_bottop.2405
 2289 081c 7091 0000 		lds r23,ftw_bottop.2405+1
 2290 0820 8091 0000 		lds r24,ftw_bottop.2405+2
 2291 0824 9091 0000 		lds r25,ftw_bottop.2405+3
 2292 0828 0E94 0000 		call __fixunssfsi
 2293 082c 062F      		mov r16,r22
 483:main.c        ****   byte4 = (uint8_t)ftw_bottop;
 2295               	.LM275:
 2296 082e 6091 0000 		lds r22,ftw_topbot.2404
 2297 0832 7091 0000 		lds r23,ftw_topbot.2404+1
 2298 0836 8091 0000 		lds r24,ftw_topbot.2404+2
 2299 083a 9091 0000 		lds r25,ftw_topbot.2404+3
 2300 083e 0E94 0000 		call __fixunssfsi
 2301 0842 262F      		mov r18,r22
 482:main.c        ****   byte3 = (uint8_t)ftw_topbot;
 2303               	.LM276:
 2304 0844 1E7F      		andi r17,lo8(-2)
 2305 0846 6091 0000 		lds r22,ftw_toptop.2403
 2306 084a 7091 0000 		lds r23,ftw_toptop.2403+1
 2307 084e 8091 0000 		lds r24,ftw_toptop.2403+2
 2308 0852 9091 0000 		lds r25,ftw_toptop.2403+3
 2309 0856 2983      		std Y+1,r18
 2310 0858 0E94 0000 		call __fixunssfsi
 2311 085c 412F      		mov r20,r17
 2312 085e 462B      		or r20,r22
 486:main.c        **** 
 487:main.c        ****   err = TWI_write_5bytes(fpga_addr, byte1, byte2, byte3, byte4, byte5);
 2314               	.LM277:
 2315 0860 2981      		ldd r18,Y+1
 2316 0862 60EC      		ldi r22,lo8(-64)
 2317 0864 83E2      		ldi r24,lo8(35)
 2318 0866 0E94 0000 		call TWI_write_5bytes
 2319               	/* epilogue start */
 488:main.c        ****   if(err)
 489:main.c        ****     return err;
 490:main.c        ****  
 491:main.c        **** #ifdef INDIRECT_FREQ
 492:main.c        ****   _delay_us(50);
 493:main.c        ****   if (pll_n != pll_n_) {
 494:main.c        ****     pll_n = pll_n_;
 495:main.c        ****     err = updateRFFE();
 496:main.c        ****     if (err)
 497:main.c        ****       return err+5;
 498:main.c        ****   }
 499:main.c        **** #endif
 500:main.c        ****   return 0x00;
 501:main.c        **** }
 2321               	.LM278:
 2322 086a 0F90      		pop __tmp_reg__
 2323 086c DF91      		pop r29
 2324 086e CF91      		pop r28
 2325 0870 1F91      		pop r17
 2326 0872 0F91      		pop r16
 2327 0874 FF90      		pop r15
 2328 0876 EF90      		pop r14
 2329 0878 DF90      		pop r13
 2330 087a CF90      		pop r12
 2331 087c BF90      		pop r11
 2332 087e AF90      		pop r10
 2333 0880 9F90      		pop r9
 2334 0882 8F90      		pop r8
 2335 0884 0895      		ret
 2345               	.Lscope25:
 2347               	.global	updateSettings
 2349               	updateSettings:
 502:main.c        **** 
 503:main.c        **** uint8_t updateSettings (void) {
 2351               	.LM279:
 2352               	.LFBB26:
 2353 0886 EF92      		push r14
 2354 0888 0F93      		push r16
 2355               	/* prologue: function */
 2356               	/* frame size = 0 */
 2357               	/* stack size = 2 */
 2358               	.L__stack_usage = 2
 504:main.c        **** 
 505:main.c        ****   uint8_t err;
 506:main.c        ****   uint8_t byte0, byte1, byte2, byte3, byte4;
 507:main.c        **** 
 508:main.c        ****   switch (mode) {  
 2360               	.LM280:
 2361 088a 9091 0000 		lds r25,mode
 2362 088e 9530      		cpi r25,lo8(5)
 2363 0890 01F0      		breq .L137
 2364 0892 00F4      		brsh .L138
 2365 0894 9130      		cpi r25,lo8(1)
 2366 0896 01F0      		breq .L137
 2367 0898 9330      		cpi r25,lo8(3)
 2368 089a 01F0      		breq .+2
 2369 089c 00C0      		rjmp .L136
 509:main.c        ****   case LSB:
 510:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 511:main.c        ****     byte0 = 0b01111000; // Set USB
 512:main.c        **** #else
 513:main.c        ****     byte0 = 0b01110000; // Set LSB
 514:main.c        **** #endif
 515:main.c        **** #if F_IF == 21
 516:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 517:main.c        ****     byte2 = 0x08;
 518:main.c        **** #elif F_IF == 45
 519:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 520:main.c        ****     byte2 = 0x88;
 521:main.c        **** #endif
 522:main.c        ****     byte3 = 0x00;
 523:main.c        ****     byte4 = 0x00;
 524:main.c        ****     break;
 525:main.c        **** 
 526:main.c        ****   case USB:
 527:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 528:main.c        ****     byte0 = 0b01110000; // Set LSB
 529:main.c        **** #else
 530:main.c        ****     byte0 = 0b01111000; // Set USB
 531:main.c        **** #endif
 532:main.c        **** #if F_IF == 21
 533:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 534:main.c        ****     byte2 = 0x08;
 535:main.c        **** #elif F_IF == 45
 536:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2371               	.LM281:
 2372 089e 9091 0000 		lds r25,tx_att
 2373 08a2 8091 0000 		lds r24,rx_att
 2374 08a6 28E0      		ldi r18,lo8(8)
 2375 08a8 829F      		mul r24,r18
 2376 08aa A001      		movw r20,r0
 2377 08ac 1124      		clr __zero_reg__
 2378 08ae 20E4      		ldi r18,lo8(64)
 2379 08b0 929F      		mul r25,r18
 2380 08b2 C001      		movw r24,r0
 2381 08b4 1124      		clr __zero_reg__
 2382 08b6 482B      		or r20,r24
 530:main.c        **** #endif
 2384               	.LM282:
 2385 08b8 68E7      		ldi r22,lo8(120)
 537:main.c        ****     byte2 = 0x88;
 538:main.c        **** #endif
 539:main.c        ****     byte3 = 0x00;
 540:main.c        ****     byte4 = 0x00;
 541:main.c        ****     break;
 2387               	.LM283:
 2388 08ba 00C0      		rjmp .L136
 2389               	.L138:
 508:main.c        ****   case LSB:
 2391               	.LM284:
 2392 08bc 9830      		cpi r25,lo8(8)
 2393 08be 01F0      		breq .L141
 2394 08c0 9A30      		cpi r25,lo8(10)
 2395 08c2 01F0      		breq .L142
 2396 08c4 9630      		cpi r25,lo8(6)
 2397 08c6 01F4      		brne .L136
 542:main.c        **** 
 543:main.c        ****   case CW:
 544:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 545:main.c        ****     byte0 = 0b01111000; // Set USB
 546:main.c        **** #else
 547:main.c        ****     byte0 = 0b01110000; // Set LSB
 548:main.c        **** #endif
 549:main.c        **** #if F_IF == 21
 550:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 551:main.c        ****     byte2 = 0x08;
 552:main.c        **** #elif F_IF == 45
 553:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 554:main.c        ****     byte2 = 0x88;
 555:main.c        **** #endif
 556:main.c        ****     byte3 = 0x00;
 557:main.c        ****     byte4 = 0x00;
 558:main.c        ****     break;
 559:main.c        **** 
 560:main.c        ****   case CWN:
 561:main.c        **** #if defined(LO_FREQ_PLUS_IF)||defined(LO_IF_PLUS_FREQ)
 562:main.c        ****     byte0 = 0b01101000; // Set narrow USB
 563:main.c        **** #else
 564:main.c        ****     byte0 = 0b01100000; // Set narrow LSB
 565:main.c        **** #endif
 566:main.c        **** #if F_IF == 21
 567:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 568:main.c        ****     byte2 = 0x08;
 569:main.c        **** #elif F_IF == 45
 570:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2399               	.LM285:
 2400 08c8 9091 0000 		lds r25,tx_att
 2401 08cc 8091 0000 		lds r24,rx_att
 2402 08d0 28E0      		ldi r18,lo8(8)
 2403 08d2 829F      		mul r24,r18
 2404 08d4 A001      		movw r20,r0
 2405 08d6 1124      		clr __zero_reg__
 2406 08d8 20E4      		ldi r18,lo8(64)
 2407 08da 929F      		mul r25,r18
 2408 08dc C001      		movw r24,r0
 2409 08de 1124      		clr __zero_reg__
 2410 08e0 482B      		or r20,r24
 564:main.c        **** #endif
 2412               	.LM286:
 2413 08e2 60E6      		ldi r22,lo8(96)
 571:main.c        ****     byte2 = 0x88;
 572:main.c        **** #endif
 573:main.c        ****     byte3 = 0x00;
 574:main.c        ****     byte4 = 0x00;
 575:main.c        ****     break;
 2415               	.LM287:
 2416 08e4 00C0      		rjmp .L136
 2417               	.L137:
 553:main.c        ****     byte2 = 0x88;
 2419               	.LM288:
 2420 08e6 9091 0000 		lds r25,tx_att
 2421 08ea 8091 0000 		lds r24,rx_att
 2422 08ee 28E0      		ldi r18,lo8(8)
 2423 08f0 829F      		mul r24,r18
 2424 08f2 A001      		movw r20,r0
 2425 08f4 1124      		clr __zero_reg__
 2426 08f6 20E4      		ldi r18,lo8(64)
 2427 08f8 929F      		mul r25,r18
 2428 08fa C001      		movw r24,r0
 2429 08fc 1124      		clr __zero_reg__
 2430 08fe 482B      		or r20,r24
 547:main.c        **** #endif
 2432               	.LM289:
 2433 0900 60E7      		ldi r22,lo8(112)
 558:main.c        **** 
 2435               	.LM290:
 2436 0902 00C0      		rjmp .L136
 2437               	.L141:
 576:main.c        **** 
 577:main.c        ****   case AM:
 578:main.c        ****     byte0 = 0b01000000;
 579:main.c        **** #if F_IF == 21
 580:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 581:main.c        ****     byte2 = 0x08;
 582:main.c        **** #elif F_IF == 45
 583:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2439               	.LM291:
 2440 0904 9091 0000 		lds r25,tx_att
 2441 0908 8091 0000 		lds r24,rx_att
 2442 090c 28E0      		ldi r18,lo8(8)
 2443 090e 829F      		mul r24,r18
 2444 0910 A001      		movw r20,r0
 2445 0912 1124      		clr __zero_reg__
 2446 0914 20E4      		ldi r18,lo8(64)
 2447 0916 929F      		mul r25,r18
 2448 0918 C001      		movw r24,r0
 2449 091a 1124      		clr __zero_reg__
 2450 091c 482B      		or r20,r24
 578:main.c        **** #if F_IF == 21
 2452               	.LM292:
 2453 091e 60E4      		ldi r22,lo8(64)
 584:main.c        ****     byte2 = 0x88;
 585:main.c        **** #endif
 586:main.c        ****     byte3 = 0x00;
 587:main.c        ****     byte4 = 0x00;
 588:main.c        ****     break;
 2455               	.LM293:
 2456 0920 00C0      		rjmp .L136
 2457               	.L142:
 589:main.c        **** 
 590:main.c        ****   case FM:
 591:main.c        ****     byte0 = 0b01000001;
 592:main.c        **** #if F_IF == 21
 593:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x01;
 594:main.c        ****     byte2 = 0x08;
 595:main.c        **** #elif F_IF == 45
 596:main.c        ****     byte1 = (tx_att << 6)|(rx_att << 3)|0x00;
 2459               	.LM294:
 2460 0922 9091 0000 		lds r25,tx_att
 2461 0926 8091 0000 		lds r24,rx_att
 2462 092a 28E0      		ldi r18,lo8(8)
 2463 092c 829F      		mul r24,r18
 2464 092e A001      		movw r20,r0
 2465 0930 1124      		clr __zero_reg__
 2466 0932 20E4      		ldi r18,lo8(64)
 2467 0934 929F      		mul r25,r18
 2468 0936 C001      		movw r24,r0
 2469 0938 1124      		clr __zero_reg__
 2470 093a 482B      		or r20,r24
 591:main.c        **** #if F_IF == 21
 2472               	.LM295:
 2473 093c 61E4      		ldi r22,lo8(65)
 2474               	.L136:
 597:main.c        ****     byte2 = 0x88;
 598:main.c        **** #endif
 599:main.c        ****     byte3 = 0x00;
 600:main.c        ****     byte4 = 0x00;
 601:main.c        ****   }
 602:main.c        ****   
 603:main.c        ****   err = TWI_write_5bytes(fpga_addr, byte0, byte1, byte2, byte3, byte4);
 2476               	.LM296:
 2477 093e E12C      		mov r14,__zero_reg__
 2478 0940 00E0      		ldi r16,0
 2479 0942 28E8      		ldi r18,lo8(-120)
 2480 0944 83E2      		ldi r24,lo8(35)
 2481 0946 0E94 0000 		call TWI_write_5bytes
 2482               	/* epilogue start */
 604:main.c        ****   if (err)
 605:main.c        ****     return err;
 606:main.c        **** 
 607:main.c        ****   return 0x00;
 608:main.c        **** 
 609:main.c        **** }
 2484               	.LM297:
 2485 094a 0F91      		pop r16
 2486 094c EF90      		pop r14
 2487 094e 0895      		ret
 2493               	.Lscope26:
 2495               	.global	adcInit
 2497               	adcInit:
 610:main.c        **** 
 611:main.c        **** void adcInit(void) {
 2499               	.LM298:
 2500               	.LFBB27:
 2501               	/* prologue: function */
 2502               	/* frame size = 0 */
 2503               	/* stack size = 0 */
 2504               	.L__stack_usage = 0
 612:main.c        ****   ADCSRA = (1 << ADEN) | (1 << ADFR) | (1 << ADPS2) | (1 << ADPS1); // Free run, /64 -> 77 kHz
 2506               	.LM299:
 2507 0950 86EA      		ldi r24,lo8(-90)
 2508 0952 86B9      		out 0x6,r24
 613:main.c        ****   ADMUX = 0x43; // ADC3, AVCC ref
 2510               	.LM300:
 2511 0954 83E4      		ldi r24,lo8(67)
 2512 0956 87B9      		out 0x7,r24
 614:main.c        ****   ADCSRA |= (1 << ADSC); // Start conversion
 2514               	.LM301:
 2515 0958 369A      		sbi 0x6,6
 2516 095a 0895      		ret
 2518               	.Lscope27:
 2520               	.global	Timer0Init
 2522               	Timer0Init:
 615:main.c        **** 
 616:main.c        **** }
 617:main.c        **** 
 618:main.c        **** void Timer0Init(void) {
 2524               	.LM302:
 2525               	.LFBB28:
 2526               	/* prologue: function */
 2527               	/* frame size = 0 */
 2528               	/* stack size = 0 */
 2529               	.L__stack_usage = 0
 619:main.c        **** 
 620:main.c        ****   TCCR0 = 0x0f; // CTC mode, 1024 prescaler
 2531               	.LM303:
 2532 095c 8FE0      		ldi r24,lo8(15)
 2533 095e 83BF      		out 0x33,r24
 621:main.c        ****   OCR0 = (uint8_t)10; // 1000000/(1024*10) = 100 Hz, 10ms
 2535               	.LM304:
 2536 0960 8AE0      		ldi r24,lo8(10)
 2537 0962 81BF      		out 0x31,r24
 622:main.c        ****   TIMSK |= (1 << OCIE0); // Interrupt at compare match
 2539               	.LM305:
 2540 0964 87B7      		in r24,0x37
 2541 0966 8260      		ori r24,lo8(2)
 2542 0968 87BF      		out 0x37,r24
 2543 096a 0895      		ret
 2545               	.Lscope28:
 2547               	.global	Timer1Init
 2549               	Timer1Init:
 623:main.c        **** }
 624:main.c        **** 
 625:main.c        **** void Timer1Init(void) {
 2551               	.LM306:
 2552               	.LFBB29:
 2553               	/* prologue: function */
 2554               	/* frame size = 0 */
 2555               	/* stack size = 0 */
 2556               	.L__stack_usage = 0
 626:main.c        **** 
 627:main.c        ****   TCCR1A = 0x00;  
 2558               	.LM307:
 2559 096c 1FBC      		out 0x2f,__zero_reg__
 628:main.c        ****   TCCR1B = 0x0b; // CTC mode, 64 prescaler
 2561               	.LM308:
 2562 096e 8BE0      		ldi r24,lo8(11)
 2563 0970 8EBD      		out 0x2e,r24
 629:main.c        ****   OCR1A = (uint16_t)1563; // 1000000/(64*1563) = 10 Hz, 100ms
 2565               	.LM309:
 2566 0972 8BE1      		ldi r24,lo8(27)
 2567 0974 96E0      		ldi r25,lo8(6)
 2568 0976 9BBD      		out 0x2a+1,r25
 2569 0978 8ABD      		out 0x2a,r24
 630:main.c        ****   TIMSK |= (1 << OCIE1A); // Interrupt at compare match
 2571               	.LM310:
 2572 097a 87B7      		in r24,0x37
 2573 097c 8061      		ori r24,lo8(16)
 2574 097e 87BF      		out 0x37,r24
 2575 0980 0895      		ret
 2577               	.Lscope29:
 2578               		.section	.rodata.str1.1,"aMS",@progbits,1
 2579               	.LC0:
 2580 0000 4572 7220 		.string	"Err %x         "
 2580      2578 2020 
 2580      2020 2020 
 2580      2020 2000 
 2581               	.global	__divsf3
 2582               	.global	__fixsfsi
 2583               	.LC1:
 2584 0010 2564 2C25 		.string	"%d,%06.2f     "
 2584      3036 2E32 
 2584      6620 2020 
 2584      2020 00
 2585               	.LC2:
 2586 001f 2B00      		.string	"+"
 2587               	.LC3:
 2588 0021 2D00      		.string	"-"
 2589               	.LC4:
 2590 0023 2000      		.string	" "
 2591               	.global	__nesf2
 2592               	.LC5:
 2593 0025 532D 2D2D 		.string	"S---9+++   "
 2593      392B 2B2B 
 2593      2020 2000 
 2594               	.LC6:
 2595 0031 5325 6420 		.string	"S%d         "
 2595      2020 2020 
 2595      2020 2020 
 2595      00
 2596               	.LC7:
 2597 003e 532D 2564 		.string	"S-%d        "
 2597      2020 2020 
 2597      2020 2020 
 2597      00
 2598               	.LC8:
 2599 004b 532D 2D25 		.string	"S--%d       "
 2599      6420 2020 
 2599      2020 2020 
 2599      00
 2600               	.LC9:
 2601 0058 532D 2D2D 		.string	"S---%d      "
 2601      2564 2020 
 2601      2020 2020 
 2601      00
 2602               	.LC10:
 2603 0065 532D 2D2D 		.string	"S----%d     "
 2603      2D25 6420 
 2603      2020 2020 
 2603      00
 2604               	.LC11:
 2605 0072 532D 2D2D 		.string	"S----9+    "
 2605      2D39 2B20 
 2605      2020 2000 
 2606               	.LC12:
 2607 007e 532D 2D2D 		.string	"S----9++   "
 2607      2D39 2B2B 
 2607      2020 2000 
 2608               	.LC13:
 2609 008a 5553 4220 		.string	"USB "
 2609      00
 2610               	.LC14:
 2611 008f 4357 2020 		.string	"CW  "
 2611      00
 2612               	.LC15:
 2613 0094 4357 4E20 		.string	"CWN "
 2613      00
 2614               	.LC16:
 2615 0099 414D 2020 		.string	"AM  "
 2615      00
 2616               	.LC17:
 2617 009e 464D 2020 		.string	"FM  "
 2617      00
 2618               	.LC18:
 2619 00a3 4C53 4220 		.string	"LSB "
 2619      00
 2620               	.global	__ltsf2
 2621               	.LC19:
 2622 00a8 4572 7220 		.string	"Err freq %x         "
 2622      6672 6571 
 2622      2025 7820 
 2622      2020 2020 
 2622      2020 2020 
 2623               	.LC20:
 2624 00bd 4572 7220 		.string	"Err sett %x         "
 2624      7365 7474 
 2624      2025 7820 
 2624      2020 2020 
 2624      2020 2020 
 2625               	.LC21:
 2626 00d2 566F 6C20 		.string	"Vol %d    "
 2626      2564 2020 
 2626      2020 00
 2627               	.LC22:
 2628 00dd 4572 7220 		.string	"Err Vol %x         "
 2628      566F 6C20 
 2628      2578 2020 
 2628      2020 2020 
 2628      2020 2000 
 2629               	.LC23:
 2630 00f1 5371 2025 		.string	"Sq %d    "
 2630      6420 2020 
 2630      2000 
 2631               	.LC24:
 2632 00fb 4572 7220 		.string	"Err Sq %x         "
 2632      5371 2025 
 2632      7820 2020 
 2632      2020 2020 
 2632      2020 00
 2633               		.section	.text.startup,"ax",@progbits
 2635               	.global	main
 2637               	main:
 631:main.c        **** }
 632:main.c        **** 
 633:main.c        **** int main(void)
 634:main.c        **** {
 2639               	.LM311:
 2640               	.LFBB30:
 2641 0000 CF93      		push r28
 2642 0002 DF93      		push r29
 2643 0004 CDB7      		in r28,__SP_L__
 2644 0006 DEB7      		in r29,__SP_H__
 2645 0008 C654      		subi r28,70
 2646 000a D109      		sbc r29,__zero_reg__
 2647 000c 0FB6      		in __tmp_reg__,__SREG__
 2648 000e F894      		cli
 2649 0010 DEBF      		out __SP_H__,r29
 2650 0012 0FBE      		out __SREG__,__tmp_reg__
 2651 0014 CDBF      		out __SP_L__,r28
 2652               	/* prologue: function */
 2653               	/* frame size = 70 */
 2654               	/* stack size = 72 */
 2655               	.L__stack_usage = 72
 635:main.c        ****   char buffer[60];
 636:main.c        ****   double freq, freq_last;  // kHz part
 637:main.c        ****   int16_t clarval, clarval_last;
 638:main.c        ****   int8_t clar = 0;
 639:main.c        ****   int freq_offset = 0; // offset in MHz for display
 640:main.c        ****   uint8_t err, data;
 641:main.c        ****   uint8_t rssi, rssi_max=0, rssi_count=0;
 642:main.c        ****   uint8_t last_dir;
 643:main.c        ****   uint8_t squelch = 0;
 644:main.c        ****   uint8_t tx_last = 255;
 645:main.c        ****   uint8_t vol = 0x18;
 646:main.c        ****   uint16_t steps;
 647:main.c        ****   
 648:main.c        ****   static const char string_intro_row1[] PROGMEM = "*** SM6VFZ";
 649:main.c        ****   static const char string_intro_row2[] PROGMEM = "Starting radio";
 650:main.c        **** 
 651:main.c        ****   DDRA = 0xFF;
 2657               	.LM312:
 2658 0016 8FEF      		ldi r24,lo8(-1)
 2659 0018 8ABB      		out 0x1a,r24
 652:main.c        ****   DDRB = 0xFF;
 2661               	.LM313:
 2662 001a 87BB      		out 0x17,r24
 653:main.c        ****   DDRC = 0xFF;
 2664               	.LM314:
 2665 001c 84BB      		out 0x14,r24
 654:main.c        ****   DDRD = ~(uint8_t)((1 << ROT2_A)|(1 << ROT2_B));
 2667               	.LM315:
 2668 001e 93EF      		ldi r25,lo8(-13)
 2669 0020 91BB      		out 0x11,r25
 655:main.c        ****   DDRE = ~(uint8_t)((1 << ROT1_A)|(1 << ROT1_B)|(1 << VOLROT_A)|(1 << VOLROT_B)|(1 << FREQ_BUTTON))
 2671               	.LM316:
 2672 0022 97E0      		ldi r25,lo8(7)
 2673 0024 92B9      		out 0x2,r25
 656:main.c        ****   DDRF = ~(uint8_t)((1 << VOL_BUTTON)|(1 << MODE_BUTTON)|(1 << BAND_BUTTON)|(1 << CLAR_POT)|(1 << M
 2675               	.LM317:
 2676 0026 90EE      		ldi r25,lo8(-32)
 2677 0028 9093 6100 		sts 97,r25
 657:main.c        ****   DDRG = 0xFF;  
 2679               	.LM318:
 2680 002c 8093 6400 		sts 100,r24
 658:main.c        **** 	
 659:main.c        ****   PORTA = 0x00;
 2682               	.LM319:
 2683 0030 1BBA      		out 0x1b,__zero_reg__
 660:main.c        ****   PORTB = 0x00;
 2685               	.LM320:
 2686 0032 18BA      		out 0x18,__zero_reg__
 661:main.c        ****   PORTC = 0x00;
 2688               	.LM321:
 2689 0034 15BA      		out 0x15,__zero_reg__
 662:main.c        ****   PORTD = (uint8_t)((1 << ROT2_A)|(1 << ROT2_B));
 2691               	.LM322:
 2692 0036 8CE0      		ldi r24,lo8(12)
 2693 0038 82BB      		out 0x12,r24
 663:main.c        ****   PORTE = (uint8_t)((1 << ROT1_A)|(1 << ROT1_B)|(1 << VOLROT_A)|(1 << VOLROT_B)|(1 << FREQ_BUTTON)|
 2695               	.LM323:
 2696 003a 88EF      		ldi r24,lo8(-8)
 2697 003c 83B9      		out 0x3,r24
 664:main.c        ****   PORTF = (uint8_t)((1 << VOL_BUTTON)|(1 << MODE_BUTTON)|(1 << BAND_BUTTON)|(1 << MODE_BUTTON)|(1 <
 2699               	.LM324:
 2700 003e 83E1      		ldi r24,lo8(19)
 2701 0040 8093 6200 		sts 98,r24
 665:main.c        ****   PORTG = 0x00;
 2703               	.LM325:
 2704 0044 1092 6500 		sts 101,__zero_reg__
 666:main.c        **** 	
 667:main.c        ****   // turn off the analog comparator
 668:main.c        ****   ACSR = 0x40U;
 2706               	.LM326:
 2707 0048 80E4      		ldi r24,lo8(64)
 2708 004a 88B9      		out 0x8,r24
 669:main.c        **** 	
 670:main.c        ****   // turn off SPI, TWI and USART0
 671:main.c        ****   //PRR  = 0x86U;
 672:main.c        **** 	
 673:main.c        ****   EICRA = (1<<ISC21)|(1<<ISC31);
 2710               	.LM327:
 2711 004c 80EA      		ldi r24,lo8(-96)
 2712 004e 8093 6A00 		sts 106,r24
 674:main.c        ****   EICRB = (1<<ISC41)|(1<<ISC51)|(1<<ISC61)|(1<<ISC71);
 2714               	.LM328:
 2715 0052 8AEA      		ldi r24,lo8(-86)
 2716 0054 8ABF      		out 0x3a,r24
 675:main.c        **** 
 676:main.c        ****   EIMSK = (1 << INTF2)|(1 << INTF3)|(1 << INTF4)|(1 << INTF5)|(1 << INTF6)|(1 << INTF7);
 2718               	.LM329:
 2719 0056 8CEF      		ldi r24,lo8(-4)
 2720 0058 89BF      		out 0x39,r24
 2721               	.LBB481:
 2722               	.LBB482:
 2724               	.Ltext37:
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** 
 102:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 103:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** #else
 105:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 106:/usr/lib/avr/include/avr/wdt.h **** #endif
 107:/usr/lib/avr/include/avr/wdt.h **** 
 108:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 109:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 110:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 111:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 112:/usr/lib/avr/include/avr/wdt.h **** #else
 113:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 114:/usr/lib/avr/include/avr/wdt.h **** #endif
 115:/usr/lib/avr/include/avr/wdt.h **** 
 116:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 117:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 118:/usr/lib/avr/include/avr/wdt.h **** #else
 119:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 120:/usr/lib/avr/include/avr/wdt.h **** #endif
 121:/usr/lib/avr/include/avr/wdt.h **** 
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** /**
 124:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 125:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 126:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 127:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 128:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 129:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 130:/usr/lib/avr/include/avr/wdt.h **** 
 131:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 132:/usr/lib/avr/include/avr/wdt.h **** */
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h **** 
 135:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** /*
 138:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 139:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 140:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 141:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 142:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 143:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 144:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 145:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 146:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 147:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 148:/usr/lib/avr/include/avr/wdt.h **** */
 149:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 150:/usr/lib/avr/include/avr/wdt.h **** do { \
 151:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 152:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 153:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 155:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 156:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 157:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 158:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 159:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 160:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 161:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 162:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 163:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 164:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 165:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 166:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 167:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 168:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 169:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 170:/usr/lib/avr/include/avr/wdt.h **** ); \
 171:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 172:/usr/lib/avr/include/avr/wdt.h **** 
 173:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 174:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 175:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 176:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 177:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 178:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 179:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 180:/usr/lib/avr/include/avr/wdt.h ****     : \
 181:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 182:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 183:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 184:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 185:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 186:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 187:/usr/lib/avr/include/avr/wdt.h **** );
 188:/usr/lib/avr/include/avr/wdt.h **** 
 189:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 190:/usr/lib/avr/include/avr/wdt.h **** 
 191:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 192:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 193:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 194:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 195:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 196:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 197:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 198:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 199:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 200:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 201:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 202:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 203:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 204:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 205:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 206:/usr/lib/avr/include/avr/wdt.h **** )
 207:/usr/lib/avr/include/avr/wdt.h **** 
 208:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 209:/usr/lib/avr/include/avr/wdt.h **** do { \
 210:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 211:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 212:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 213:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 214:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 215:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 216:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 217:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 218:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 219:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 220:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 221:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 222:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 223:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 224:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 225:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 226:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 227:/usr/lib/avr/include/avr/wdt.h **** ); \
 228:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 229:/usr/lib/avr/include/avr/wdt.h **** 
 230:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 231:/usr/lib/avr/include/avr/wdt.h **** 
 232:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 233:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 234:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 235:/usr/lib/avr/include/avr/wdt.h **** {
 236:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 237:/usr/lib/avr/include/avr/wdt.h **** 	{
 238:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 239:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 240:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 241:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 242:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 243:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 244:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 245:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 246:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 247:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 248:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 249:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 250:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 251:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 252:/usr/lib/avr/include/avr/wdt.h **** 			);
 253:/usr/lib/avr/include/avr/wdt.h **** 	}
 254:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 255:/usr/lib/avr/include/avr/wdt.h **** 	{
 256:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 257:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 258:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 259:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 260:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 261:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 262:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 263:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 264:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 265:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 266:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 267:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 268:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 269:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 270:/usr/lib/avr/include/avr/wdt.h **** 			);
 271:/usr/lib/avr/include/avr/wdt.h **** 	}
 272:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 273:/usr/lib/avr/include/avr/wdt.h **** 	{
 274:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 275:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 276:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 277:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 278:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 279:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 280:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 281:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 282:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 283:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 284:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 285:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 286:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 287:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 288:/usr/lib/avr/include/avr/wdt.h **** 			);
 289:/usr/lib/avr/include/avr/wdt.h **** 	}
 290:/usr/lib/avr/include/avr/wdt.h **** 	else
 291:/usr/lib/avr/include/avr/wdt.h ****  	{
 292:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 293:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 294:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 295:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 296:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 297:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 298:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 299:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 300:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 301:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 302:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 303:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 304:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 305:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 306:/usr/lib/avr/include/avr/wdt.h **** 			);
 307:/usr/lib/avr/include/avr/wdt.h **** 	}
 308:/usr/lib/avr/include/avr/wdt.h **** }
 309:/usr/lib/avr/include/avr/wdt.h **** 
 310:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 311:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 312:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 313:/usr/lib/avr/include/avr/wdt.h **** {
 314:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 315:/usr/lib/avr/include/avr/wdt.h **** 	{
 316:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 317:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 318:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 319:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 320:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 321:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 322:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 323:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 327:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 328:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 329:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 330:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 331:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 332:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 333:/usr/lib/avr/include/avr/wdt.h **** 				);
 334:/usr/lib/avr/include/avr/wdt.h **** 	}
 335:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 336:/usr/lib/avr/include/avr/wdt.h **** 	{
 337:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 338:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 339:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 340:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 341:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 348:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 352:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 353:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 				);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 357:/usr/lib/avr/include/avr/wdt.h **** 	{
 358:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 359:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 360:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 361:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 362:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 363:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 364:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 365:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 366:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 369:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 370:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 371:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 372:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 373:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 374:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 375:/usr/lib/avr/include/avr/wdt.h **** 				);
 376:/usr/lib/avr/include/avr/wdt.h **** 	}
 377:/usr/lib/avr/include/avr/wdt.h **** 	else
 378:/usr/lib/avr/include/avr/wdt.h **** 	{
 379:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 380:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 381:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 382:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 383:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 384:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 385:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 386:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 387:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 390:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 391:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 392:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 393:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 394:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 395:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 396:/usr/lib/avr/include/avr/wdt.h **** 				);
 397:/usr/lib/avr/include/avr/wdt.h **** 	}
 398:/usr/lib/avr/include/avr/wdt.h **** }
 399:/usr/lib/avr/include/avr/wdt.h **** 
 400:/usr/lib/avr/include/avr/wdt.h **** #else
 401:/usr/lib/avr/include/avr/wdt.h **** 
 402:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 403:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 404:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 405:/usr/lib/avr/include/avr/wdt.h **** {
 406:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 407:/usr/lib/avr/include/avr/wdt.h **** 	{
 408:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 409:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 416:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 417:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 418:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 419:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 420:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 421:/usr/lib/avr/include/avr/wdt.h **** 		);
 422:/usr/lib/avr/include/avr/wdt.h **** 	}
 423:/usr/lib/avr/include/avr/wdt.h **** 	else
 424:/usr/lib/avr/include/avr/wdt.h **** 	{
 425:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 426:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 427:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 428:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 429:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 433:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 434:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 435:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 436:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 437:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 438:/usr/lib/avr/include/avr/wdt.h **** 		);
 439:/usr/lib/avr/include/avr/wdt.h **** 	}
 440:/usr/lib/avr/include/avr/wdt.h **** }
 441:/usr/lib/avr/include/avr/wdt.h **** 
 442:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 443:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 444:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 445:/usr/lib/avr/include/avr/wdt.h **** {
 446:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 447:/usr/lib/avr/include/avr/wdt.h **** 	{
 448:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 449:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2726               	.LM330:
 2727               	/* #APP */
 2728               	 ;  449 "/usr/lib/avr/include/avr/wdt.h" 1
 2729 005a 0FB6      		in __tmp_reg__,__SREG__
 2730 005c F894      		cli
 2731 005e A895      		wdr
 2732 0060 81B5      		in  r24,33
 2733 0062 8861      		ori r24,24
 2734 0064 81BD      		out 33,r24
 2735 0066 11BC      		out 33,__zero_reg__
 2736 0068 0FBE      		out __SREG__,__tmp_reg__
 2737               		
 2738               	 ;  0 "" 2
 2739               	/* #NOAPP */
 2740               	.LBE482:
 2741               	.LBE481:
 2742               	.LBB483:
 2743               	.LBB484:
 2745               	.Ltext38:
 163:/usr/lib/avr/include/util/delay.h **** 
 2747               	.LM331:
 2748 006a 2FE9      		ldi r18,lo8(99999)
 2749 006c 86E8      		ldi r24,hi8(99999)
 2750 006e 91E0      		ldi r25,hlo8(99999)
 2751 0070 2150      	1:	subi r18,1
 2752 0072 8040      		sbci r24,0
 2753 0074 9040      		sbci r25,0
 2754 0076 01F4      		brne 1b
 2755 0078 00C0      		rjmp .
 2756 007a 0000      		nop
 2757               	.LBE484:
 2758               	.LBE483:
 2760               	.Ltext39:
 677:main.c        **** 
 678:main.c        ****   wdt_disable();
 679:main.c        **** 
 680:main.c        ****   _delay_ms(500);
 681:main.c        **** 
 682:main.c        ****   PORTD |= (1 << LED_RED) | (1 << LED_GREEN);
 2762               	.LM332:
 2763 007c 82B3      		in r24,0x12
 2764 007e 8066      		ori r24,lo8(96)
 2765 0080 82BB      		out 0x12,r24
 683:main.c        **** 
 684:main.c        ****   TIMSK = 0;
 2767               	.LM333:
 2768 0082 17BE      		out 0x37,__zero_reg__
 685:main.c        ****   Timer0Init();
 2770               	.LM334:
 2771 0084 0E94 0000 		call Timer0Init
 686:main.c        ****   Timer1Init();
 2773               	.LM335:
 2774 0088 0E94 0000 		call Timer1Init
 687:main.c        ****   TWIinit();
 2776               	.LM336:
 2777 008c 0E94 0000 		call TWIinit
 688:main.c        ****   lcd_init();
 2779               	.LM337:
 2780 0090 0E94 0000 		call lcd_init
 689:main.c        ****   lcd_clrscr();
 2782               	.LM338:
 2783 0094 0E94 0000 		call lcd_clrscr
 690:main.c        ****   adcInit();
 2785               	.LM339:
 2786 0098 0E94 0000 		call adcInit
 2787               	.LBB485:
 2788               	.LBB486:
 2790               	.Ltext40:
 163:/usr/lib/avr/include/util/delay.h **** 
 2792               	.LM340:
 2793 009c AFE4      		ldi r26,lo8(-15537)
 2794 009e B3EC      		ldi r27,hi8(-15537)
 2795 00a0 1197      	1:	sbiw r26,1
 2796 00a2 01F4      		brne 1b
 2797 00a4 00C0      		rjmp .
 2798 00a6 0000      		nop
 2799               	.LBE486:
 2800               	.LBE485:
 2802               	.Ltext41:
 691:main.c        **** 
 692:main.c        ****   _delay_ms(200);
 693:main.c        **** 
 694:main.c        ****   PORTD &= ~((1 << LED_RED) | (1 << LED_GREEN));
 2804               	.LM341:
 2805 00a8 82B3      		in r24,0x12
 2806 00aa 8F79      		andi r24,lo8(-97)
 2807 00ac 82BB      		out 0x12,r24
 695:main.c        **** 
 696:main.c        ****   strcpy_P(buffer, string_intro_row1);
 2809               	.LM342:
 2810 00ae 60E0      		ldi r22,lo8(string_intro_row1.2452)
 2811 00b0 70E0      		ldi r23,hi8(string_intro_row1.2452)
 2812 00b2 CE01      		movw r24,r28
 2813 00b4 0196      		adiw r24,1
 2814 00b6 6C01      		movw r12,r24
 2815 00b8 0E94 0000 		call strcpy_P
 697:main.c        ****   lcd_puts(buffer);
 2817               	.LM343:
 2818 00bc C601      		movw r24,r12
 2819 00be 0E94 0000 		call lcd_puts
 698:main.c        ****   lcd_goto(0x40);
 2821               	.LM344:
 2822 00c2 80E4      		ldi r24,lo8(64)
 2823 00c4 0E94 0000 		call lcd_goto
 699:main.c        ****   strcpy_P(buffer, string_intro_row2);
 2825               	.LM345:
 2826 00c8 60E0      		ldi r22,lo8(string_intro_row2.2453)
 2827 00ca 70E0      		ldi r23,hi8(string_intro_row2.2453)
 2828 00cc C601      		movw r24,r12
 2829 00ce 0E94 0000 		call strcpy_P
 700:main.c        ****   lcd_puts(buffer);
 2831               	.LM346:
 2832 00d2 C601      		movw r24,r12
 2833 00d4 0E94 0000 		call lcd_puts
 701:main.c        **** 
 702:main.c        ****   rot_flag = 0x01;
 2835               	.LM347:
 2836 00d8 81E0      		ldi r24,lo8(1)
 2837 00da 8093 0000 		sts rot_flag,r24
 703:main.c        ****   mode_flag = 0x01;
 2839               	.LM348:
 2840 00de 8093 0000 		sts mode_flag,r24
 704:main.c        ****   band_flag = 0x02;
 2842               	.LM349:
 2843 00e2 82E0      		ldi r24,lo8(2)
 2844 00e4 8093 0000 		sts band_flag,r24
 705:main.c        ****   timer_flag = 0x00;
 2846               	.LM350:
 2847 00e8 1092 0000 		sts timer_flag,__zero_reg__
 706:main.c        **** 
 707:main.c        ****   band = 10;
 2849               	.LM351:
 2850 00ec 8AE0      		ldi r24,lo8(10)
 2851 00ee 8093 0000 		sts band,r24
 708:main.c        ****   freq = 7010;
 709:main.c        ****   step_timer = 255;
 2853               	.LM352:
 2854 00f2 8FEF      		ldi r24,lo8(-1)
 2855 00f4 90E0      		ldi r25,0
 2856 00f6 9093 0000 		sts step_timer+1,r25
 2857 00fa 8093 0000 		sts step_timer,r24
 710:main.c        ****   steps = 0;
 711:main.c        ****   last_dir = 0x00;
 712:main.c        ****   mode = 0x00;
 2859               	.LM353:
 2860 00fe 1092 0000 		sts mode,__zero_reg__
 713:main.c        ****   tx = 0x0000;
 2862               	.LM354:
 2863 0102 1092 0000 		sts tx+1,__zero_reg__
 2864 0106 1092 0000 		sts tx,__zero_reg__
 714:main.c        ****   rx_att = 0x00;
 2866               	.LM355:
 2867 010a 1092 0000 		sts rx_att,__zero_reg__
 715:main.c        ****   tx_att = 0x00;
 2869               	.LM356:
 2870 010e 1092 0000 		sts tx_att,__zero_reg__
 716:main.c        ****   rffe_rx_att = false;
 2872               	.LM357:
 2873 0112 1092 0000 		sts rffe_rx_att,__zero_reg__
 717:main.c        **** 
 718:main.c        ****   err = updateVolumeSquelch(vol, squelch);
 2875               	.LM358:
 2876 0116 60E0      		ldi r22,0
 2877 0118 88E1      		ldi r24,lo8(24)
 2878 011a 0E94 0000 		call updateVolumeSquelch
 2879               	.LBB487:
 2880               	.LBB488:
 2882               	.Ltext42:
 163:/usr/lib/avr/include/util/delay.h **** 
 2884               	.LM359:
 2885 011e 9FE7      		ldi r25,lo8(399999)
 2886 0120 AAE1      		ldi r26,hi8(399999)
 2887 0122 B6E0      		ldi r27,hlo8(399999)
 2888 0124 9150      	1:	subi r25,1
 2889 0126 A040      		sbci r26,0
 2890 0128 B040      		sbci r27,0
 2891 012a 01F4      		brne 1b
 2892 012c 00C0      		rjmp .
 2893 012e 0000      		nop
 2894               	.LBE488:
 2895               	.LBE487:
 2897               	.Ltext43:
 719:main.c        ****   
 720:main.c        ****   _delay_ms(2000);
 721:main.c        **** 
 722:main.c        ****   lcd_clrscr();
 2899               	.LM360:
 2900 0130 0E94 0000 		call lcd_clrscr
 723:main.c        ****   
 724:main.c        ****   sei();
 2902               	.LM361:
 2903               	/* #APP */
 2904               	 ;  724 "main.c" 1
 2905 0134 7894      		sei
 2906               	 ;  0 "" 2
 710:main.c        ****   last_dir = 0x00;
 2908               	.LM362:
 2909               	/* #NOAPP */
 2910 0136 412C      		mov r4,__zero_reg__
 2911 0138 512C      		mov r5,__zero_reg__
 645:main.c        ****   uint16_t steps;
 2913               	.LM363:
 2914 013a 48E1      		ldi r20,lo8(24)
 2915 013c 642E      		mov r6,r20
 644:main.c        ****   uint8_t vol = 0x18;
 2917               	.LM364:
 2918 013e 2FEF      		ldi r18,lo8(-1)
 2919 0140 2FAF      		std Y+63,r18
 643:main.c        ****   uint8_t tx_last = 255;
 2921               	.LM365:
 2922 0142 712C      		mov r7,__zero_reg__
 711:main.c        ****   mode = 0x00;
 2924               	.LM366:
 2925 0144 2396      		adiw r28,66-63
 2926 0146 1FAE      		std Y+63,__zero_reg__
 2927 0148 2397      		sbiw r28,66-63
 641:main.c        ****   uint8_t last_dir;
 2929               	.LM367:
 2930 014a A12C      		mov r10,__zero_reg__
 2931 014c B12C      		mov r11,__zero_reg__
 638:main.c        ****   int freq_offset = 0; // offset in MHz for display
 2933               	.LM368:
 2934 014e 1EAE      		std Y+62,__zero_reg__
 708:main.c        ****   step_timer = 255;
 2936               	.LM369:
 2937 0150 10E0      		ldi r17,0
 2938 0152 00E1      		ldi r16,lo8(16)
 2939 0154 5BED      		ldi r21,lo8(-37)
 2940 0156 F52E      		mov r15,r21
 2941 0158 65E4      		ldi r22,lo8(69)
 2942 015a E62E      		mov r14,r22
 2943               	.L148:
 725:main.c        **** 
 726:main.c        ****   while (1) {
 727:main.c        ****     if (timer_flag) {
 2945               	.LM370:
 2946 015c 8091 0000 		lds r24,timer_flag
 2947 0160 8823      		tst r24
 2948 0162 01F4      		brne .+2
 2949 0164 00C0      		rjmp .L149
 2950               	.LBB489:
 2951               	.LBB490:
 389:main.c        **** }
 2953               	.LM371:
 2954 0166 84B0      		in r8,0x4
 2955 0168 95B0      		in r9,0x4+1
 2956               	.LBE490:
 2957               	.LBE489:
 728:main.c        **** 
 729:main.c        **** #ifdef CLARPOT
 730:main.c        ****       clarval = readClar();
 731:main.c        **** #endif
 732:main.c        **** #ifndef CLARPOT
 733:main.c        ****       clarval = 0;
 734:main.c        **** #endif
 735:main.c        **** 
 736:main.c        ****       if ((clarval < clarval_last - 10) || (clarval > clarval_last + 10)) {
 2959               	.LM372:
 2960 016a C101      		movw r24,r2
 2961 016c 0A97      		sbiw r24,10
 2962 016e 8816      		cp r8,r24
 2963 0170 9906      		cpc r9,r25
 2964 0172 04F0      		brlt .L150
 2966               	.LM373:
 2967 0174 4496      		adiw r24,20
 2968 0176 8815      		cp r24,r8
 2969 0178 9905      		cpc r25,r9
 2970 017a 04F0      		brlt .+2
 2971 017c 00C0      		rjmp .L151
 2972               	.L150:
 737:main.c        **** 	clar = (int8_t)((clarval - 512) >> 2);
 2974               	.LM374:
 2975 017e A401      		movw r20,r8
 2976 0180 5250      		subi r21,2
 2977 0182 5595      		asr r21
 2978 0184 4795      		ror r20
 2979 0186 5595      		asr r21
 2980 0188 4795      		ror r20
 2981 018a 4EAF      		std Y+62,r20
 738:main.c        **** 	err = updateFreq(freq,clar,0);
 2983               	.LM375:
 2984 018c 20E0      		ldi r18,0
 2985 018e 612F      		mov r22,r17
 2986 0190 702F      		mov r23,r16
 2987 0192 8F2D      		mov r24,r15
 2988 0194 9E2D      		mov r25,r14
 2989 0196 0E94 0000 		call updateFreq
 739:main.c        **** 	if (err) {
 2991               	.LM376:
 2992 019a 8823      		tst r24
 2993 019c 01F0      		breq .L152
 740:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 2995               	.LM377:
 2996 019e 1F92      		push __zero_reg__
 2997 01a0 8F93      		push r24
 2998 01a2 80E0      		ldi r24,lo8(.LC0)
 2999 01a4 90E0      		ldi r25,hi8(.LC0)
 3000 01a6 9F93      		push r25
 3001 01a8 8F93      		push r24
 3002 01aa DF92      		push r13
 3003 01ac CF92      		push r12
 3004 01ae 0E94 0000 		call sprintf
 741:main.c        **** 	  lcd_goto(0x40);
 3006               	.LM378:
 3007 01b2 80E4      		ldi r24,lo8(64)
 3008 01b4 0E94 0000 		call lcd_goto
 742:main.c        **** 	  lcd_puts(buffer);	
 3010               	.LM379:
 3011 01b8 C601      		movw r24,r12
 3012 01ba 0E94 0000 		call lcd_puts
 3013 01be 0F90      		pop __tmp_reg__
 3014 01c0 0F90      		pop __tmp_reg__
 3015 01c2 0F90      		pop __tmp_reg__
 3016 01c4 0F90      		pop __tmp_reg__
 3017 01c6 0F90      		pop __tmp_reg__
 3018 01c8 0F90      		pop __tmp_reg__
 3019 01ca 00C0      		rjmp .L304
 3020               	.L152:
 743:main.c        **** 	}
 744:main.c        **** 	else {
 745:main.c        **** 	  lcd_freq();
 3022               	.LM380:
 3023 01cc 84E0      		ldi r24,lo8(4)
 3024 01ce 0E94 0000 		call lcd_goto
 3025 01d2 20E0      		ldi r18,0
 3026 01d4 30E0      		ldi r19,0
 3027 01d6 4AE7      		ldi r20,lo8(122)
 3028 01d8 54E4      		ldi r21,lo8(68)
 3029 01da 612F      		mov r22,r17
 3030 01dc 702F      		mov r23,r16
 3031 01de 8F2D      		mov r24,r15
 3032 01e0 9E2D      		mov r25,r14
 3033 01e2 0E94 0000 		call fmod
 3034 01e6 2496      		adiw r28,67-63
 3035 01e8 6FAF      		std Y+63,r22
 3036 01ea 2497      		sbiw r28,67-63
 3037 01ec 2596      		adiw r28,68-63
 3038 01ee 7FAF      		std Y+63,r23
 3039 01f0 2597      		sbiw r28,68-63
 3040 01f2 382E      		mov r3,r24
 3041 01f4 292E      		mov r2,r25
 3042 01f6 20E0      		ldi r18,0
 3043 01f8 30E0      		ldi r19,0
 3044 01fa 4AE7      		ldi r20,lo8(122)
 3045 01fc 54E4      		ldi r21,lo8(68)
 3046 01fe 612F      		mov r22,r17
 3047 0200 702F      		mov r23,r16
 3048 0202 8F2D      		mov r24,r15
 3049 0204 9E2D      		mov r25,r14
 3050 0206 0E94 0000 		call __divsf3
 3051 020a 20E0      		ldi r18,0
 3052 020c 30E0      		ldi r19,0
 3053 020e A901      		movw r20,r18
 3054 0210 0E94 0000 		call __addsf3
 3055 0214 0E94 0000 		call floor
 3056 0218 2F92      		push r2
 3057 021a 3F92      		push r3
 3058 021c 2596      		adiw r28,68-63
 3059 021e AFAD      		ldd r26,Y+63
 3060 0220 2597      		sbiw r28,68-63
 3061 0222 AF93      		push r26
 3062 0224 2496      		adiw r28,67-63
 3063 0226 BFAD      		ldd r27,Y+63
 3064 0228 2497      		sbiw r28,67-63
 3065 022a BF93      		push r27
 3066 022c 0E94 0000 		call __fixsfsi
 3067 0230 7F93      		push r23
 3068 0232 6F93      		push r22
 3069 0234 80E0      		ldi r24,lo8(.LC1)
 3070 0236 90E0      		ldi r25,hi8(.LC1)
 3071 0238 9F93      		push r25
 3072 023a 8F93      		push r24
 3073 023c DF92      		push r13
 3074 023e CF92      		push r12
 3075 0240 0E94 0000 		call sprintf
 3076 0244 C601      		movw r24,r12
 3077 0246 0E94 0000 		call lcd_puts
 3078 024a 8FE0      		ldi r24,lo8(15)
 3079 024c 0E94 0000 		call lcd_goto
 3080 0250 0FB6      		in __tmp_reg__,__SREG__
 3081 0252 F894      		cli
 3082 0254 DEBF      		out __SP_H__,r29
 3083 0256 0FBE      		out __SREG__,__tmp_reg__
 3084 0258 CDBF      		out __SP_L__,r28
 3085 025a 9EAD      		ldd r25,Y+62
 3086 025c 9B30      		cpi r25,lo8(11)
 3087 025e 04F0      		brlt .L153
 3089               	.LM381:
 3090 0260 60E0      		ldi r22,lo8(.LC2)
 3091 0262 70E0      		ldi r23,hi8(.LC2)
 3092 0264 00C0      		rjmp .L303
 3093               	.L153:
 3095               	.LM382:
 3096 0266 AEAD      		ldd r26,Y+62
 3097 0268 A63F      		cpi r26,lo8(-10)
 3098 026a 04F4      		brge .L155
 3100               	.LM383:
 3101 026c 60E0      		ldi r22,lo8(.LC3)
 3102 026e 70E0      		ldi r23,hi8(.LC3)
 3103 0270 00C0      		rjmp .L303
 3104               	.L155:
 3106               	.LM384:
 3107 0272 60E0      		ldi r22,lo8(.LC4)
 3108 0274 70E0      		ldi r23,hi8(.LC4)
 3109               	.L303:
 3110 0276 C601      		movw r24,r12
 3111 0278 0E94 0000 		call strcpy
 3112 027c C601      		movw r24,r12
 3113 027e 0E94 0000 		call lcd_puts
 3114               	.L304:
 730:main.c        **** #endif
 3116               	.LM385:
 3117 0282 1401      		movw r2,r8
 3118               	.L151:
 746:main.c        **** 	}
 747:main.c        **** 	clarval_last = clarval;
 748:main.c        ****       }
 749:main.c        **** 
 750:main.c        ****       if (vol_timer < 255)
 3120               	.LM386:
 3121 0284 8091 0000 		lds r24,vol_timer
 3122 0288 8F3F      		cpi r24,lo8(-1)
 3123 028a 01F0      		breq .L156
 751:main.c        **** 	vol_timer ++;
 3125               	.LM387:
 3126 028c 8091 0000 		lds r24,vol_timer
 3127 0290 8F5F      		subi r24,lo8(-(1))
 3128 0292 8093 0000 		sts vol_timer,r24
 3129               	.L156:
 752:main.c        **** 
 753:main.c        ****       // Band button
 754:main.c        **** 
 755:main.c        ****       if (band_timer < 9) { // Recently pressed ?
 3131               	.LM388:
 3132 0296 8091 0000 		lds r24,band_timer
 3133 029a 8930      		cpi r24,lo8(9)
 3134 029c 00F4      		brsh .L157
 756:main.c        **** 	band_timer ++;
 3136               	.LM389:
 3137 029e 8091 0000 		lds r24,band_timer
 3138 02a2 8F5F      		subi r24,lo8(-(1))
 3139 02a4 8093 0000 		sts band_timer,r24
 757:main.c        **** 	if ((band_timer < 9) && (PINF & (1 << BAND_BUTTON))) {
 3141               	.LM390:
 3142 02a8 8091 0000 		lds r24,band_timer
 3143 02ac 8930      		cpi r24,lo8(9)
 3144 02ae 00F4      		brsh .L158
 3146               	.LM391:
 3147 02b0 009B      		sbis 0,0
 3148 02b2 00C0      		rjmp .L158
 758:main.c        **** 	  band_flag = 0x01; // short press
 3150               	.LM392:
 3151 02b4 81E0      		ldi r24,lo8(1)
 3152 02b6 8093 0000 		sts band_flag,r24
 759:main.c        **** 	  band_timer = 255;
 3154               	.LM393:
 3155 02ba 8FEF      		ldi r24,lo8(-1)
 3156 02bc 8093 0000 		sts band_timer,r24
 3157               	.L158:
 760:main.c        **** 	}
 761:main.c        **** 	if ((band_timer == 9) && (!(PINF & (1 << BAND_BUTTON)))) 
 3159               	.LM394:
 3160 02c0 8091 0000 		lds r24,band_timer
 3161 02c4 8930      		cpi r24,lo8(9)
 3162 02c6 01F4      		brne .L160
 3164               	.LM395:
 3165 02c8 0099      		sbic 0,0
 3166 02ca 00C0      		rjmp .L160
 762:main.c        **** 	  band_flag = 0x02; // long press
 3168               	.LM396:
 3169 02cc 82E0      		ldi r24,lo8(2)
 3170 02ce 8093 0000 		sts band_flag,r24
 3171 02d2 00C0      		rjmp .L160
 3172               	.L157:
 763:main.c        ****       }
 764:main.c        ****       else if (!(PINF & (1 << BAND_BUTTON))) {  // New press
 3174               	.LM397:
 3175 02d4 009B      		sbis 0,0
 765:main.c        **** 	band_timer = 0;
 3177               	.LM398:
 3178 02d6 1092 0000 		sts band_timer,__zero_reg__
 3179               	.L160:
 766:main.c        ****       }
 767:main.c        **** 
 768:main.c        ****       // Mode button
 769:main.c        **** 
 770:main.c        ****       if (!(PINF & (1 << MODE_BUTTON))) {
 3181               	.LM399:
 3182 02da 0199      		sbic 0,1
 3183 02dc 00C0      		rjmp .L162
 771:main.c        **** 	mode_flag = 0x01;
 3185               	.LM400:
 3186 02de 81E0      		ldi r24,lo8(1)
 3187 02e0 8093 0000 		sts mode_flag,r24
 3188               	.L162:
 772:main.c        ****       }
 773:main.c        ****       
 774:main.c        ****       // Update frequency if necessary:
 775:main.c        ****       if (freq != freq_last) {
 3190               	.LM401:
 3191 02e4 2196      		adiw r28,64-63
 3192 02e6 2FAD      		ldd r18,Y+63
 3193 02e8 2197      		sbiw r28,64-63
 3194 02ea 2296      		adiw r28,65-63
 3195 02ec 3FAD      		ldd r19,Y+63
 3196 02ee 2297      		sbiw r28,65-63
 3197 02f0 2696      		adiw r28,69-63
 3198 02f2 4FAD      		ldd r20,Y+63
 3199 02f4 2697      		sbiw r28,69-63
 3200 02f6 2796      		adiw r28,70-63
 3201 02f8 5FAD      		ldd r21,Y+63
 3202 02fa 2797      		sbiw r28,70-63
 3203 02fc 612F      		mov r22,r17
 3204 02fe 702F      		mov r23,r16
 3205 0300 8F2D      		mov r24,r15
 3206 0302 9E2D      		mov r25,r14
 3207 0304 0E94 0000 		call __nesf2
 3208 0308 8823      		tst r24
 3209 030a 01F4      		brne .+2
 3210 030c 00C0      		rjmp .L163
 776:main.c        **** 	lcd_freq();
 3212               	.LM402:
 3213 030e 84E0      		ldi r24,lo8(4)
 3214 0310 0E94 0000 		call lcd_goto
 3215 0314 20E0      		ldi r18,0
 3216 0316 30E0      		ldi r19,0
 3217 0318 4AE7      		ldi r20,lo8(122)
 3218 031a 54E4      		ldi r21,lo8(68)
 3219 031c 612F      		mov r22,r17
 3220 031e 702F      		mov r23,r16
 3221 0320 8F2D      		mov r24,r15
 3222 0322 9E2D      		mov r25,r14
 3223 0324 0E94 0000 		call fmod
 3224 0328 962E      		mov r9,r22
 3225 032a 872E      		mov r8,r23
 3226 032c 2196      		adiw r28,64-63
 3227 032e 8FAF      		std Y+63,r24
 3228 0330 2197      		sbiw r28,64-63
 3229 0332 2296      		adiw r28,65-63
 3230 0334 9FAF      		std Y+63,r25
 3231 0336 2297      		sbiw r28,65-63
 3232 0338 20E0      		ldi r18,0
 3233 033a 30E0      		ldi r19,0
 3234 033c 4AE7      		ldi r20,lo8(122)
 3235 033e 54E4      		ldi r21,lo8(68)
 3236 0340 612F      		mov r22,r17
 3237 0342 702F      		mov r23,r16
 3238 0344 8F2D      		mov r24,r15
 3239 0346 9E2D      		mov r25,r14
 3240 0348 0E94 0000 		call __divsf3
 3241 034c 20E0      		ldi r18,0
 3242 034e 30E0      		ldi r19,0
 3243 0350 A901      		movw r20,r18
 3244 0352 0E94 0000 		call __addsf3
 3245 0356 0E94 0000 		call floor
 3246 035a 2296      		adiw r28,65-63
 3247 035c BFAD      		ldd r27,Y+63
 3248 035e 2297      		sbiw r28,65-63
 3249 0360 BF93      		push r27
 3250 0362 2196      		adiw r28,64-63
 3251 0364 2FAD      		ldd r18,Y+63
 3252 0366 2197      		sbiw r28,64-63
 3253 0368 2F93      		push r18
 3254 036a 8F92      		push r8
 3255 036c 9F92      		push r9
 3256 036e 0E94 0000 		call __fixsfsi
 3257 0372 7F93      		push r23
 3258 0374 6F93      		push r22
 3259 0376 80E0      		ldi r24,lo8(.LC1)
 3260 0378 90E0      		ldi r25,hi8(.LC1)
 3261 037a 9F93      		push r25
 3262 037c 8F93      		push r24
 3263 037e DF92      		push r13
 3264 0380 CF92      		push r12
 3265 0382 0E94 0000 		call sprintf
 3266 0386 C601      		movw r24,r12
 3267 0388 0E94 0000 		call lcd_puts
 3268 038c 8FE0      		ldi r24,lo8(15)
 3269 038e 0E94 0000 		call lcd_goto
 3270 0392 0FB6      		in __tmp_reg__,__SREG__
 3271 0394 F894      		cli
 3272 0396 DEBF      		out __SP_H__,r29
 3273 0398 0FBE      		out __SREG__,__tmp_reg__
 3274 039a CDBF      		out __SP_L__,r28
 3275 039c 9EAD      		ldd r25,Y+62
 3276 039e 9B30      		cpi r25,lo8(11)
 3277 03a0 04F0      		brlt .L165
 3279               	.LM403:
 3280 03a2 60E0      		ldi r22,lo8(.LC2)
 3281 03a4 70E0      		ldi r23,hi8(.LC2)
 3282 03a6 00C0      		rjmp .L305
 3283               	.L165:
 3285               	.LM404:
 3286 03a8 AEAD      		ldd r26,Y+62
 3287 03aa A63F      		cpi r26,lo8(-10)
 3288 03ac 04F4      		brge .L167
 3290               	.LM405:
 3291 03ae 60E0      		ldi r22,lo8(.LC3)
 3292 03b0 70E0      		ldi r23,hi8(.LC3)
 3293 03b2 00C0      		rjmp .L305
 3294               	.L167:
 3296               	.LM406:
 3297 03b4 60E0      		ldi r22,lo8(.LC4)
 3298 03b6 70E0      		ldi r23,hi8(.LC4)
 3299               	.L305:
 3300 03b8 C601      		movw r24,r12
 3301 03ba 0E94 0000 		call strcpy
 3302 03be C601      		movw r24,r12
 3303 03c0 0E94 0000 		call lcd_puts
 777:main.c        **** 	err = updateFreq(freq,clar,1);
 3305               	.LM407:
 3306 03c4 21E0      		ldi r18,lo8(1)
 3307 03c6 4EAD      		ldd r20,Y+62
 3308 03c8 612F      		mov r22,r17
 3309 03ca 702F      		mov r23,r16
 3310 03cc 8F2D      		mov r24,r15
 3311 03ce 9E2D      		mov r25,r14
 3312 03d0 0E94 0000 		call updateFreq
 778:main.c        **** 	if (err) {
 3314               	.LM408:
 3315 03d4 8823      		tst r24
 3316 03d6 01F0      		breq .L243
 779:main.c        **** 	  sprintf(buffer,"Err %x         ",err);
 3318               	.LM409:
 3319 03d8 1F92      		push __zero_reg__
 3320 03da 8F93      		push r24
 3321 03dc 80E0      		ldi r24,lo8(.LC0)
 3322 03de 90E0      		ldi r25,hi8(.LC0)
 3323 03e0 9F93      		push r25
 3324 03e2 8F93      		push r24
 3325 03e4 DF92      		push r13
 3326 03e6 CF92      		push r12
 3327 03e8 0E94 0000 		call sprintf
 780:main.c        **** 	  lcd_goto(0x40);
 3329               	.LM410:
 3330 03ec 80E4      		ldi r24,lo8(64)
 3331 03ee 0E94 0000 		call lcd_goto
 781:main.c        **** 	  lcd_puts(buffer);	
 3333               	.LM411:
 3334 03f2 C601      		movw r24,r12
 3335 03f4 0E94 0000 		call lcd_puts
 3336 03f8 0F90      		pop __tmp_reg__
 3337 03fa 0F90      		pop __tmp_reg__
 3338 03fc 0F90      		pop __tmp_reg__
 3339 03fe 0F90      		pop __tmp_reg__
 3340 0400 0F90      		pop __tmp_reg__
 3341 0402 0F90      		pop __tmp_reg__
 3342               	.L243:
 782:main.c        **** 	}
 783:main.c        **** 	freq_last = freq;
 3344               	.LM412:
 3345 0404 2196      		adiw r28,64-63
 3346 0406 1FAF      		std Y+63,r17
 3347 0408 2197      		sbiw r28,64-63
 3348 040a 2296      		adiw r28,65-63
 3349 040c 0FAF      		std Y+63,r16
 3350 040e 2297      		sbiw r28,65-63
 3351 0410 2696      		adiw r28,69-63
 3352 0412 FFAE      		std Y+63,r15
 3353 0414 2697      		sbiw r28,69-63
 3354 0416 2796      		adiw r28,70-63
 3355 0418 EFAE      		std Y+63,r14
 3356 041a 2797      		sbiw r28,70-63
 3357               	.L163:
 784:main.c        ****       }
 785:main.c        **** 
 786:main.c        ****       // Read RSSI and status:
 787:main.c        ****       err = TWI_read_byte(fpga_addr, &data);
 3359               	.LM413:
 3360 041c BE01      		movw r22,r28
 3361 041e 635C      		subi r22,-61
 3362 0420 7F4F      		sbci r23,-1
 3363 0422 83E2      		ldi r24,lo8(35)
 3364 0424 0E94 0000 		call TWI_read_byte
 788:main.c        ****       if (!err) {
 3366               	.LM414:
 3367 0428 8111      		cpse r24,__zero_reg__
 3368 042a 00C0      		rjmp .L168
 789:main.c        **** 	if ((data & 0x80) && (tx_last != 1)) { // Shift to TX ?
 3370               	.LM415:
 3371 042c 8DAD      		ldd r24,Y+61
 3372 042e 87FF      		sbrs r24,7
 3373 0430 00C0      		rjmp .L169
 3375               	.LM416:
 3376 0432 BFAD      		ldd r27,Y+63
 3377 0434 B130      		cpi r27,lo8(1)
 3378 0436 01F0      		breq .L170
 790:main.c        **** 	  tx = 0x0001;
 3380               	.LM417:
 3381 0438 81E0      		ldi r24,lo8(1)
 3382 043a 90E0      		ldi r25,0
 3383 043c 9093 0000 		sts tx+1,r25
 3384 0440 8093 0000 		sts tx,r24
 791:main.c        **** 	  updateRFFE();
 3386               	.LM418:
 3387 0444 0E94 0000 		call updateRFFE
 792:main.c        **** 	  PORTD |= (1 << LED_RED);
 3389               	.LM419:
 3390 0448 969A      		sbi 0x12,6
 793:main.c        **** 	  PORTD &= ~(1 << LED_GREEN);
 3392               	.LM420:
 3393 044a 9598      		cbi 0x12,5
 794:main.c        **** 	  tx_last = 1;
 3395               	.LM421:
 3396 044c 21E0      		ldi r18,lo8(1)
 3397 044e 2FAF      		std Y+63,r18
 3398 0450 00C0      		rjmp .L170
 3399               	.L169:
 795:main.c        **** 	}
 796:main.c        **** 	else if (!(data & 0x80) && (tx_last != 0)) { // Shift to RX ?
 3401               	.LM422:
 3402 0452 8FAD      		ldd r24,Y+63
 3403 0454 8823      		tst r24
 3404 0456 01F0      		breq .L170
 797:main.c        **** 	  tx = 0x0000;
 3406               	.LM423:
 3407 0458 1092 0000 		sts tx+1,__zero_reg__
 3408 045c 1092 0000 		sts tx,__zero_reg__
 798:main.c        **** 	  updateRFFE();
 3410               	.LM424:
 3411 0460 0E94 0000 		call updateRFFE
 799:main.c        **** 	  PORTD |= (1 << LED_GREEN);
 3413               	.LM425:
 3414 0464 959A      		sbi 0x12,5
 800:main.c        **** 	  PORTD &= ~(1 << LED_RED);
 3416               	.LM426:
 3417 0466 9698      		cbi 0x12,6
 801:main.c        **** 	  tx_last = 0;
 3419               	.LM427:
 3420 0468 1FAE      		std Y+63,__zero_reg__
 3421 046a 00C0      		rjmp .L170
 3422               	.L168:
 802:main.c        **** 	}
 803:main.c        ****       }
 804:main.c        ****       else { // error
 805:main.c        **** 	PORTD &= ~((1 << LED_RED)|(1 << LED_GREEN));
 3424               	.LM428:
 3425 046c 82B3      		in r24,0x12
 3426 046e 8F79      		andi r24,lo8(-97)
 3427 0470 82BB      		out 0x12,r24
 3428               	.L170:
 806:main.c        ****       }
 807:main.c        **** 
 808:main.c        ****       rssi = (0x3f & data); 
 3430               	.LM429:
 3431 0472 8DAD      		ldd r24,Y+61
 3432 0474 8F73      		andi r24,lo8(63)
 3433 0476 B816      		cp r11,r24
 3434 0478 00F4      		brsh .L171
 3435 047a B82E      		mov r11,r24
 3436               	.L171:
 809:main.c        ****       if (rssi_max < rssi) 
 810:main.c        **** 	rssi_max = rssi;
 811:main.c        ****       rssi_count ++;
 3438               	.LM430:
 3439 047c A394      		inc r10
 812:main.c        ****       if ((!rffe_rx_att && rssi_count > 2) || (rffe_rx_att && rssi_count > 2)) {
 3441               	.LM431:
 3442 047e 8091 0000 		lds r24,rffe_rx_att
 3443 0482 8111      		cpse r24,__zero_reg__
 3444 0484 00C0      		rjmp .L172
 3446               	.LM432:
 3447 0486 92E0      		ldi r25,lo8(2)
 3448 0488 9A15      		cp r25,r10
 3449 048a 00F0      		brlo .L173
 3450               	.L172:
 3452               	.LM433:
 3453 048c 8091 0000 		lds r24,rffe_rx_att
 3454 0490 8823      		tst r24
 3455 0492 01F4      		brne .+2
 3456 0494 00C0      		rjmp .L174
 3458               	.LM434:
 3459 0496 A2E0      		ldi r26,lo8(2)
 3460 0498 AA15      		cp r26,r10
 3461 049a 00F0      		brlo .+2
 3462 049c 00C0      		rjmp .L174
 3463               	.L173:
 813:main.c        **** 	rssi_count = 0;
 814:main.c        **** 	if (rssi_max < 4)
 3465               	.LM435:
 3466 049e B3E0      		ldi r27,lo8(3)
 3467 04a0 BB15      		cp r27,r11
 3468 04a2 00F4      		brsh .L244
 815:main.c        **** 	  rssi = 0;
 816:main.c        **** 	else 
 817:main.c        **** 	  rssi = rssi_max - 4;
 3470               	.LM436:
 3471 04a4 8CEF      		ldi r24,lo8(-4)
 3472 04a6 8B0D      		add r24,r11
 3473 04a8 00C0      		rjmp .L175
 3474               	.L244:
 815:main.c        **** 	  rssi = 0;
 3476               	.LM437:
 3477 04aa 80E0      		ldi r24,0
 3478               	.L175:
 818:main.c        **** 	rssi_max = 0;
 819:main.c        **** 
 820:main.c        **** 	if (vol_timer < 10); // Don't print if vol info
 3480               	.LM438:
 3481 04ac 9091 0000 		lds r25,vol_timer
 3482 04b0 9A30      		cpi r25,lo8(10)
 3483 04b2 00F4      		brsh .+2
 3484 04b4 00C0      		rjmp .L245
 821:main.c        **** 	else if (rffe_rx_att && (rssi>9)) {
 3486               	.LM439:
 3487 04b6 9091 0000 		lds r25,rffe_rx_att
 3488 04ba 9923      		tst r25
 3489 04bc 01F0      		breq .L176
 3491               	.LM440:
 3492 04be 8A30      		cpi r24,lo8(10)
 3493 04c0 00F0      		brlo .L176
 822:main.c        **** 	  sprintf(buffer,"S---9+++   ");
 3495               	.LM441:
 3496 04c2 60E0      		ldi r22,lo8(.LC5)
 3497 04c4 70E0      		ldi r23,hi8(.LC5)
 3498 04c6 00C0      		rjmp .L314
 3499               	.L176:
 823:main.c        **** 	  lcd_goto(0x40);
 824:main.c        **** 	  lcd_puts(buffer);
 825:main.c        **** 	}
 826:main.c        **** 	else if (rffe_rx_att && (rssi < 10)) {
 3501               	.LM442:
 3502 04c8 9091 0000 		lds r25,rffe_rx_att
 3503 04cc 9923      		tst r25
 3504 04ce 01F0      		breq .L177
 3506               	.LM443:
 3507 04d0 8A30      		cpi r24,lo8(10)
 3508 04d2 00F4      		brsh .L178
 827:main.c        **** 	  rffe_rx_att = false;
 3510               	.LM444:
 3511 04d4 1092 0000 		sts rffe_rx_att,__zero_reg__
 3512 04d8 00C0      		rjmp .L313
 3513               	.L177:
 828:main.c        **** 	  err = updateRFFE();
 829:main.c        **** 	}
 830:main.c        **** 	else if (rssi < 2) { 
 3515               	.LM445:
 3516 04da 8230      		cpi r24,lo8(2)
 3517 04dc 00F4      		brsh .L179
 831:main.c        **** 	  sprintf(buffer,"S%d         ",rssi);
 3519               	.LM446:
 3520 04de 1F92      		push __zero_reg__
 3521 04e0 8F93      		push r24
 3522 04e2 80E0      		ldi r24,lo8(.LC6)
 3523 04e4 90E0      		ldi r25,hi8(.LC6)
 3524 04e6 00C0      		rjmp .L318
 3525               	.L179:
 832:main.c        **** 	  lcd_goto(0x40);
 833:main.c        **** 	  lcd_puts(buffer);
 834:main.c        **** 	}
 835:main.c        **** 	else if (rssi < 4) {
 3527               	.LM447:
 3528 04e8 8430      		cpi r24,lo8(4)
 3529 04ea 00F4      		brsh .L178
 836:main.c        **** 	  sprintf(buffer,"S-%d        ",rssi);
 3531               	.LM448:
 3532 04ec 1F92      		push __zero_reg__
 3533 04ee 8F93      		push r24
 3534 04f0 80E0      		ldi r24,lo8(.LC7)
 3535 04f2 90E0      		ldi r25,hi8(.LC7)
 3536 04f4 00C0      		rjmp .L318
 3537               	.L178:
 837:main.c        **** 	  lcd_goto(0x40);
 838:main.c        **** 	  lcd_puts(buffer);
 839:main.c        ****  	}
 840:main.c        **** 	else if (rssi < 6) {
 3539               	.LM449:
 3540 04f6 8630      		cpi r24,lo8(6)
 3541 04f8 00F4      		brsh .L180
 841:main.c        **** 	  sprintf(buffer,"S--%d       ",rssi);
 3543               	.LM450:
 3544 04fa 1F92      		push __zero_reg__
 3545 04fc 8F93      		push r24
 3546 04fe 80E0      		ldi r24,lo8(.LC8)
 3547 0500 90E0      		ldi r25,hi8(.LC8)
 3548 0502 00C0      		rjmp .L318
 3549               	.L180:
 842:main.c        **** 	  lcd_goto(0x40);
 843:main.c        **** 	  lcd_puts(buffer);
 844:main.c        **** 	}
 845:main.c        **** 	else if (rssi < 8) {
 3551               	.LM451:
 3552 0504 8830      		cpi r24,lo8(8)
 3553 0506 00F4      		brsh .L181
 846:main.c        **** 	  sprintf(buffer,"S---%d      ",rssi);
 3555               	.LM452:
 3556 0508 1F92      		push __zero_reg__
 3557 050a 8F93      		push r24
 3558 050c 80E0      		ldi r24,lo8(.LC9)
 3559 050e 90E0      		ldi r25,hi8(.LC9)
 3560               	.L318:
 3561 0510 9F93      		push r25
 3562 0512 8F93      		push r24
 3563 0514 00C0      		rjmp .L315
 3564               	.L181:
 847:main.c        **** 	  lcd_goto(0x40);
 848:main.c        **** 	  lcd_puts(buffer);
 849:main.c        **** 	}
 850:main.c        **** 	else if (rssi < 10) {
 3566               	.LM453:
 3567 0516 8A30      		cpi r24,lo8(10)
 3568 0518 00F4      		brsh .L182
 851:main.c        **** 	  sprintf(buffer,"S----%d     ",rssi);
 3570               	.LM454:
 3571 051a 1F92      		push __zero_reg__
 3572 051c 8F93      		push r24
 3573 051e A0E0      		ldi r26,lo8(.LC10)
 3574 0520 B0E0      		ldi r27,hi8(.LC10)
 3575 0522 BF93      		push r27
 3576 0524 AF93      		push r26
 3577               	.L315:
 3578 0526 DF92      		push r13
 3579 0528 CF92      		push r12
 3580 052a 0E94 0000 		call sprintf
 852:main.c        **** 	  lcd_goto(0x40);
 3582               	.LM455:
 3583 052e 80E4      		ldi r24,lo8(64)
 3584 0530 0E94 0000 		call lcd_goto
 853:main.c        **** 	  lcd_puts(buffer);
 3586               	.LM456:
 3587 0534 C601      		movw r24,r12
 3588 0536 0E94 0000 		call lcd_puts
 3589 053a 0F90      		pop __tmp_reg__
 3590 053c 0F90      		pop __tmp_reg__
 3591 053e 0F90      		pop __tmp_reg__
 3592 0540 0F90      		pop __tmp_reg__
 3593 0542 0F90      		pop __tmp_reg__
 3594 0544 0F90      		pop __tmp_reg__
 3595 0546 00C0      		rjmp .L245
 3596               	.L182:
 854:main.c        **** 	}
 855:main.c        **** 	else if (rssi < 12) {
 3598               	.LM457:
 3599 0548 8C30      		cpi r24,lo8(12)
 3600 054a 00F4      		brsh .L183
 856:main.c        **** 	  sprintf(buffer,"S----9+    ");
 3602               	.LM458:
 3603 054c 60E0      		ldi r22,lo8(.LC11)
 3604 054e 70E0      		ldi r23,hi8(.LC11)
 3605 0550 00C0      		rjmp .L314
 3606               	.L183:
 857:main.c        **** 	  lcd_goto(0x40);
 858:main.c        **** 	  lcd_puts(buffer);
 859:main.c        **** 	}
 860:main.c        **** 	else if (rssi < 13 ){
 3608               	.LM459:
 3609 0552 8C30      		cpi r24,lo8(12)
 3610 0554 01F4      		brne .L184
 861:main.c        **** 	  sprintf(buffer,"S----9++   ");
 3612               	.LM460:
 3613 0556 60E0      		ldi r22,lo8(.LC12)
 3614 0558 70E0      		ldi r23,hi8(.LC12)
 3615               	.L314:
 3616 055a C601      		movw r24,r12
 3617 055c 0E94 0000 		call strcpy
 862:main.c        **** 	  lcd_goto(0x40);
 3619               	.LM461:
 3620 0560 80E4      		ldi r24,lo8(64)
 3621 0562 0E94 0000 		call lcd_goto
 863:main.c        **** 	  lcd_puts(buffer);
 3623               	.LM462:
 3624 0566 C601      		movw r24,r12
 3625 0568 0E94 0000 		call lcd_puts
 3626 056c 00C0      		rjmp .L245
 3627               	.L184:
 864:main.c        **** 	}
 865:main.c        **** 	else {
 866:main.c        **** 	  rffe_rx_att = true;
 3629               	.LM463:
 3630 056e 81E0      		ldi r24,lo8(1)
 3631 0570 8093 0000 		sts rffe_rx_att,r24
 3632               	.L313:
 867:main.c        **** 	  err = updateRFFE();
 3634               	.LM464:
 3635 0574 0E94 0000 		call updateRFFE
 3636               	.L245:
 813:main.c        **** 	if (rssi_max < 4)
 3638               	.LM465:
 3639 0578 A12C      		mov r10,__zero_reg__
 818:main.c        **** 
 3641               	.LM466:
 3642 057a B12C      		mov r11,__zero_reg__
 3643               	.L174:
 868:main.c        **** 	}
 869:main.c        **** 	rssi = 0;
 870:main.c        ****       }
 871:main.c        ****       timer_flag = 0;
 3645               	.LM467:
 3646 057c 1092 0000 		sts timer_flag,__zero_reg__
 3647 0580 00C0      		rjmp .L185
 3648               	.L149:
 872:main.c        ****     }
 873:main.c        ****     else if (mode_flag) {
 3650               	.LM468:
 3651 0582 8091 0000 		lds r24,mode_flag
 3652 0586 8823      		tst r24
 3653 0588 01F4      		brne .+2
 3654 058a 00C0      		rjmp .L185
 874:main.c        ****       switch (mode) {
 3656               	.LM469:
 3657 058c 8091 0000 		lds r24,mode
 3658 0590 8330      		cpi r24,lo8(3)
 3659 0592 01F0      		breq .L187
 3660 0594 00F4      		brsh .L188
 3661 0596 8130      		cpi r24,lo8(1)
 3662 0598 01F0      		breq .L189
 3663 059a 00C0      		rjmp .L186
 3664               	.L188:
 3665 059c 8530      		cpi r24,lo8(5)
 3666 059e 01F0      		breq .L190
 3667 05a0 8630      		cpi r24,lo8(6)
 3668 05a2 01F0      		breq .L191
 3669 05a4 00C0      		rjmp .L186
 3670               	.L189:
 875:main.c        ****       case LSB:
 876:main.c        **** 	mode = USB;
 3672               	.LM470:
 3673 05a6 83E0      		ldi r24,lo8(3)
 3674 05a8 8093 0000 		sts mode,r24
 877:main.c        **** 	if (!updateSettings()) { 
 3676               	.LM471:
 3677 05ac 0E94 0000 		call updateSettings
 3678 05b0 8111      		cpse r24,__zero_reg__
 3679 05b2 00C0      		rjmp .L193
 878:main.c        **** 	  lcd_goto(0x00);
 3681               	.LM472:
 3682 05b4 0E94 0000 		call lcd_goto
 879:main.c        **** 	  sprintf(buffer,"USB ");
 3684               	.LM473:
 3685 05b8 60E0      		ldi r22,lo8(.LC13)
 3686 05ba 70E0      		ldi r23,hi8(.LC13)
 3687 05bc 00C0      		rjmp .L306
 3688               	.L187:
 880:main.c        **** 	  lcd_puts(buffer);
 881:main.c        **** 	}
 882:main.c        **** 	break;
 883:main.c        ****       case USB:
 884:main.c        **** 	mode = CW;
 3690               	.LM474:
 3691 05be 85E0      		ldi r24,lo8(5)
 3692 05c0 8093 0000 		sts mode,r24
 885:main.c        **** 	if(!updateSettings()) {
 3694               	.LM475:
 3695 05c4 0E94 0000 		call updateSettings
 3696 05c8 8111      		cpse r24,__zero_reg__
 3697 05ca 00C0      		rjmp .L193
 886:main.c        **** 	  lcd_goto(0x00);
 3699               	.LM476:
 3700 05cc 0E94 0000 		call lcd_goto
 887:main.c        **** 	  sprintf(buffer,"CW  ");
 3702               	.LM477:
 3703 05d0 60E0      		ldi r22,lo8(.LC14)
 3704 05d2 70E0      		ldi r23,hi8(.LC14)
 3705 05d4 00C0      		rjmp .L306
 3706               	.L190:
 888:main.c        **** 	  lcd_puts(buffer);
 889:main.c        **** 	}
 890:main.c        **** 	break;
 891:main.c        ****       case CW:
 892:main.c        **** 	mode = CWN;
 3708               	.LM478:
 3709 05d6 86E0      		ldi r24,lo8(6)
 3710 05d8 8093 0000 		sts mode,r24
 893:main.c        **** 	if(!updateSettings()) {
 3712               	.LM479:
 3713 05dc 0E94 0000 		call updateSettings
 3714 05e0 8111      		cpse r24,__zero_reg__
 3715 05e2 00C0      		rjmp .L193
 894:main.c        **** 	  lcd_goto(0x00);
 3717               	.LM480:
 3718 05e4 0E94 0000 		call lcd_goto
 895:main.c        **** 	  sprintf(buffer,"CWN ");
 3720               	.LM481:
 3721 05e8 60E0      		ldi r22,lo8(.LC15)
 3722 05ea 70E0      		ldi r23,hi8(.LC15)
 3723 05ec 00C0      		rjmp .L306
 3724               	.L191:
 896:main.c        **** 	  lcd_puts(buffer);
 897:main.c        **** 	}
 898:main.c        **** 	break;
 899:main.c        ****       case CWN:
 900:main.c        **** 	if (band < 200) {
 3726               	.LM482:
 3727 05ee 8091 0000 		lds r24,band
 3728 05f2 883C      		cpi r24,lo8(-56)
 3729 05f4 00F4      		brsh .L195
 901:main.c        **** 	  mode = AM;
 3731               	.LM483:
 3732 05f6 88E0      		ldi r24,lo8(8)
 3733 05f8 8093 0000 		sts mode,r24
 902:main.c        **** 	  if(!updateSettings()) {
 3735               	.LM484:
 3736 05fc 0E94 0000 		call updateSettings
 3737 0600 8111      		cpse r24,__zero_reg__
 3738 0602 00C0      		rjmp .L193
 903:main.c        **** 	    lcd_goto(0x00);
 3740               	.LM485:
 3741 0604 0E94 0000 		call lcd_goto
 904:main.c        **** 	    sprintf(buffer,"AM  ");
 3743               	.LM486:
 3744 0608 60E0      		ldi r22,lo8(.LC16)
 3745 060a 70E0      		ldi r23,hi8(.LC16)
 3746 060c 00C0      		rjmp .L306
 3747               	.L195:
 905:main.c        **** 	    lcd_puts(buffer);
 906:main.c        **** 	  }
 907:main.c        **** 	}
 908:main.c        **** 	else {
 909:main.c        **** 	  mode = FM;
 3749               	.LM487:
 3750 060e 8AE0      		ldi r24,lo8(10)
 3751 0610 8093 0000 		sts mode,r24
 910:main.c        **** 	  if(!updateSettings()) {
 3753               	.LM488:
 3754 0614 0E94 0000 		call updateSettings
 3755 0618 8111      		cpse r24,__zero_reg__
 3756 061a 00C0      		rjmp .L193
 911:main.c        **** 	    lcd_goto(0x00);
 3758               	.LM489:
 3759 061c 0E94 0000 		call lcd_goto
 912:main.c        **** 	    sprintf(buffer,"FM  ");
 3761               	.LM490:
 3762 0620 60E0      		ldi r22,lo8(.LC17)
 3763 0622 70E0      		ldi r23,hi8(.LC17)
 3764 0624 00C0      		rjmp .L306
 3765               	.L186:
 913:main.c        **** 	    lcd_puts(buffer);
 914:main.c        **** 	  }
 915:main.c        **** 	}	  
 916:main.c        **** 	break;
 917:main.c        ****       case AM:
 918:main.c        ****       case FM:
 919:main.c        ****       default:
 920:main.c        **** 	mode = LSB;
 3767               	.LM491:
 3768 0626 81E0      		ldi r24,lo8(1)
 3769 0628 8093 0000 		sts mode,r24
 921:main.c        **** 	if(!updateSettings()) { 
 3771               	.LM492:
 3772 062c 0E94 0000 		call updateSettings
 3773 0630 8111      		cpse r24,__zero_reg__
 3774 0632 00C0      		rjmp .L193
 922:main.c        **** 	  lcd_goto(0x00);
 3776               	.LM493:
 3777 0634 0E94 0000 		call lcd_goto
 923:main.c        **** 	  sprintf(buffer,"LSB ");
 3779               	.LM494:
 3780 0638 60E0      		ldi r22,lo8(.LC18)
 3781 063a 70E0      		ldi r23,hi8(.LC18)
 3782               	.L306:
 3783 063c C601      		movw r24,r12
 3784 063e 0E94 0000 		call strcpy
 924:main.c        **** 	  lcd_puts(buffer);
 3786               	.LM495:
 3787 0642 C601      		movw r24,r12
 3788 0644 0E94 0000 		call lcd_puts
 3789               	.L193:
 3790               	.LBB491:
 3791               	.LBB492:
 3793               	.Ltext44:
 163:/usr/lib/avr/include/util/delay.h **** 
 3795               	.LM496:
 3796 0648 83E2      		ldi r24,lo8(-3037)
 3797 064a 94EF      		ldi r25,hi8(-3037)
 3798 064c 0197      	1:	sbiw r24,1
 3799 064e 01F4      		brne 1b
 3800 0650 00C0      		rjmp .
 3801 0652 0000      		nop
 3802               	.LBE492:
 3803               	.LBE491:
 3805               	.Ltext45:
 925:main.c        **** 	}
 926:main.c        **** 	break;
 927:main.c        ****       }
 928:main.c        ****       _delay_ms(250);
 929:main.c        ****       err = updateFreq(freq,clar,1);  // To shift +/-
 3807               	.LM497:
 3808 0654 21E0      		ldi r18,lo8(1)
 3809 0656 4EAD      		ldd r20,Y+62
 3810 0658 612F      		mov r22,r17
 3811 065a 702F      		mov r23,r16
 3812 065c 8F2D      		mov r24,r15
 3813 065e 9E2D      		mov r25,r14
 3814 0660 0E94 0000 		call updateFreq
 930:main.c        ****       mode_flag = 0x00;
 3816               	.LM498:
 3817 0664 1092 0000 		sts mode_flag,__zero_reg__
 3818               	.L185:
 931:main.c        ****     }
 932:main.c        **** 
 933:main.c        ****     if (band_flag) {
 3820               	.LM499:
 3821 0668 8091 0000 		lds r24,band_flag
 3822 066c 8823      		tst r24
 3823 066e 01F4      		brne .+2
 3824 0670 00C0      		rjmp .L196
 934:main.c        ****       if (band_flag == 0x02) { // long press
 3826               	.LM500:
 3827 0672 8091 0000 		lds r24,band_flag
 3828 0676 8230      		cpi r24,lo8(2)
 3829 0678 01F4      		brne .+2
 3830 067a 00C0      		rjmp .L197
 935:main.c        **** #ifdef TWOMETER_TRANSV
 936:main.c        **** 	if (band == 200) {
 937:main.c        **** 	  band = 201;
 938:main.c        **** 	  freq_offset = 1152;
 939:main.c        **** 	  freq = 144200;
 940:main.c        **** 	  tx_att = 0x01;
 941:main.c        **** 	  rx_att = 0x00;
 942:main.c        **** 	  updateSettings();
 943:main.c        **** 	}
 944:main.c        **** 	else if (band == 201) {
 945:main.c        **** 	  band = 202;
 946:main.c        **** 	  freq_offset = 5616;
 947:main.c        **** 	  freq = 144200;
 948:main.c        **** 	  tx_att = 0x01;
 949:main.c        **** 	  rx_att = 0x00;
 950:main.c        **** 	  updateSettings();
 951:main.c        **** 	}
 952:main.c        **** 	else {
 953:main.c        **** 	  band = 200;
 954:main.c        **** 	  freq_offset = 0;
 955:main.c        **** 	  freq = 144300;
 956:main.c        **** 	  tx_att = 0x00;
 957:main.c        **** 	  rx_att = 0x00;
 958:main.c        **** 	  updateSettings();
 959:main.c        **** 	  /*
 960:main.c        **** 	  band = 160;
 961:main.c        **** 	  freq_offset = 0;
 962:main.c        **** 	  freq = 1810;
 963:main.c        **** 	  tx_att = 0x00;
 964:main.c        **** 	  */
 965:main.c        **** 	}
 966:main.c        **** #endif
 967:main.c        ****       }
 968:main.c        ****       else {
 969:main.c        **** #ifdef HF_HAM
 970:main.c        **** 	if (freq<3500)
 3832               	.LM501:
 3833 067c 20E0      		ldi r18,0
 3834 067e 30EC      		ldi r19,lo8(-64)
 3835 0680 4AE5      		ldi r20,lo8(90)
 3836 0682 55E4      		ldi r21,lo8(69)
 3837 0684 612F      		mov r22,r17
 3838 0686 702F      		mov r23,r16
 3839 0688 8F2D      		mov r24,r15
 3840 068a 9E2D      		mov r25,r14
 3841 068c 0E94 0000 		call __ltsf2
 3842 0690 87FD      		sbrc r24,7
 3843 0692 00C0      		rjmp .L246
 971:main.c        **** 	  freq = 3510;
 972:main.c        **** 	else if(freq<7000)
 3845               	.LM502:
 3846 0694 20E0      		ldi r18,0
 3847 0696 30EC      		ldi r19,lo8(-64)
 3848 0698 4AED      		ldi r20,lo8(-38)
 3849 069a 55E4      		ldi r21,lo8(69)
 3850 069c 612F      		mov r22,r17
 3851 069e 702F      		mov r23,r16
 3852 06a0 8F2D      		mov r24,r15
 3853 06a2 9E2D      		mov r25,r14
 3854 06a4 0E94 0000 		call __ltsf2
 3855 06a8 87FD      		sbrc r24,7
 3856 06aa 00C0      		rjmp .L247
 973:main.c        **** 	  freq = 7010;
 974:main.c        **** 	else if(freq<10100)
 3858               	.LM503:
 3859 06ac 20E0      		ldi r18,0
 3860 06ae 30ED      		ldi r19,lo8(-48)
 3861 06b0 4DE1      		ldi r20,lo8(29)
 3862 06b2 56E4      		ldi r21,lo8(70)
 3863 06b4 612F      		mov r22,r17
 3864 06b6 702F      		mov r23,r16
 3865 06b8 8F2D      		mov r24,r15
 3866 06ba 9E2D      		mov r25,r14
 3867 06bc 0E94 0000 		call __ltsf2
 3868 06c0 87FD      		sbrc r24,7
 3869 06c2 00C0      		rjmp .L248
 975:main.c        **** 	  freq = 10110;
 976:main.c        **** 	else if(freq<14000)
 3871               	.LM504:
 3872 06c4 20E0      		ldi r18,0
 3873 06c6 30EC      		ldi r19,lo8(-64)
 3874 06c8 4AE5      		ldi r20,lo8(90)
 3875 06ca 56E4      		ldi r21,lo8(70)
 3876 06cc 612F      		mov r22,r17
 3877 06ce 702F      		mov r23,r16
 3878 06d0 8F2D      		mov r24,r15
 3879 06d2 9E2D      		mov r25,r14
 3880 06d4 0E94 0000 		call __ltsf2
 3881 06d8 87FD      		sbrc r24,7
 3882 06da 00C0      		rjmp .L249
 977:main.c        **** 	  freq = 14010;
 978:main.c        **** 	else if(freq<18068)
 3884               	.LM505:
 3885 06dc 20E0      		ldi r18,0
 3886 06de 38E2      		ldi r19,lo8(40)
 3887 06e0 4DE8      		ldi r20,lo8(-115)
 3888 06e2 56E4      		ldi r21,lo8(70)
 3889 06e4 612F      		mov r22,r17
 3890 06e6 702F      		mov r23,r16
 3891 06e8 8F2D      		mov r24,r15
 3892 06ea 9E2D      		mov r25,r14
 3893 06ec 0E94 0000 		call __ltsf2
 3894 06f0 87FD      		sbrc r24,7
 3895 06f2 00C0      		rjmp .L250
 979:main.c        **** 	  freq = 18078;
 980:main.c        **** 	else if(freq<21000)
 3897               	.LM506:
 3898 06f4 20E0      		ldi r18,0
 3899 06f6 30E1      		ldi r19,lo8(16)
 3900 06f8 44EA      		ldi r20,lo8(-92)
 3901 06fa 56E4      		ldi r21,lo8(70)
 3902 06fc 612F      		mov r22,r17
 3903 06fe 702F      		mov r23,r16
 3904 0700 8F2D      		mov r24,r15
 3905 0702 9E2D      		mov r25,r14
 3906 0704 0E94 0000 		call __ltsf2
 3907 0708 87FD      		sbrc r24,7
 3908 070a 00C0      		rjmp .L251
 981:main.c        **** 	  freq = 21010;
 982:main.c        **** 	else if(freq<24890)
 3910               	.LM507:
 3911 070c 20E0      		ldi r18,0
 3912 070e 34E7      		ldi r19,lo8(116)
 3913 0710 42EC      		ldi r20,lo8(-62)
 3914 0712 56E4      		ldi r21,lo8(70)
 3915 0714 612F      		mov r22,r17
 3916 0716 702F      		mov r23,r16
 3917 0718 8F2D      		mov r24,r15
 3918 071a 9E2D      		mov r25,r14
 3919 071c 0E94 0000 		call __ltsf2
 3920 0720 87FD      		sbrc r24,7
 3921 0722 00C0      		rjmp .L252
 983:main.c        **** 	  freq = 24900;
 984:main.c        **** 	else if(freq<28000)
 3923               	.LM508:
 3924 0724 20E0      		ldi r18,0
 3925 0726 30EC      		ldi r19,lo8(-64)
 3926 0728 4AED      		ldi r20,lo8(-38)
 3927 072a 56E4      		ldi r21,lo8(70)
 3928 072c 612F      		mov r22,r17
 3929 072e 702F      		mov r23,r16
 3930 0730 8F2D      		mov r24,r15
 3931 0732 9E2D      		mov r25,r14
 3932 0734 0E94 0000 		call __ltsf2
 3933 0738 87FD      		sbrc r24,7
 3934 073a 00C0      		rjmp .L253
 985:main.c        **** 	  freq = 28010;
 986:main.c        **** 	else if(freq<28500)
 3936               	.LM509:
 3937 073c 20E0      		ldi r18,0
 3938 073e 38EA      		ldi r19,lo8(-88)
 3939 0740 4EED      		ldi r20,lo8(-34)
 3940 0742 56E4      		ldi r21,lo8(70)
 3941 0744 612F      		mov r22,r17
 3942 0746 702F      		mov r23,r16
 3943 0748 8F2D      		mov r24,r15
 3944 074a 9E2D      		mov r25,r14
 3945 074c 0E94 0000 		call __ltsf2
 987:main.c        **** 	  freq = 28600;
 3947               	.LM510:
 3948 0750 10E0      		ldi r17,0
 986:main.c        **** 	  freq = 28600;
 3950               	.LM511:
 3951 0752 87FD      		sbrc r24,7
 3952 0754 00C0      		rjmp .L254
 988:main.c        **** 	else
 989:main.c        **** 	  freq = 1810;
 3954               	.LM512:
 3955 0756 00E4      		ldi r16,lo8(64)
 3956 0758 92EE      		ldi r25,lo8(-30)
 3957 075a F92E      		mov r15,r25
 3958 075c 24E4      		ldi r18,lo8(68)
 3959 075e E22E      		mov r14,r18
 3960 0760 00C0      		rjmp .L197
 3961               	.L246:
 971:main.c        **** 	else if(freq<7000)
 3963               	.LM513:
 3964 0762 10E0      		ldi r17,0
 3965 0764 00E6      		ldi r16,lo8(96)
 3966 0766 8BE5      		ldi r24,lo8(91)
 3967 0768 F82E      		mov r15,r24
 3968 076a 00C0      		rjmp .L308
 3969               	.L247:
 973:main.c        **** 	else if(freq<10100)
 3971               	.LM514:
 3972 076c 10E0      		ldi r17,0
 3973 076e 00E1      		ldi r16,lo8(16)
 3974 0770 BBED      		ldi r27,lo8(-37)
 3975 0772 FB2E      		mov r15,r27
 3976               	.L308:
 3977 0774 A5E4      		ldi r26,lo8(69)
 3978 0776 EA2E      		mov r14,r26
 3979 0778 00C0      		rjmp .L197
 3980               	.L248:
 975:main.c        **** 	else if(freq<14000)
 3982               	.LM515:
 3983 077a 10E0      		ldi r17,0
 3984 077c 08EF      		ldi r16,lo8(-8)
 3985 077e FDE1      		ldi r31,lo8(29)
 3986 0780 FF2E      		mov r15,r31
 3987 0782 00C0      		rjmp .L307
 3988               	.L249:
 977:main.c        **** 	else if(freq<18068)
 3990               	.LM516:
 3991 0784 10E0      		ldi r17,0
 3992 0786 08EE      		ldi r16,lo8(-24)
 3993 0788 EAE5      		ldi r30,lo8(90)
 3994 078a FE2E      		mov r15,r30
 3995 078c 00C0      		rjmp .L307
 3996               	.L250:
 979:main.c        **** 	else if(freq<21000)
 3998               	.LM517:
 3999 078e 10E0      		ldi r17,0
 4000 0790 0CE3      		ldi r16,lo8(60)
 4001 0792 7DE8      		ldi r23,lo8(-115)
 4002 0794 F72E      		mov r15,r23
 4003 0796 00C0      		rjmp .L307
 4004               	.L251:
 981:main.c        **** 	else if(freq<24890)
 4006               	.LM518:
 4007 0798 10E0      		ldi r17,0
 4008 079a 04E2      		ldi r16,lo8(36)
 4009 079c 64EA      		ldi r22,lo8(-92)
 4010 079e F62E      		mov r15,r22
 4011 07a0 00C0      		rjmp .L307
 4012               	.L252:
 983:main.c        **** 	else if(freq<28000)
 4014               	.LM519:
 4015 07a2 10E0      		ldi r17,0
 4016 07a4 08E8      		ldi r16,lo8(-120)
 4017 07a6 52EC      		ldi r21,lo8(-62)
 4018 07a8 F52E      		mov r15,r21
 4019 07aa 00C0      		rjmp .L307
 4020               	.L253:
 985:main.c        **** 	else if(freq<28500)
 4022               	.LM520:
 4023 07ac 10E0      		ldi r17,0
 4024 07ae 04ED      		ldi r16,lo8(-44)
 4025 07b0 4AED      		ldi r20,lo8(-38)
 4026 07b2 F42E      		mov r15,r20
 4027 07b4 00C0      		rjmp .L307
 4028               	.L254:
 987:main.c        **** 	else
 4030               	.LM521:
 4031 07b6 00E7      		ldi r16,lo8(112)
 4032 07b8 3FED      		ldi r19,lo8(-33)
 4033 07ba F32E      		mov r15,r19
 4034               	.L307:
 4035 07bc 26E4      		ldi r18,lo8(70)
 4036 07be E22E      		mov r14,r18
 4037               	.L197:
 990:main.c        **** #endif
 991:main.c        **** #ifdef TWOMETER
 992:main.c        ****       if(freq<144150)
 993:main.c        **** 	freq = 144300;
 994:main.c        ****       else if(freq<144400)
 995:main.c        **** 	freq = 144450;
 996:main.c        ****       else if(freq<145000)
 997:main.c        **** 	freq = 145500;
 998:main.c        ****       else if(freq<150000)
 999:main.c        **** 	freq = 144050;
1000:main.c        **** #endif
1001:main.c        **** #ifdef TWOMETER_TRANSV
1002:main.c        ****       if(freq<144700)
1003:main.c        **** 	freq = 144800;
1004:main.c        ****       else if(freq<150000)
1005:main.c        **** 	freq = 144200;
1006:main.c        **** #endif
1007:main.c        ****       }
1008:main.c        **** 
1009:main.c        ****       lcd_freq();
 4039               	.LM522:
 4040 07c0 84E0      		ldi r24,lo8(4)
 4041 07c2 0E94 0000 		call lcd_goto
 4042 07c6 20E0      		ldi r18,0
 4043 07c8 30E0      		ldi r19,0
 4044 07ca 4AE7      		ldi r20,lo8(122)
 4045 07cc 54E4      		ldi r21,lo8(68)
 4046 07ce 612F      		mov r22,r17
 4047 07d0 702F      		mov r23,r16
 4048 07d2 8F2D      		mov r24,r15
 4049 07d4 9E2D      		mov r25,r14
 4050 07d6 0E94 0000 		call fmod
 4051 07da 962E      		mov r9,r22
 4052 07dc 872E      		mov r8,r23
 4053 07de 2496      		adiw r28,67-63
 4054 07e0 8FAF      		std Y+63,r24
 4055 07e2 2497      		sbiw r28,67-63
 4056 07e4 2596      		adiw r28,68-63
 4057 07e6 9FAF      		std Y+63,r25
 4058 07e8 2597      		sbiw r28,68-63
 4059 07ea 20E0      		ldi r18,0
 4060 07ec 30E0      		ldi r19,0
 4061 07ee 4AE7      		ldi r20,lo8(122)
 4062 07f0 54E4      		ldi r21,lo8(68)
 4063 07f2 612F      		mov r22,r17
 4064 07f4 702F      		mov r23,r16
 4065 07f6 8F2D      		mov r24,r15
 4066 07f8 9E2D      		mov r25,r14
 4067 07fa 0E94 0000 		call __divsf3
 4068 07fe 20E0      		ldi r18,0
 4069 0800 30E0      		ldi r19,0
 4070 0802 A901      		movw r20,r18
 4071 0804 0E94 0000 		call __addsf3
 4072 0808 0E94 0000 		call floor
 4073 080c 2596      		adiw r28,68-63
 4074 080e AFAD      		ldd r26,Y+63
 4075 0810 2597      		sbiw r28,68-63
 4076 0812 AF93      		push r26
 4077 0814 2496      		adiw r28,67-63
 4078 0816 BFAD      		ldd r27,Y+63
 4079 0818 2497      		sbiw r28,67-63
 4080 081a BF93      		push r27
 4081 081c 8F92      		push r8
 4082 081e 9F92      		push r9
 4083 0820 0E94 0000 		call __fixsfsi
 4084 0824 7F93      		push r23
 4085 0826 6F93      		push r22
 4086 0828 80E0      		ldi r24,lo8(.LC1)
 4087 082a 90E0      		ldi r25,hi8(.LC1)
 4088 082c 9F93      		push r25
 4089 082e 8F93      		push r24
 4090 0830 DF92      		push r13
 4091 0832 CF92      		push r12
 4092 0834 0E94 0000 		call sprintf
 4093 0838 C601      		movw r24,r12
 4094 083a 0E94 0000 		call lcd_puts
 4095 083e 8FE0      		ldi r24,lo8(15)
 4096 0840 0E94 0000 		call lcd_goto
 4097 0844 0FB6      		in __tmp_reg__,__SREG__
 4098 0846 F894      		cli
 4099 0848 DEBF      		out __SP_H__,r29
 4100 084a 0FBE      		out __SREG__,__tmp_reg__
 4101 084c CDBF      		out __SP_L__,r28
 4102 084e 9EAD      		ldd r25,Y+62
 4103 0850 9B30      		cpi r25,lo8(11)
 4104 0852 04F0      		brlt .L198
 4106               	.LM523:
 4107 0854 60E0      		ldi r22,lo8(.LC2)
 4108 0856 70E0      		ldi r23,hi8(.LC2)
 4109 0858 00C0      		rjmp .L309
 4110               	.L198:
 4112               	.LM524:
 4113 085a AEAD      		ldd r26,Y+62
 4114 085c A63F      		cpi r26,lo8(-10)
 4115 085e 04F4      		brge .L200
 4117               	.LM525:
 4118 0860 60E0      		ldi r22,lo8(.LC3)
 4119 0862 70E0      		ldi r23,hi8(.LC3)
 4120 0864 00C0      		rjmp .L309
 4121               	.L200:
 4123               	.LM526:
 4124 0866 60E0      		ldi r22,lo8(.LC4)
 4125 0868 70E0      		ldi r23,hi8(.LC4)
 4126               	.L309:
 4127 086a C601      		movw r24,r12
 4128 086c 0E94 0000 		call strcpy
 4129 0870 C601      		movw r24,r12
 4130 0872 0E94 0000 		call lcd_puts
1010:main.c        ****       err = updateFreq(freq,clar,1);
 4132               	.LM527:
 4133 0876 21E0      		ldi r18,lo8(1)
 4134 0878 4EAD      		ldd r20,Y+62
 4135 087a 612F      		mov r22,r17
 4136 087c 702F      		mov r23,r16
 4137 087e 8F2D      		mov r24,r15
 4138 0880 9E2D      		mov r25,r14
 4139 0882 0E94 0000 		call updateFreq
1011:main.c        ****       if (err) {
 4141               	.LM528:
 4142 0886 8823      		tst r24
 4143 0888 01F0      		breq .L201
1012:main.c        **** 	sprintf(buffer,"Err freq %x         ",err);
 4145               	.LM529:
 4146 088a 1F92      		push __zero_reg__
 4147 088c 8F93      		push r24
 4148 088e 80E0      		ldi r24,lo8(.LC19)
 4149 0890 90E0      		ldi r25,hi8(.LC19)
 4150 0892 9F93      		push r25
 4151 0894 8F93      		push r24
 4152 0896 DF92      		push r13
 4153 0898 CF92      		push r12
 4154 089a 0E94 0000 		call sprintf
1013:main.c        **** 	lcd_goto(0x40);
 4156               	.LM530:
 4157 089e 80E4      		ldi r24,lo8(64)
 4158 08a0 0E94 0000 		call lcd_goto
1014:main.c        **** 	lcd_puts(buffer);	
 4160               	.LM531:
 4161 08a4 C601      		movw r24,r12
 4162 08a6 0E94 0000 		call lcd_puts
 4163 08aa 0F90      		pop __tmp_reg__
 4164 08ac 0F90      		pop __tmp_reg__
 4165 08ae 0F90      		pop __tmp_reg__
 4166 08b0 0F90      		pop __tmp_reg__
 4167 08b2 0F90      		pop __tmp_reg__
 4168 08b4 0F90      		pop __tmp_reg__
 4169               	.L201:
1015:main.c        ****       }      
1016:main.c        ****       err = updateSettings();
 4171               	.LM532:
 4172 08b6 0E94 0000 		call updateSettings
1017:main.c        ****       if (err) {
 4174               	.LM533:
 4175 08ba 8823      		tst r24
 4176 08bc 01F0      		breq .L202
1018:main.c        **** 	sprintf(buffer,"Err sett %x         ",err);
 4178               	.LM534:
 4179 08be 1F92      		push __zero_reg__
 4180 08c0 8F93      		push r24
 4181 08c2 80E0      		ldi r24,lo8(.LC20)
 4182 08c4 90E0      		ldi r25,hi8(.LC20)
 4183 08c6 9F93      		push r25
 4184 08c8 8F93      		push r24
 4185 08ca DF92      		push r13
 4186 08cc CF92      		push r12
 4187 08ce 0E94 0000 		call sprintf
1019:main.c        **** 	lcd_goto(0x40);
 4189               	.LM535:
 4190 08d2 80E4      		ldi r24,lo8(64)
 4191 08d4 0E94 0000 		call lcd_goto
1020:main.c        **** 	lcd_puts(buffer);	
 4193               	.LM536:
 4194 08d8 C601      		movw r24,r12
 4195 08da 0E94 0000 		call lcd_puts
 4196 08de 0F90      		pop __tmp_reg__
 4197 08e0 0F90      		pop __tmp_reg__
 4198 08e2 0F90      		pop __tmp_reg__
 4199 08e4 0F90      		pop __tmp_reg__
 4200 08e6 0F90      		pop __tmp_reg__
 4201 08e8 0F90      		pop __tmp_reg__
 4202               	.L202:
 4203               	.LBB493:
 4204               	.LBB494:
 4206               	.Ltext46:
 163:/usr/lib/avr/include/util/delay.h **** 
 4208               	.LM537:
 4209 08ea 8FE4      		ldi r24,lo8(-15537)
 4210 08ec 93EC      		ldi r25,hi8(-15537)
 4211 08ee 0197      	1:	sbiw r24,1
 4212 08f0 01F4      		brne 1b
 4213 08f2 00C0      		rjmp .
 4214 08f4 0000      		nop
 4215               	.LBE494:
 4216               	.LBE493:
 4218               	.Ltext47:
1021:main.c        ****       }      
1022:main.c        ****       _delay_ms(200);
1023:main.c        ****       band_flag = 0x00;
 4220               	.LM538:
 4221 08f6 1092 0000 		sts band_flag,__zero_reg__
 4222 08fa 00C0      		rjmp .L148
 4223               	.L196:
1024:main.c        ****     }
1025:main.c        ****     else if (rot_flag) {
 4225               	.LM539:
 4226 08fc 8091 0000 		lds r24,rot_flag
 4227 0900 8823      		tst r24
 4228 0902 01F4      		brne .+2
 4229 0904 00C0      		rjmp .L204
1026:main.c        ****       if (rot_flag != last_dir) {
 4231               	.LM540:
 4232 0906 8091 0000 		lds r24,rot_flag
 4233 090a 2396      		adiw r28,66-63
 4234 090c 9FAD      		ldd r25,Y+63
 4235 090e 2397      		sbiw r28,66-63
 4236 0910 8917      		cp r24,r25
 4237 0912 01F0      		breq .L205
1027:main.c        **** 	steps = 0;
1028:main.c        **** 	step_timer = 0;
 4239               	.LM541:
 4240 0914 1092 0000 		sts step_timer+1,__zero_reg__
 4241 0918 1092 0000 		sts step_timer,__zero_reg__
1029:main.c        **** 	last_dir = rot_flag;
 4243               	.LM542:
 4244 091c 8091 0000 		lds r24,rot_flag
1027:main.c        **** 	steps = 0;
 4246               	.LM543:
 4247 0920 412C      		mov r4,__zero_reg__
 4248 0922 512C      		mov r5,__zero_reg__
 4249 0924 00C0      		rjmp .L206
 4250               	.L205:
1030:main.c        ****       }
1031:main.c        ****       else if (rot_flag == 0x01) {
 4252               	.LM544:
 4253 0926 9091 0000 		lds r25,rot_flag
 4254 092a 9130      		cpi r25,lo8(1)
 4255 092c 01F0      		breq .+2
 4256 092e 00C0      		rjmp .L207
1032:main.c        **** 	if (step_timer < 30) {
 4258               	.LM545:
 4259 0930 8091 0000 		lds r24,step_timer
 4260 0934 9091 0000 		lds r25,step_timer+1
1033:main.c        **** 	  step_timer = 0;
 4262               	.LM546:
 4263 0938 1092 0000 		sts step_timer+1,__zero_reg__
 4264 093c 1092 0000 		sts step_timer,__zero_reg__
1032:main.c        **** 	if (step_timer < 30) {
 4266               	.LM547:
 4267 0940 4E97      		sbiw r24,30
 4268 0942 00F4      		brsh .L208
1034:main.c        **** 	  steps ++;
 4270               	.LM548:
 4271 0944 AFEF      		ldi r26,-1
 4272 0946 4A1A      		sub r4,r26
 4273 0948 5A0A      		sbc r5,r26
1035:main.c        **** 	}
1036:main.c        **** 	else {
1037:main.c        **** 	  step_timer = 0;
1038:main.c        **** 	  steps = 1;
1039:main.c        **** 	}
1040:main.c        **** 	
1041:main.c        **** 	if (steps > 500) {
 4275               	.LM549:
 4276 094a B5EF      		ldi r27,-11
 4277 094c 4B16      		cp r4,r27
 4278 094e B1E0      		ldi r27,1
 4279 0950 5B06      		cpc r5,r27
 4280 0952 00F4      		brsh .L209
 4281 0954 00C0      		rjmp .L319
 4282               	.L208:
1038:main.c        **** 	}
 4284               	.LM550:
 4285 0956 4424      		clr r4
 4286 0958 4394      		inc r4
 4287 095a 512C      		mov r5,__zero_reg__
 4288 095c 00C0      		rjmp .L211
 4289               	.L209:
1042:main.c        **** 	  if (mode == AM)
 4291               	.LM551:
 4292 095e 8091 0000 		lds r24,mode
 4293 0962 8830      		cpi r24,lo8(8)
 4294 0964 01F4      		brne .L212
1043:main.c        **** 	    freq += 20;
 4296               	.LM552:
 4297 0966 20E0      		ldi r18,0
 4298 0968 30E0      		ldi r19,0
 4299 096a 40EA      		ldi r20,lo8(-96)
 4300 096c 51E4      		ldi r21,lo8(65)
 4301 096e 00C0      		rjmp .L310
 4302               	.L212:
1044:main.c        **** 	  else if (mode == FM)
 4304               	.LM553:
 4305 0970 8091 0000 		lds r24,mode
 4306 0974 8A30      		cpi r24,lo8(10)
 4307 0976 01F4      		brne .L316
1045:main.c        **** 	    freq += 50;
 4309               	.LM554:
 4310 0978 20E0      		ldi r18,0
 4311 097a 30E0      		ldi r19,0
 4312 097c 48E4      		ldi r20,lo8(72)
 4313 097e 52E4      		ldi r21,lo8(66)
 4314 0980 00C0      		rjmp .L310
 4315               	.L319:
1046:main.c        **** 	  else
1047:main.c        **** 	    freq += 1;
1048:main.c        **** 	}
1049:main.c        **** 	else if (steps > 150) {
 4317               	.LM555:
 4318 0982 27E9      		ldi r18,-105
 4319 0984 4216      		cp r4,r18
 4320 0986 5104      		cpc r5,__zero_reg__
 4321 0988 00F0      		brlo .L211
1050:main.c        **** 	  if (mode == AM)
 4323               	.LM556:
 4324 098a 8091 0000 		lds r24,mode
 4325 098e 8830      		cpi r24,lo8(8)
 4326 0990 01F4      		brne .L214
1051:main.c        **** 	    freq += 5;
 4328               	.LM557:
 4329 0992 20E0      		ldi r18,0
 4330 0994 30E0      		ldi r19,0
 4331 0996 40EA      		ldi r20,lo8(-96)
 4332 0998 50E4      		ldi r21,lo8(64)
 4333 099a 00C0      		rjmp .L310
 4334               	.L214:
1052:main.c        **** 	  else if (mode == FM)
 4336               	.LM558:
 4337 099c 8091 0000 		lds r24,mode
 4338 09a0 8A30      		cpi r24,lo8(10)
 4339 09a2 01F4      		brne .L215
1053:main.c        **** 	    freq += 25;
 4341               	.LM559:
 4342 09a4 20E0      		ldi r18,0
 4343 09a6 30E0      		ldi r19,0
 4344 09a8 48EC      		ldi r20,lo8(-56)
 4345 09aa 51E4      		ldi r21,lo8(65)
 4346 09ac 00C0      		rjmp .L310
 4347               	.L215:
1054:main.c        **** 	  else
1055:main.c        **** 	    freq += 0.5;
 4349               	.LM560:
 4350 09ae 20E0      		ldi r18,0
 4351 09b0 30E0      		ldi r19,0
 4352 09b2 40E0      		ldi r20,0
 4353 09b4 5FE3      		ldi r21,lo8(63)
 4354 09b6 00C0      		rjmp .L310
 4355               	.L211:
1056:main.c        **** 	}
1057:main.c        **** 	else {
1058:main.c        **** 	  if (mode == AM) {
 4357               	.LM561:
 4358 09b8 8091 0000 		lds r24,mode
 4359 09bc 8830      		cpi r24,lo8(8)
 4360 09be 01F4      		brne .L216
1059:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4362               	.LM562:
 4363 09c0 0B9B      		sbis 0x1,3
 4364 09c2 00C0      		rjmp .L217
 4365               	.L316:
1060:main.c        **** 		freq += 1;
 4367               	.LM563:
 4368 09c4 20E0      		ldi r18,0
 4369 09c6 30E0      		ldi r19,0
 4370 09c8 40E8      		ldi r20,lo8(-128)
 4371 09ca 5FE3      		ldi r21,lo8(63)
 4372 09cc 00C0      		rjmp .L310
 4373               	.L217:
1061:main.c        **** 	    else
1062:main.c        **** 	      freq += 10;
 4375               	.LM564:
 4376 09ce 20E0      		ldi r18,0
 4377 09d0 30E0      		ldi r19,0
 4378 09d2 40E2      		ldi r20,lo8(32)
 4379 09d4 51E4      		ldi r21,lo8(65)
 4380 09d6 00C0      		rjmp .L310
 4381               	.L216:
1063:main.c        **** 	  }
1064:main.c        **** 	  else if (mode == FM)
 4383               	.LM565:
 4384 09d8 8091 0000 		lds r24,mode
 4385 09dc 8A30      		cpi r24,lo8(10)
 4386 09de 01F4      		brne .L218
1065:main.c        **** 	    freq += 2.5;
 4388               	.LM566:
 4389 09e0 20E0      		ldi r18,0
 4390 09e2 30E0      		ldi r19,0
 4391 09e4 40E2      		ldi r20,lo8(32)
 4392 09e6 50E4      		ldi r21,lo8(64)
 4393 09e8 00C0      		rjmp .L310
 4394               	.L218:
1066:main.c        **** 	  else {
1067:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4396               	.LM567:
 4397 09ea 0B9B      		sbis 0x1,3
 4398 09ec 00C0      		rjmp .L219
1068:main.c        **** 		freq += 0.05;
 4400               	.LM568:
 4401 09ee 2DEC      		ldi r18,lo8(-51)
 4402 09f0 3CEC      		ldi r19,lo8(-52)
 4403 09f2 4CE4      		ldi r20,lo8(76)
 4404 09f4 5DE3      		ldi r21,lo8(61)
 4405 09f6 00C0      		rjmp .L310
 4406               	.L219:
1069:main.c        **** 	    else
1070:main.c        **** 	      freq += 2;
 4408               	.LM569:
 4409 09f8 20E0      		ldi r18,0
 4410 09fa 30E0      		ldi r19,0
 4411 09fc 40E0      		ldi r20,0
 4412 09fe 50E4      		ldi r21,lo8(64)
 4413               	.L310:
 4414 0a00 612F      		mov r22,r17
 4415 0a02 702F      		mov r23,r16
 4416 0a04 8F2D      		mov r24,r15
 4417 0a06 9E2D      		mov r25,r14
 4418 0a08 0E94 0000 		call __addsf3
 4419 0a0c 162F      		mov r17,r22
 4420 0a0e 072F      		mov r16,r23
 4421 0a10 F82E      		mov r15,r24
 4422 0a12 E92E      		mov r14,r25
1071:main.c        **** 	  }
1072:main.c        **** 	}
1073:main.c        **** 	last_dir = 0x01;
 4424               	.LM570:
 4425 0a14 81E0      		ldi r24,lo8(1)
 4426 0a16 00C0      		rjmp .L206
 4427               	.L207:
1074:main.c        ****       }
1075:main.c        ****       else if (rot_flag == 0x02) {
 4429               	.LM571:
 4430 0a18 9091 0000 		lds r25,rot_flag
 4431 0a1c 9230      		cpi r25,lo8(2)
 4432 0a1e 01F0      		breq .+2
 4433 0a20 00C0      		rjmp .L206
1076:main.c        **** 	if ((step_timer < 30) && (last_dir == rot_flag)) {
 4435               	.LM572:
 4436 0a22 8091 0000 		lds r24,step_timer
 4437 0a26 9091 0000 		lds r25,step_timer+1
 4438 0a2a 4E97      		sbiw r24,30
 4439 0a2c 00F4      		brsh .L220
 4441               	.LM573:
 4442 0a2e 8091 0000 		lds r24,rot_flag
 4443 0a32 2396      		adiw r28,66-63
 4444 0a34 9FAD      		ldd r25,Y+63
 4445 0a36 2397      		sbiw r28,66-63
 4446 0a38 9813      		cpse r25,r24
 4447 0a3a 00C0      		rjmp .L220
1077:main.c        **** 	  step_timer = 0;
 4449               	.LM574:
 4450 0a3c 1092 0000 		sts step_timer+1,__zero_reg__
 4451 0a40 1092 0000 		sts step_timer,__zero_reg__
1078:main.c        **** 	  steps ++;
 4453               	.LM575:
 4454 0a44 AFEF      		ldi r26,-1
 4455 0a46 4A1A      		sub r4,r26
 4456 0a48 5A0A      		sbc r5,r26
1079:main.c        **** 	}
1080:main.c        **** 	else {
1081:main.c        **** 	  step_timer = 0;
1082:main.c        **** 	  steps = 1;
1083:main.c        **** 	}
1084:main.c        **** 	
1085:main.c        **** 	if (steps > 500) {
 4458               	.LM576:
 4459 0a4a B5EF      		ldi r27,-11
 4460 0a4c 4B16      		cp r4,r27
 4461 0a4e B1E0      		ldi r27,1
 4462 0a50 5B06      		cpc r5,r27
 4463 0a52 00F4      		brsh .L221
 4464 0a54 00C0      		rjmp .L320
 4465               	.L220:
1081:main.c        **** 	  steps = 1;
 4467               	.LM577:
 4468 0a56 1092 0000 		sts step_timer+1,__zero_reg__
 4469 0a5a 1092 0000 		sts step_timer,__zero_reg__
1082:main.c        **** 	}
 4471               	.LM578:
 4472 0a5e 4424      		clr r4
 4473 0a60 4394      		inc r4
 4474 0a62 512C      		mov r5,__zero_reg__
 4475 0a64 00C0      		rjmp .L223
 4476               	.L221:
1086:main.c        **** 	  if (mode == AM)
 4478               	.LM579:
 4479 0a66 8091 0000 		lds r24,mode
 4480 0a6a 8830      		cpi r24,lo8(8)
 4481 0a6c 01F4      		brne .L224
1087:main.c        **** 	    freq -= 20;
 4483               	.LM580:
 4484 0a6e 20E0      		ldi r18,0
 4485 0a70 30E0      		ldi r19,0
 4486 0a72 40EA      		ldi r20,lo8(-96)
 4487 0a74 51E4      		ldi r21,lo8(65)
 4488 0a76 00C0      		rjmp .L311
 4489               	.L224:
1088:main.c        **** 	  else if (mode == FM)
 4491               	.LM581:
 4492 0a78 8091 0000 		lds r24,mode
 4493 0a7c 8A30      		cpi r24,lo8(10)
 4494 0a7e 01F4      		brne .L317
1089:main.c        **** 	    freq -= 50;
 4496               	.LM582:
 4497 0a80 20E0      		ldi r18,0
 4498 0a82 30E0      		ldi r19,0
 4499 0a84 48E4      		ldi r20,lo8(72)
 4500 0a86 52E4      		ldi r21,lo8(66)
 4501 0a88 00C0      		rjmp .L311
 4502               	.L320:
1090:main.c        **** 	  else
1091:main.c        **** 	    freq -= 1;
1092:main.c        **** 	}
1093:main.c        **** 	else if (steps > 150) {
 4504               	.LM583:
 4505 0a8a 27E9      		ldi r18,-105
 4506 0a8c 4216      		cp r4,r18
 4507 0a8e 5104      		cpc r5,__zero_reg__
 4508 0a90 00F0      		brlo .L223
1094:main.c        **** 	  if (mode == AM)
 4510               	.LM584:
 4511 0a92 8091 0000 		lds r24,mode
 4512 0a96 8830      		cpi r24,lo8(8)
 4513 0a98 01F4      		brne .L226
1095:main.c        **** 	    freq -= 5;
 4515               	.LM585:
 4516 0a9a 20E0      		ldi r18,0
 4517 0a9c 30E0      		ldi r19,0
 4518 0a9e 40EA      		ldi r20,lo8(-96)
 4519 0aa0 50E4      		ldi r21,lo8(64)
 4520 0aa2 00C0      		rjmp .L311
 4521               	.L226:
1096:main.c        **** 	  else if (mode == FM)
 4523               	.LM586:
 4524 0aa4 8091 0000 		lds r24,mode
 4525 0aa8 8A30      		cpi r24,lo8(10)
 4526 0aaa 01F4      		brne .L227
1097:main.c        **** 	    freq -= 25;
 4528               	.LM587:
 4529 0aac 20E0      		ldi r18,0
 4530 0aae 30E0      		ldi r19,0
 4531 0ab0 48EC      		ldi r20,lo8(-56)
 4532 0ab2 51E4      		ldi r21,lo8(65)
 4533 0ab4 00C0      		rjmp .L311
 4534               	.L227:
1098:main.c        **** 	  else
1099:main.c        **** 	    freq -= 0.5;
 4536               	.LM588:
 4537 0ab6 20E0      		ldi r18,0
 4538 0ab8 30E0      		ldi r19,0
 4539 0aba 40E0      		ldi r20,0
 4540 0abc 5FE3      		ldi r21,lo8(63)
 4541 0abe 00C0      		rjmp .L311
 4542               	.L223:
1100:main.c        **** 	}
1101:main.c        **** 	else {
1102:main.c        **** 	  if (mode == AM) {
 4544               	.LM589:
 4545 0ac0 8091 0000 		lds r24,mode
 4546 0ac4 8830      		cpi r24,lo8(8)
 4547 0ac6 01F4      		brne .L228
1103:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4549               	.LM590:
 4550 0ac8 0B9B      		sbis 0x1,3
 4551 0aca 00C0      		rjmp .L229
 4552               	.L317:
1104:main.c        **** 		freq -= 1;
 4554               	.LM591:
 4555 0acc 20E0      		ldi r18,0
 4556 0ace 30E0      		ldi r19,0
 4557 0ad0 40E8      		ldi r20,lo8(-128)
 4558 0ad2 5FE3      		ldi r21,lo8(63)
 4559 0ad4 00C0      		rjmp .L311
 4560               	.L229:
1105:main.c        **** 	    else
1106:main.c        **** 	      freq -= 10;
 4562               	.LM592:
 4563 0ad6 20E0      		ldi r18,0
 4564 0ad8 30E0      		ldi r19,0
 4565 0ada 40E2      		ldi r20,lo8(32)
 4566 0adc 51E4      		ldi r21,lo8(65)
 4567 0ade 00C0      		rjmp .L311
 4568               	.L228:
1107:main.c        **** 	  }
1108:main.c        **** 	  else if (mode == FM)
 4570               	.LM593:
 4571 0ae0 8091 0000 		lds r24,mode
 4572 0ae4 8A30      		cpi r24,lo8(10)
 4573 0ae6 01F4      		brne .L230
1109:main.c        **** 	    freq -= 2.5;
 4575               	.LM594:
 4576 0ae8 20E0      		ldi r18,0
 4577 0aea 30E0      		ldi r19,0
 4578 0aec 40E2      		ldi r20,lo8(32)
 4579 0aee 50E4      		ldi r21,lo8(64)
 4580 0af0 00C0      		rjmp .L311
 4581               	.L230:
1110:main.c        **** 	  else {
1111:main.c        **** 	    if (PINE & (1 << ROT_BUTTON)) 
 4583               	.LM595:
 4584 0af2 0B9B      		sbis 0x1,3
 4585 0af4 00C0      		rjmp .L231
1112:main.c        **** 		freq -= 0.05;
 4587               	.LM596:
 4588 0af6 2DEC      		ldi r18,lo8(-51)
 4589 0af8 3CEC      		ldi r19,lo8(-52)
 4590 0afa 4CE4      		ldi r20,lo8(76)
 4591 0afc 5DE3      		ldi r21,lo8(61)
 4592 0afe 00C0      		rjmp .L311
 4593               	.L231:
1113:main.c        **** 	    else
1114:main.c        **** 	      freq -= 2;
 4595               	.LM597:
 4596 0b00 20E0      		ldi r18,0
 4597 0b02 30E0      		ldi r19,0
 4598 0b04 40E0      		ldi r20,0
 4599 0b06 50E4      		ldi r21,lo8(64)
 4600               	.L311:
 4601 0b08 612F      		mov r22,r17
 4602 0b0a 702F      		mov r23,r16
 4603 0b0c 8F2D      		mov r24,r15
 4604 0b0e 9E2D      		mov r25,r14
 4605 0b10 0E94 0000 		call __subsf3
 4606 0b14 162F      		mov r17,r22
 4607 0b16 072F      		mov r16,r23
 4608 0b18 F82E      		mov r15,r24
 4609 0b1a E92E      		mov r14,r25
1115:main.c        **** 	  }
1116:main.c        **** 	}
1117:main.c        ****       last_dir = 0x02;
 4611               	.LM598:
 4612 0b1c 82E0      		ldi r24,lo8(2)
 4613               	.L206:
1118:main.c        ****       }
1119:main.c        ****       //_delay_ms(30);
1120:main.c        **** 
1121:main.c        ****       rot_flag = 0x00;
 4615               	.LM599:
 4616 0b1e 1092 0000 		sts rot_flag,__zero_reg__
 4617 0b22 2396      		adiw r28,66-63
 4618 0b24 8FAF      		std Y+63,r24
 4619 0b26 2397      		sbiw r28,66-63
 4620 0b28 00C0      		rjmp .L148
 4621               	.L204:
1122:main.c        ****     }
1123:main.c        ****     else if (vol_flag) {
 4623               	.LM600:
 4624 0b2a 8091 0000 		lds r24,vol_flag
 4625 0b2e 8823      		tst r24
 4626 0b30 01F4      		brne .+2
 4627 0b32 00C0      		rjmp .L148
1124:main.c        ****       if (vol_timer > 1) {
 4629               	.LM601:
 4630 0b34 8091 0000 		lds r24,vol_timer
 4631 0b38 8230      		cpi r24,lo8(2)
 4632 0b3a 00F4      		brsh .+2
 4633 0b3c 00C0      		rjmp .L232
1125:main.c        **** 	if (PINF & (1 << SQUELCH_BUTTON)) {
 4635               	.LM602:
 4636 0b3e 049B      		sbis 0,4
 4637 0b40 00C0      		rjmp .L233
1126:main.c        **** 	    if (vol_flag == 0x01) {
 4639               	.LM603:
 4640 0b42 8091 0000 		lds r24,vol_flag
 4641 0b46 8130      		cpi r24,lo8(1)
 4642 0b48 01F4      		brne .L234
1127:main.c        **** 	      if(vol<31)
 4644               	.LM604:
 4645 0b4a 8EE1      		ldi r24,lo8(30)
 4646 0b4c 8615      		cp r24,r6
 4647 0b4e 00F0      		brlo .L237
1128:main.c        **** 		vol ++; // Higher means lower 
 4649               	.LM605:
 4650 0b50 6394      		inc r6
 4651 0b52 00C0      		rjmp .L237
 4652               	.L234:
1129:main.c        **** 	      sprintf(buffer,"Vol %d    ", 31-vol);
1130:main.c        **** 	      lcd_goto(0x40);
1131:main.c        **** 	      lcd_puts(buffer);
1132:main.c        **** 	    }
1133:main.c        **** 	    else if (vol_flag == 0x02) {
 4654               	.LM606:
 4655 0b54 8091 0000 		lds r24,vol_flag
 4656 0b58 8230      		cpi r24,lo8(2)
 4657 0b5a 01F4      		brne .L236
1134:main.c        **** 	      if(vol>0)
 4659               	.LM607:
 4660 0b5c 6110      		cpse r6,__zero_reg__
1135:main.c        **** 		vol --;
 4662               	.LM608:
 4663 0b5e 6A94      		dec r6
 4664               	.L237:
1136:main.c        **** 	      sprintf(buffer,"Vol %d    ", 31-vol);
 4666               	.LM609:
 4667 0b60 8FE1      		ldi r24,lo8(31)
 4668 0b62 90E0      		ldi r25,0
 4669 0b64 8619      		sub r24,r6
 4670 0b66 9109      		sbc r25,__zero_reg__
 4671 0b68 9F93      		push r25
 4672 0b6a 8F93      		push r24
 4673 0b6c 80E0      		ldi r24,lo8(.LC21)
 4674 0b6e 90E0      		ldi r25,hi8(.LC21)
 4675 0b70 9F93      		push r25
 4676 0b72 8F93      		push r24
 4677 0b74 DF92      		push r13
 4678 0b76 CF92      		push r12
 4679 0b78 0E94 0000 		call sprintf
1137:main.c        **** 	      lcd_goto(0x40);
 4681               	.LM610:
 4682 0b7c 80E4      		ldi r24,lo8(64)
 4683 0b7e 0E94 0000 		call lcd_goto
1138:main.c        **** 	      lcd_puts(buffer);
 4685               	.LM611:
 4686 0b82 C601      		movw r24,r12
 4687 0b84 0E94 0000 		call lcd_puts
 4688 0b88 0F90      		pop __tmp_reg__
 4689 0b8a 0F90      		pop __tmp_reg__
 4690 0b8c 0F90      		pop __tmp_reg__
 4691 0b8e 0F90      		pop __tmp_reg__
 4692 0b90 0F90      		pop __tmp_reg__
 4693 0b92 0F90      		pop __tmp_reg__
 4694               	.L236:
1139:main.c        **** 	    }
1140:main.c        **** 	    
1141:main.c        **** 	    err = updateVolumeSquelch(vol, squelch);
 4696               	.LM612:
 4697 0b94 672D      		mov r22,r7
 4698 0b96 862D      		mov r24,r6
 4699 0b98 0E94 0000 		call updateVolumeSquelch
1142:main.c        **** 	    
1143:main.c        **** 	    if (err) {
 4701               	.LM613:
 4702 0b9c 8823      		tst r24
 4703 0b9e 01F4      		brne .+2
 4704 0ba0 00C0      		rjmp .L238
1144:main.c        **** 	      sprintf(buffer,"Err Vol %x         ",err);
 4706               	.LM614:
 4707 0ba2 1F92      		push __zero_reg__
 4708 0ba4 8F93      		push r24
 4709 0ba6 80E0      		ldi r24,lo8(.LC22)
 4710 0ba8 90E0      		ldi r25,hi8(.LC22)
 4711 0baa 00C0      		rjmp .L312
 4712               	.L233:
1145:main.c        **** 	      lcd_goto(0x40);
1146:main.c        **** 	      lcd_puts(buffer);	
1147:main.c        **** 	    }      
1148:main.c        **** 	  }
1149:main.c        **** 	  else {
1150:main.c        **** 	    if (vol_flag == 0x02) {
 4714               	.LM615:
 4715 0bac 8091 0000 		lds r24,vol_flag
 4716 0bb0 8230      		cpi r24,lo8(2)
 4717 0bb2 01F4      		brne .L239
1151:main.c        **** 	      if(squelch<31)
 4719               	.LM616:
 4720 0bb4 9EE1      		ldi r25,lo8(30)
 4721 0bb6 9715      		cp r25,r7
 4722 0bb8 00F0      		brlo .L242
1152:main.c        **** 		squelch ++; 
 4724               	.LM617:
 4725 0bba 7394      		inc r7
 4726 0bbc 00C0      		rjmp .L242
 4727               	.L239:
1153:main.c        **** 	      sprintf(buffer,"Sq %d    ", squelch);
1154:main.c        **** 	      lcd_goto(0x40);
1155:main.c        **** 	      lcd_puts(buffer);
1156:main.c        **** 	    }
1157:main.c        **** 	    else if (vol_flag == 0x01) {
 4729               	.LM618:
 4730 0bbe 8091 0000 		lds r24,vol_flag
 4731 0bc2 8130      		cpi r24,lo8(1)
 4732 0bc4 01F4      		brne .L241
1158:main.c        **** 	      if(squelch>0)
 4734               	.LM619:
 4735 0bc6 7110      		cpse r7,__zero_reg__
1159:main.c        **** 		squelch --;
 4737               	.LM620:
 4738 0bc8 7A94      		dec r7
 4739               	.L242:
1160:main.c        **** 	      sprintf(buffer,"Sq %d    ", squelch);
 4741               	.LM621:
 4742 0bca 1F92      		push __zero_reg__
 4743 0bcc 7F92      		push r7
 4744 0bce 80E0      		ldi r24,lo8(.LC23)
 4745 0bd0 90E0      		ldi r25,hi8(.LC23)
 4746 0bd2 9F93      		push r25
 4747 0bd4 8F93      		push r24
 4748 0bd6 DF92      		push r13
 4749 0bd8 CF92      		push r12
 4750 0bda 0E94 0000 		call sprintf
1161:main.c        **** 	      lcd_goto(0x40);
 4752               	.LM622:
 4753 0bde 80E4      		ldi r24,lo8(64)
 4754 0be0 0E94 0000 		call lcd_goto
1162:main.c        **** 	      lcd_puts(buffer);
 4756               	.LM623:
 4757 0be4 C601      		movw r24,r12
 4758 0be6 0E94 0000 		call lcd_puts
 4759 0bea 0F90      		pop __tmp_reg__
 4760 0bec 0F90      		pop __tmp_reg__
 4761 0bee 0F90      		pop __tmp_reg__
 4762 0bf0 0F90      		pop __tmp_reg__
 4763 0bf2 0F90      		pop __tmp_reg__
 4764 0bf4 0F90      		pop __tmp_reg__
 4765               	.L241:
1163:main.c        **** 	    }
1164:main.c        **** 	    
1165:main.c        **** 	    err = updateVolumeSquelch(vol, squelch);
 4767               	.LM624:
 4768 0bf6 672D      		mov r22,r7
 4769 0bf8 862D      		mov r24,r6
 4770 0bfa 0E94 0000 		call updateVolumeSquelch
1166:main.c        **** 	    
1167:main.c        **** 	    if (err) {
 4772               	.LM625:
 4773 0bfe 8823      		tst r24
 4774 0c00 01F0      		breq .L238
1168:main.c        **** 	      sprintf(buffer,"Err Sq %x         ",err);
 4776               	.LM626:
 4777 0c02 1F92      		push __zero_reg__
 4778 0c04 8F93      		push r24
 4779 0c06 80E0      		ldi r24,lo8(.LC24)
 4780 0c08 90E0      		ldi r25,hi8(.LC24)
 4781               	.L312:
 4782 0c0a 9F93      		push r25
 4783 0c0c 8F93      		push r24
 4784 0c0e DF92      		push r13
 4785 0c10 CF92      		push r12
 4786 0c12 0E94 0000 		call sprintf
1169:main.c        **** 	      lcd_goto(0x40);
 4788               	.LM627:
 4789 0c16 80E4      		ldi r24,lo8(64)
 4790 0c18 0E94 0000 		call lcd_goto
1170:main.c        **** 	      lcd_puts(buffer);	
 4792               	.LM628:
 4793 0c1c C601      		movw r24,r12
 4794 0c1e 0E94 0000 		call lcd_puts
 4795 0c22 0F90      		pop __tmp_reg__
 4796 0c24 0F90      		pop __tmp_reg__
 4797 0c26 0F90      		pop __tmp_reg__
 4798 0c28 0F90      		pop __tmp_reg__
 4799 0c2a 0F90      		pop __tmp_reg__
 4800 0c2c 0F90      		pop __tmp_reg__
 4801               	.L238:
1171:main.c        **** 	    }      
1172:main.c        **** 	  }
1173:main.c        **** 	vol_timer = 0;
 4803               	.LM629:
 4804 0c2e 1092 0000 		sts vol_timer,__zero_reg__
 4805               	.L232:
1174:main.c        ****       }
1175:main.c        ****       vol_flag = 0x00;
 4807               	.LM630:
 4808 0c32 1092 0000 		sts vol_flag,__zero_reg__
 4809 0c36 00C0      		rjmp .L148
 4824               	.Lscope30:
 4825               		.section	.progmem.data,"a",@progbits
 4828               	string_intro_row2.2453:
 4829 0000 5374 6172 		.string	"Starting radio"
 4829      7469 6E67 
 4829      2072 6164 
 4829      696F 00
 4832               	string_intro_row1.2452:
 4833 000f 2A2A 2A20 		.string	"*** SM6VFZ"
 4833      534D 3656 
 4833      465A 00
 4834               		.local	ftw_botbot.2406
 4835               		.comm	ftw_botbot.2406,4,1
 4836               		.local	ftw_bottop.2405
 4837               		.comm	ftw_bottop.2405,4,1
 4838               		.local	ftw_topbot.2404
 4839               		.comm	ftw_topbot.2404,4,1
 4840               		.local	ftw_toptop.2403
 4841               		.comm	ftw_toptop.2403,4,1
 4842               		.comm	rffe_rx_att,1,1
 4843               		.comm	rx_att,1,1
 4844               	.global	pll_n
 4845               		.section .bss
 4848               	pll_n:
 4849 0000 0000      		.zero	2
 4850               		.comm	tx,2,1
 4851               		.comm	bandf,2,1
 4852               	.global	vol_timer
 4853               		.data
 4856               	vol_timer:
 4857 0000 FF        		.byte	-1
 4858               	.global	band_timer
 4861               	band_timer:
 4862 0001 FF        		.byte	-1
 4863               		.comm	tx_att,1,1
 4864               		.comm	band,1,1
 4865               		.comm	mode,1,1
 4866               		.comm	step_timer,2,1
 4867               		.comm	vol_flag,1,1
 4868               		.comm	timer_flag,1,1
 4869               		.comm	band_flag,1,1
 4870               		.comm	mode_flag,1,1
 4871               		.comm	rot_flag,1,1
 4888               		.text
 4890               	.Letext0:
 4891               		.ident	"GCC: (GNU) 4.9.2"
 4892               	.global __do_copy_data
 4893               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccybRbcS.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccybRbcS.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccybRbcS.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccybRbcS.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccybRbcS.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccybRbcS.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccybRbcS.s:125    .text:0000000000000000 __vector_15
                            *COM*:0000000000000002 step_timer
     /tmp/ccybRbcS.s:172    .text:0000000000000040 __vector_12
                            *COM*:0000000000000001 timer_flag
     /tmp/ccybRbcS.s:204    .text:000000000000005e __vector_3
                            *COM*:0000000000000001 rot_flag
     /tmp/ccybRbcS.s:295    .text:00000000000000a4 __vector_4
     /tmp/ccybRbcS.s:386    .text:00000000000000ea __vector_5
     /tmp/ccybRbcS.s:483    .text:000000000000013c __vector_6
     /tmp/ccybRbcS.s:580    .text:000000000000018e __vector_7
                            *COM*:0000000000000001 vol_flag
     /tmp/ccybRbcS.s:677    .text:00000000000001e0 __vector_8
     /tmp/ccybRbcS.s:774    .text:0000000000000232 TWIinit
     /tmp/ccybRbcS.s:796    .text:0000000000000240 TWIStart
     /tmp/ccybRbcS.s:823    .text:0000000000000250 TWIStop
     /tmp/ccybRbcS.s:842    .text:0000000000000258 TWIWrite
     /tmp/ccybRbcS.s:872    .text:000000000000026c TWIReadACK
     /tmp/ccybRbcS.s:901    .text:0000000000000280 TWIReadNACK
     /tmp/ccybRbcS.s:930    .text:0000000000000294 TWIGetStatus
     /tmp/ccybRbcS.s:952    .text:000000000000029c TWI_write_byte
     /tmp/ccybRbcS.s:1082   .text:000000000000030c TWI_read_byte
     /tmp/ccybRbcS.s:1192   .text:0000000000000370 TWI_write_word
     /tmp/ccybRbcS.s:1360   .text:0000000000000400 TWI_write_3bytes
     /tmp/ccybRbcS.s:1545   .text:00000000000004a6 TWI_write_4bytes
     /tmp/ccybRbcS.s:1749   .text:0000000000000560 TWI_write_5bytes
     /tmp/ccybRbcS.s:1971   .text:000000000000062e updateVolumeSquelch
     /tmp/ccybRbcS.s:2001   .text:0000000000000648 readClar
     /tmp/ccybRbcS.s:2021   .text:000000000000064e updateRFFE
                            *COM*:0000000000000001 rx_att
     /tmp/ccybRbcS.s:4848   .bss:0000000000000000 pll_n
                            *COM*:0000000000000002 tx
                            *COM*:0000000000000002 bandf
     /tmp/ccybRbcS.s:2103   .text:00000000000006b0 updateFreq
                            *COM*:0000000000000001 mode
     /tmp/ccybRbcS.s:4839   .bss:000000000000000e ftw_toptop.2403
     /tmp/ccybRbcS.s:4837   .bss:000000000000000a ftw_topbot.2404
     /tmp/ccybRbcS.s:4835   .bss:0000000000000006 ftw_bottop.2405
                             .bss:0000000000000002 ftw_botbot.2406
     /tmp/ccybRbcS.s:2349   .text:0000000000000886 updateSettings
                            *COM*:0000000000000001 tx_att
     /tmp/ccybRbcS.s:2497   .text:0000000000000950 adcInit
     /tmp/ccybRbcS.s:2522   .text:000000000000095c Timer0Init
     /tmp/ccybRbcS.s:2549   .text:000000000000096c Timer1Init
     /tmp/ccybRbcS.s:2637   .text.startup:0000000000000000 main
     /tmp/ccybRbcS.s:4832   .progmem.data:000000000000000f string_intro_row1.2452
     /tmp/ccybRbcS.s:4828   .progmem.data:0000000000000000 string_intro_row2.2453
                            *COM*:0000000000000001 mode_flag
                            *COM*:0000000000000001 band_flag
                            *COM*:0000000000000001 band
                            *COM*:0000000000000001 rffe_rx_att
     /tmp/ccybRbcS.s:4856   .data:0000000000000000 vol_timer
     /tmp/ccybRbcS.s:4861   .data:0000000000000001 band_timer

UNDEFINED SYMBOLS
__subsf3
__addsf3
__mulsf3
__fixunssfsi
floor
fmod
__divsf3
__fixsfsi
__nesf2
__ltsf2
lcd_init
lcd_clrscr
strcpy_P
lcd_puts
lcd_goto
sprintf
strcpy
__do_copy_data
__do_clear_bss
